<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>V8垃圾回收机制</title>
    <url>/2021/04/17/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>​    JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。搞清楚内存中的垃圾是如何回收的对理解内存机制和写出高性能的代码具有巨大的帮助。下面将主要介绍V8引擎的垃圾回收机制。</p>
<span id="more"></span>

<p>JavaScript、Java、Python 等语言，<strong>产生的垃圾数据是由垃圾回收器来释放的</strong>，并不需要手动通过代码来释放。</p>
<h4 id="调用栈中的数据如何回收"><a href="#调用栈中的数据如何回收" class="headerlink" title="调用栈中的数据如何回收"></a>调用栈中的数据如何回收</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客邦 &quot;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> c = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">      <span class="keyword">var</span> d = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    showName()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>​    执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如下图所示。与此同时，还有一个<strong>记录当前执行状态的指针（称为 ESP）</strong>，指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p>
<p>​    接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，<strong>这个下移操作就是销毁 showName 函数执行上下文的过程</strong>。</p>
<p><img src="/2021/04/17/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210304112315040.png" alt="image-20210304112315040"></p>
<p>所以说，当一个函数执行结束之后，<strong>JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文</strong>。</p>
<h4 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h4><p><strong>代际假说（The Generational Hypothesis）</strong>：</p>
<ul>
<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>
<li>第二个是不死的对象，会活得更久。</li>
</ul>
<p><strong>分代收集</strong>：</p>
<p>​    在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>
<ul>
<li><strong>副垃圾回收器，主要负责新生代的垃圾回收。</strong></li>
<li><strong>主垃圾回收器，主要负责老生代的垃圾回收。</strong></li>
</ul>
<p><strong>垃圾回收器的工作流程</strong>：</p>
<p>​    不管是主垃圾回收器还是副垃圾回收器都遵循以下这套公共的执行流程：</p>
<p>​    1、<strong>标记空间中活动对象和非活动对象</strong>。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p>
<p>​    2、<strong>回收非活动对象所占据的内存</strong>。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>
<p>​    3、<strong>内存整理</strong>。频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当出现量不连续的内存碎片后，我们再想分配一个较大的连续空间就会出现内存不足的情况。</p>
<h4 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h4><p>​    副垃圾回收器主要负责新生区的垃圾回收，用<strong>Scavenge 算法</strong>来处理。其原理就是：把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，新加入的对象都会存放到对象区域，<strong>当对象区域快被写满时</strong>，就需要执行一次垃圾清理操作。</p>
<p><img src="/2021/04/17/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210304114240567.png" alt="image-20210304114240567"></p>
<p>其回收过程如下：</p>
<p>​    1、对对象区域中的垃圾做标记，活动对象和非活动会对象；</p>
<p>​    2、标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些<strong>仍然存活的对象</strong>复制到空闲区域中，<strong>同时它还会把这些对象有序地排列起来，所以这个复制过程</strong>，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>
<p>​    3、完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。</p>
<p><strong>对象晋升策略</strong>：由于为了执行效率，新生区的空间通常会被设置的比较小，所以很容易被存满，为此JavaScript引擎引入了晋升策略，即：<strong>经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</strong></p>
<h4 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h4><p>​    老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p>
<p>​    主垃圾回收器是采用<strong>标记 - 清除（Mark-Sweep）</strong>的算法进行垃圾回收的。</p>
<p>1、<strong>对垃圾数据做标记</strong>。当调用栈中的ESP指向下一个执行上下文后，上一个执行上下文中引用对象在堆中的数据就会被当做垃圾数据被<strong>标为红色</strong>，而当前正被ESP指向的指向上下文中指针指向的栈中数据会被标为<strong>活动数据</strong>。</p>
<p>2、<strong>垃圾数据的清除</strong>。使用<strong>Mark-Sweep</strong>算法清除掉被标记为红色的垃圾数据。</p>
<p><img src="/2021/04/17/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210304115832389.png" alt="image-20210304115832389.png"></p>
<p>3、<strong>内存整理</strong>。使用<strong>标记 - 整理（Mark-Compact）</strong>对内存碎片进行整理。</p>
<p><img src="/2021/04/17/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210304115856708.png" alt="image-20210304115856708"></p>
<h4 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h4><p>​    于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p>
<p>​    为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记（Incremental Marking）算法</strong>。如下图所示：</p>
<p><img src="/2021/04/17/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210304120112556.png" alt="image-20210304120112556"></p>
<p>​    使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器工作原理</tag>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>this的指向问题</title>
    <url>/2021/04/18/this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>​    this指针是前端面试过程中最常考的问题之一，也是比较坑的问题之一，为了避免多次被坑先将this指针的相关问题记录如下，主要包括判断this指针的几类常见的方法、改变this指针的几种方法以及一些面试真题。</p>
<span id="more"></span>

<h4 id="如何判断this的指向"><a href="#如何判断this的指向" class="headerlink" title="如何判断this的指向"></a>如何判断this的指向</h4><p>在使用 this 时，为了避坑，你要谨记以下四点：</p>
<ol>
<li>当函数作为对象的方法调用时，函数中的 this 就是该对象；</li>
<li>当函数被正常调用时，<strong>在严格模式下，this 值是 undefined</strong>，非严格模式下 this 指向的是全局对象 window；</li>
<li>嵌套函数中的 this 不会继承外层函数的 this 值。</li>
<li>我们还提了一下箭头函数，因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。</li>
<li>当this遇到return时，如果返回值是一个对象，那么this指向的是构造函数的实例但是并没有被返回，如果返回值不是一个对象，那么this还是指向构造函数创建的实例。</li>
</ol>
<p>下面从几道例题中去验证：</p>
<ol>
<li><p>直接使用的函数this指向window</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> user= <span class="string">&quot;呵呵&quot;</span>，</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.user),</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>),</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// window</span></span><br></pre></td></tr></table></figure></li>
<li><p>嵌套函数中的 this 不会继承外层函数的 this 值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> user = <span class="string">&quot;呵呵&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="built_in">this</span>.user);</span><br><span class="line">    &#125;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">o();</span><br></pre></td></tr></table></figure></li>
<li><p>当函数作为对象的方法调用时，函数中的 this 就是该对象，且永远指向最后调用它的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目一</span></span><br><span class="line"><span class="keyword">var</span> o=&#123;</span><br><span class="line">	a:<span class="number">10</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">    	a=<span class="number">12</span>,</span><br><span class="line">        fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.b.fn() <span class="comment">//12</span></span><br><span class="line"><span class="comment">//题目二</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	a:<span class="number">10</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">    	a:<span class="number">12</span></span><br><span class="line">        fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    		<span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">        	<span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j = o.b.fn;</span><br><span class="line">j(); <span class="comment">// undefined //window</span></span><br></pre></td></tr></table></figure></li>
<li><p>构造函数中的this指向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&#x27;呵呵&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Fn()</span><br><span class="line"><span class="built_in">console</span>.log(p.user) <span class="comment">// 呵呵</span></span><br></pre></td></tr></table></figure></li>
<li><p>当this遇到return时</p>
<p>如果返回值是一个对象，那么this指向的是构造函数的实例但是并没有被返回，如果返回值不是一个对象，那么this还是指向构造函数创建的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//undefined</span></span><br><span class="line">==============================</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//undefined</span></span><br><span class="line">==============================</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//呵呵</span></span><br><span class="line">==============================</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//呵呵</span></span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数中的this指向</p>
<p>箭头函数是ES6中的特性，箭头函数没有执行上下文本所以没有this，它会沿用/捕获外部环境的this。也就是说，箭头函数内部与外部的this是保持一致的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 题目一 */</span></span><br><span class="line"><span class="built_in">this</span>.a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">	a:<span class="number">40</span>,</span><br><span class="line">    init:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	<span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">        go.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> go</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = test.init()</span><br><span class="line">p()</span><br><span class="line"><span class="keyword">new</span> (test.init())()</span><br><span class="line"><span class="comment">/* 题目二 */</span></span><br><span class="line"><span class="built_in">this</span>.a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">	a:<span class="number">40</span>,</span><br><span class="line">    init:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	<span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">        go.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> go</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = test.init()</span><br><span class="line">p()</span><br><span class="line"><span class="keyword">new</span> (test.init())()</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="如何改变this的指向"><a href="#如何改变this的指向" class="headerlink" title="如何改变this的指向"></a>如何改变this的指向</h4><p><strong>1、call()和apply()</strong></p>
<p>​    **call():**第一个参数表示要把this指向的新目标，第二个之后的参数其实相当于传参，参数以逗号隔开（性能较apply略好）。</p>
<p>​    用法：a.call(b,1,2)；表示要把a函数的this指向修改为b的this指向，并运行a函数，传入参数是（1,2）</p>
<p>​    <strong>apply()：</strong>第一个参数同上，第二个参数接收一个数组，里面也是传参，只是以数组的方式，相当于arguments</p>
<p>用法：a.apply(b,[1,2])；表示要把a函数的this指向修改为b的this指向，并运行a函数，传进去的参数是(1,2);</p>
<p>*<strong>注意：即使只有一个参数的话，也要是数组的形式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//call 的传参和apply的传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">arg1,arg2</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name,arg1,arg2);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name : <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  say : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">say.call(obj,<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>);<span class="comment">//tom one two</span></span><br><span class="line">say.spply(obj,[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>]);<span class="comment">//tom one two  效果一样</span></span><br></pre></td></tr></table></figure>

<p><strong>2、bind()</strong></p>
<p>​    作用：bind()方法会创建一个新的函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入bind()方法的第一个参数作为this，传入bind()的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p>​    用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar : <span class="number">1</span>,</span><br><span class="line">    eventBind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">&#x27;.someClass&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="comment">/* Act on the event */</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.bar);      <span class="comment">//1</span></span><br><span class="line">        &#125;.bind(<span class="built_in">this</span>));<span class="comment">//这里的this是eventBind的this，即指向的是foo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</p>
<p><strong>3、new</strong></p>
<p>new的运行原理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Animal(<span class="string">&#x27;cat&#x27;</span>) = &#123;<span class="comment">//类似这样</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;<span class="comment">//先定义一个空对象</span></span><br><span class="line">    obj.__proto__ = Animal.prototype;</span><br><span class="line">    <span class="comment">//把 obj 的__proto__ 指向构造函数 Animal 的原型对象 prototype，</span></span><br><span class="line">    <span class="comment">//此时便建立了 obj 对象的原型链：</span></span><br><span class="line">    <span class="comment">//obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null</span></span><br><span class="line">    <span class="keyword">var</span> result = Animal.call(obj,<span class="string">&quot;cat&quot;</span>);<span class="comment">//改变this指向，从Animal改变到obj上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span>? result : obj; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&quot;追梦子&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn();<span class="comment">//this指向a</span></span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//追梦子</span></span><br></pre></td></tr></table></figure>

<p><strong>4、return</strong></p>
<p>​    在构造函数的时候，使用return进行返回一个Object的时候，当去new一个实例对象的时候，会将this指向改变为return的Object；</p>
<p>​     用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&#x27;追梦子&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;user&quot;</span> : <span class="string">&quot;111&quot;</span></span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//111</span></span><br></pre></td></tr></table></figure>

<h4 id="使用fn-apply-this-arr-和fn-…arr-的区别"><a href="#使用fn-apply-this-arr-和fn-…arr-的区别" class="headerlink" title="使用fn.apply(this,arr)和fn(…arr)的区别"></a>使用fn.apply(this,arr)和fn(…arr)的区别</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">当然，在这道题目中用fn(...arr)也能成功的输出</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目描述</span></span><br><span class="line"><span class="comment">	将数组 arr 中的元素作为调用函数 fn 的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">greeting, name, punctuation</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> greeting + <span class="string">&#x27;, &#x27;</span> + name + (punctuation || <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;Ellie&#x27;</span>, <span class="string">&#x27;!&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argsAsArray</span>(<span class="params">fn, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, arr);</span><br><span class="line">    <span class="comment">//return fn(...arr)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：<a href="https://segmentfault.com/q/1010000004566233">https://segmentfault.com/q/1010000004566233</a></p>
<h4 id="面试真题"><a href="#面试真题" class="headerlink" title="面试真题"></a>面试真题</h4><ol>
<li><p>this的指向（from:字节跳动技术中台一面）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">	x: <span class="number">1</span>,</span><br><span class="line">    print () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.print();  <span class="comment">//1</span></span><br><span class="line"><span class="keyword">let</span> print = a.print()</span><br><span class="line">print();  <span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//问：如何改变this的指向</span></span><br><span class="line"><span class="keyword">let</span> print = a.print.bind(a);</span><br><span class="line">print()</span><br></pre></td></tr></table></figure></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>分层和合成机制</title>
    <url>/2021/09/06/%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>​    每个显示器都有固定的刷新频率，通常是60HZ（即每秒刷新60次），更新的图片都来自于显卡中<strong>前缓冲区</strong>。显卡会合成新的图像，并将其保存到<strong>后缓冲区</strong>，一旦新合成的图像写到后缓冲区，系统就会让<strong>后缓冲区</strong>和<strong>前缓冲区</strong>交换，以此保证显示器读取到新合成的图像。在浏览器中，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。由于大多数屏幕的更新频率都是60次/秒，这就意味着<strong>渲染引擎</strong>每秒需要更新60张图片到显卡的后缓存区，一旦渲染引擎生成某些帧（一张图片就是一帧）的时间过久，用户就会感到卡顿。Chrome浏览器引入了<strong>分层</strong>和<strong>合成</strong>机制，以此来解决卡顿或每帧生成时间过久的问题。</p>
<span id="more"></span>



<h3 id="如何生成一帧图像"><a href="#如何生成一帧图像" class="headerlink" title="如何生成一帧图像"></a>如何生成一帧图像</h3><p>浏览器渲染流水线中任意一帧生成的方式有：<strong>重排</strong>、<strong>重绘</strong>和<strong>合成</strong>三种。三种方式生成一帧图像的路径是不同的，但通常路径越长，生成图像说花费的时间就越多。</p>
<p><strong>重排</strong>：需要重新根据CSSOM和DOM来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍。</p>
<p><strong>重绘</strong>：需要重新计算绘制信息，并触发绘制操作之后的一系列操作。</p>
<p><strong>合成</strong>：不需要触发布局和绘制两个阶段，如果采用了GPU，那么合成效率更高。</p>
<p>所以，渲染引擎生成一帧图像的几种方式按照效率会优先使用合成，若不能满足需求，那么再使用重排或者重绘；</p>
<h3 id="分层与合成"><a href="#分层与合成" class="headerlink" title="分层与合成"></a>分层与合成</h3><p>​    通常页面的组成是非常复杂的，如果没有采用分层机制，从布局树直接生成目标图片的话一旦页面有很小的变化都会触发重排或者重绘，这种绘制策略会严重影响页面的渲染效率。为了提升每帧的渲染效率，我们可以将一张网页想象成多个图片叠加在一起的，每张图片对应一个图层，比如透明度、边框影阴、是否可旋转等，最后将这些图层叠加在一起后呈现最终的图片。将素材分解为多个图层的操作就称为<strong>分层</strong>，最后将这些图层合并到一起的操作就称为<strong>合成</strong>。</p>
<p>​    假设一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者 Alpha 渐变，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。</p>
<h4 id="分层与合成-1"><a href="#分层与合成-1" class="headerlink" title="分层与合成"></a>分层与合成</h4><p>​    在Chrome的渲染流水线中，分层体现在生成<strong>布局树</strong>之后，渲染引擎会根据布局树的特点将其转换为<strong>层树</strong>（Layer Tree）。层树的每一个节点都对应着一个图层，下一步的绘制就依赖于层树中的节点。绘制阶段其实并不是真正地绘出图片，而是将<strong>绘制指令</strong>组合成一个列表。有了绘制列表之后，光栅化就是按照绘制列表中的指令生成图片，每一个图层对应一张图片，<strong>合成线程</strong>有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。<strong>合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的</strong>。</p>
<h4 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h4><p>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。</p>
<p>​    通常情况下，页面的内容要比屏幕大的多，如果想要显示一个页面要等所有的图层都生成完了再进行合成的话会产生一些不必要的开销或者图片合成的时间变得更久。因此，<strong>合成线程</strong>会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，但是有时候即使优先绘制优先级高的图块也会因为<strong>纹理上传</strong>的原因耗费不少时间。</p>
<p>​    为此，Chrome 又采取了一个策略：<strong>在首次合成图块的时候使用一个低分辨率的图片</strong>。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。</p>
<h3 id="使用分层技术优化代码"><a href="#使用分层技术优化代码" class="headerlink" title="使用分层技术优化代码"></a>使用分层技术优化代码</h3><p>​    使用will-change来告诉渲染引擎对该元素做一些特效变换。当我们需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	will-change: transform, opacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。<strong>这也是 CSS 动画比 JavaScript 动画高效的原因</strong>。</p>
<p><strong>参考文献</strong>：《浏览器工作原理与实践》-李兵</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>ChinaVis2019参赛总结</title>
    <url>/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​    本次ChinaVis挑战赛于7月21-24日在成都举行，由于本人家住成都较近的原因很荣幸能够报名并参加了这次挑战赛会议，期间有各行业的大佬做可视化的前沿发展汇报及最新论文汇报，让我收获颇丰，其详情请关注ChinaVis2019可视化官网。本篇博客主要用来总结本人本次与同学共同参加并完成挑战赛题目的收获与不足，以及参会时记录的挑战赛1的答案详情、听取到的其他获奖作品后的感想，以备自己今后参考所用。</p>
<span id="more"></span>

<h3 id="参赛感想"><a href="#参赛感想" class="headerlink" title="参赛感想"></a>参赛感想</h3><p>我们团队作为第一次参加该比赛的新人来说，仅仅在挑战赛1中获得了优秀奖，虽然谈不上太差但却有很多在做比赛时的不足之处值得我好好思考，在做比赛时我们遇到的主要问题我归纳了有以下：</p>
<p>1）花的时间太少：由于我们团队都是今年的本科毕业生，要一边做毕业设计一边做比赛，最终导致真正花在做比赛上的时间实际只有10天左右。在参会时，我与其他获奖的参赛队伍交流后得知，他们的平均用时都在30天左右甚至更多。（可能对于真正的大佬来说时间根本不是问题，但对于我们这种水平的队来说多一些时间还是挺重要的）。</p>
<p>2）不应该最后才写论文和答卷：我认为我们这次最大的失误就是临到交卷的前一天晚上才开始写论文和答卷（实际上其过程说是在凑比较准确一点)，在写的过程中遇到各种各样的问题，很多之前在做系统和分析数据时看似好像已经分析出的东西在写答卷时又变得不清晰和无从下手。所以，我认为应该一边做系统一边写答卷。</p>
<p>3）没有针对挑战赛给出的问题有针对性的设计和作答：刚开始我们就是在从整体的角度去设计这个系统要做成怎么怎么样，怎样才能吸引专家眼球之类的，然后就是从别人历年发表过的可视化文章中去找我们可能能用到的可视化图形，但却忽略了问题本身。这样做，到最后写答卷时导致的结果就是，你会发现其实你每个问题感觉都有所涉及，但又每个问题你都没有解决。就比如在我们系统中的“场馆时间安排图”——能够勉强说明场馆的开会的时间段，但别人问题问的是让你找出每个场馆的时间安排，这包括大致的开会时间和会议名称；再比如“人员的分类”——勉强能把不同类型的人员聚类（精不精确先不说），但却不能说明每一类都是什么人。当然从做可视化的角度来说这样做无可厚非，但是我们是在比赛啊。我认为一开始就应该针对每个问题去寻找可以有效解决问题的方法不管是通过后端数据处理得到还是前端可视化图形得到，这样才能既节约时间由能有效的解答问题。</p>
<p>4）应该在答卷中尽可能多的写出自己分析的结果：在写答卷时，因为比较匆忙，所以只把自己觉得正确的地方写上去了很多之前分析出的一些较小或则与答案有关的结果并没有写上，且做出的场馆拥堵情况热力图和人员脸谱图因为没有实现联动而在没有在答卷中出现。最后在参会听老师公布答案时发现，我们分析出的很多小细节都与答案有关，我想如果把这些都写上我们的名次应该可以再上一个档次。</p>
<p>5）图与图之间的搭配问题：某些用于解决某问题的图搭配起来实际不能真正的解决该问题，这也是我们在设计之初考虑不周的结果，由此导致花费了时间在制作可视化的图形上，所以在设计之初我们应该想好了设计出的图形搭配起来是否能真正解决问题而不要盲目的开始制作图形。</p>
<p>以上就是我总结出的在本次比赛中的不足之处，下面附上我们团队做出的系统中的部分系统截图：<br><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055143400.png" alt="1620055143400"></p>
<p>点击每个会场房间可单独显示每个房间的人数变化的折线图，用于详细探索某个会场或某个格子在此时间段的人员数量变化情况。同时选择多个会场，可同时在同一坐标下显示多个房间人数变化情况，以便我们对每个会场做对比分析。</p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055210105.png" alt="1620055210105"></p>
<p>该视图着重观察主会场以及四个分会场随时间的人数变化以及稳定度变化（出度人数除以入度人数），借此来判断该会场是否存在人数庞大的时间段或者人员流动比较频繁的时间段，推测此会场是否在举行会议或者比赛等活动。其中，黄色颜色越深代表着会场人员变动频率越高说明属于休会时段，颜色越前表示会场人员走动越低说明处于开会时间段。<br><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055253742.png" alt="1620055253742"></p>
<p>  对上面经过t-sne聚类后的人员进行圈选可以查看该类人员的轨迹。点击每个聚类好的小团会在场地图中弹出该类人员的行走路线，且在折线图中显示该类人员中去过各房间的差异，从而帮助分析人员类别。</p>
<h3 id="挑战赛部分答案记录"><a href="#挑战赛部分答案记录" class="headerlink" title="挑战赛部分答案记录"></a>挑战赛部分答案记录</h3><p>  由于赛方已将答案以及切入点以表格的形式完整的在PPT上展示了，在此我就不过多赘述，有需要的请观看我在现场拍摄答案图片。</p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055313214.png" alt="1620055313214"></p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055338129.png" alt="1620055338129"></p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055375251.png" alt="1620055375251"></p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055406202.png" alt="1620055406202"></p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055432077.png" alt="1620055432077"></p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055461131.png" alt="1620055461131"></p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055486695.png" alt="1620055486695"></p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055518177.png" alt="1620055518177"></p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055542386.png" alt="1620055542386"></p>
<p><strong>备注：</strong>会场的安排包括会场的会议时间和会议名称，我只拍到了时间安排没有拍到每个房间不同时间段对应的会议名称，所以需要详细资料的可以等一段时间去官网下载详细答案。</p>
<h3 id="挑战1获奖作品记录及感想"><a href="#挑战1获奖作品记录及感想" class="headerlink" title="挑战1获奖作品记录及感想"></a>挑战1获奖作品记录及感想</h3><ol>
<li><p>一等奖，成都理工大学-李浙川</p>
<p>所用开发工具：Echarts，D3.js，Tableau，Layui，Python，Excel</p>
<p>成都理工大学队的作品被挑战赛评议委员会认为是本次赛事中分析结果最全、结果与答案最为接近的作品。在作品中并未涉及到什么算法和高大上的可视化技术却利用现有的工具将设计出的图形相互搭配完美的解决了挑战1的各问题。以下是他们设计的部分可视化界面以及简要说明。</p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620056315442.png" alt="1620056315442"></p>
<p>左图 ：A 部分为会场实时人数、人员密度统计条形 图；B 部分为实时会场动态展示图；C 部分为会场异常情况通报栏；D 部分</p>
<p>为该异常事件具体情况展示栏；E 部分为会场人数情况热力图</p>
<p>右图：AB 两部分为该 id 的一二楼该天停留情况热力图；CD 两部分为该 id 一二楼重要地点的具体停留时间和弦图；E 图为该</p>
<p>id 三天具体移动轨迹展示图</p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620056333975.png" alt="1620056333975"></p>
<p>左图：在折线图中梯度下降和梯度上升的情况判断出各会场会议的起止时间，其中以会场人数跃进式上升为会议的开始标志，会场人数断崖式下降为会议的结束标志，进而得出每个会场的会议安排表</p>
<p>右图：工作人员流动情况气泡图(其中蓝色代表服务台，灰色代表签到处，绿色代表展厅)            </p>
<p>盗用胸牌16632：通过发现在某一时刻同时出现两个编号相同的胸牌</p>
</li>
<li><p>一等奖，重庆大学</p>
<p>处理数据前对数据进行了补全再做处理</p>
<p>   <img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620056239274.png" alt="1620056239274"></p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620056212426.png" alt="1620056212426"></p>
<p>   记者越权：切入点，先分析出可进VIP房间的人不用签到但该人进入VIP房间签到 </p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620056170204.png" alt="1620056170204"></p>
<p>   当然作为一等奖的获得者他们也分析出了盗用胸牌者，不过他们找到该盗用ID是：发现使用该ID的人员瞬移并跳格，然后深入分析发现原因不是瞬移跳格，而是有人复制胸牌导致很短的时间内有同样ID的人在不同的两个地方出现。（顺便说一句，当时我们团队也发现了这个人，且发现他的原因也是他出现瞬移的情况，但我们没有进行深入分析，而只是把他当做传感器故障时间处理了，哎。。。可能这就是一等奖和优秀之间的差距吧）。</p>
</li>
<li><p>二等奖，东北师范大学</p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620056134636.png" alt="1620056134636"></p>
<p>人员分类：t-sne+圈选平行坐标图</p>
<p>先分类-&gt;预设-&gt;t-sne降维算法</p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620056086896.png" alt="1620056086896"></p>
<p>冒用：同时两条轨迹 </p>
<p>传感器出错：由一人异常-&gt;深入察看-&gt;某段某时，传感器失灵</p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620056065367.png" alt="1620056065367"></p>
</li>
<li><p>二等奖，山东大学</p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620056023159.png" alt="1620056023159"></p>
<p>用到的技术 ：D3.js    AntVG2   Vega   Echarts</p>
<p>右图右侧决定树：用于展示全场分类</p>
</li>
<li><p>二等奖，信息工程大学</p>
<p>虚幻引擎（咱也不知道啥是虚幻引擎，只知道主持人赵颖老师说这是本次比赛中用到最牛技术的获奖作品o(╥﹏╥)o）不懂所以我就不敢乱逼逼，有兴趣的可以看以下我拍摄的演讲人的报告PPT，以及该作品作者的联系方式。</p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055946850.png" alt="1620055946850"></p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055918993.png" alt="1620055918993"></p>
</li>
<li><p>二等奖，燕山大学</p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055892483.png" alt="1620055892483"></p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055864640.png" alt="1620055864640"></p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055834713.png" alt="1620055834713"></p>
<p>冒领ID：出入口检测不匹配</p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055794604.png" alt="1620055794604"></p>
</li>
<li><p>单项奖，中国铁道科学研究院集团有限公司-戚小玉（三维场景设计奖）</p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055772247.png" alt="1620055772247"></p>
<p><img src="/2019/07/28/ChinaVis2019%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/1620055713344.png" alt="1620055713344"></p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>对于发现的问题一定要做深入的分析不然可能与正确答案失之交臂，就比如发现某个人员瞬移及跳跃时，重庆大学发现了这个问题，我们队也发现了这个问题，但我们草草结论认为是传感器问题，而重庆大学在认真分析后得出了胸牌盗用复制的正确答案。</li>
<li>从以上获奖作品中可看出，虽然可能在做比赛时用到的技术不同，但在解决某个问题时大多获奖团队不谋而合的采用了相同的可视化图形，这说明针对解决某一问题时一个好的可视化图形是被普遍认可的，比如在解决场馆时间安排时成都理工大学、重庆大学、东北师范大学、燕山大学、中国铁道科学研究院集团等都用到了场馆人数变化折线图来确定时间安排，这也从侧面说明了针对比赛的某一问题去找到一种正确的可视化图形的重要性。所以比赛之初针对问题去寻找正确的可视化图形非常重要。</li>
</ol>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>ChinaVIS</tag>
      </tags>
  </entry>
  <entry>
    <title>V8引擎编译器和解析器</title>
    <url>/2021/04/22/V8%E5%BC%95%E6%93%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<p>​    通过阅读李兵老师的《浏览器的原理与实践》感觉对自己学习和理解前端知识大有启发，结合自己的理解对V8引擎的编译器和解释器做了以下归纳和总结。已备自己忘记时查看。</p>
<span id="more"></span>

<h4 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h4><p>​    <strong>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。</strong>比如 C/C++、GO 等都是编译型语言。</p>
<p>​    <strong>解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行</strong>。比如 Python、JavaScript 等都属于解释型语言。</p>
<p><img src="/2021/04/22/V8%E5%BC%95%E6%93%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E6%9E%90%E5%99%A8/image-20210306105157354.png" alt="image-20210306105157354"></p>
<p><strong>（1）编译型语言的执行流程：</strong>编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</p>
<p><strong>（2）解释型语言的执行流程：</strong>解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</p>
<h4 id="V8-是如何执行一段-JavaScript-代码的"><a href="#V8-是如何执行一段-JavaScript-代码的" class="headerlink" title="V8 是如何执行一段 JavaScript 代码的"></a>V8 是如何执行一段 JavaScript 代码的</h4><p>​    V8 在执行过程中既有<strong>解释器 Ignition</strong>，又有<strong>编译器 TurboFan</strong>。其全局执行流程如下所示：</p>
<p><img src="/2021/04/22/V8%E5%BC%95%E6%93%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E6%9E%90%E5%99%A8/image-20210306105718810.png" alt="image-20210306105718810"></p>
<h5 id="生成抽象语法树（AST）和执行上下文"><a href="#生成抽象语法树（AST）和执行上下文" class="headerlink" title="生成抽象语法树（AST）和执行上下文"></a>生成抽象语法树（AST）和执行上下文</h5><p>​    首先，将源代码转换成<strong>抽象语法树（AST）</strong>和<strong>执行上下文</strong>。高级语言是开发者可以理解的语言，而对于编译器和解释器来说他们可以理解的就是抽象语法树（AST）。这和渲染引擎将HTML格式的文件转换为自己可以理解的DOM树类似。</p>
<p>​    AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。<strong>Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</strong></p>
<p>​    除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p>
<p><strong>生成AST的两个阶段：</strong></p>
<p><strong>第一阶段是分词（tokenize），又称为词法分析</strong>，其作用是将一行行的源码拆解成一个个 token。所谓<strong>token</strong>，指的是语法上不可能再分的、最小的单个字符或字符串。</p>
<p><img src="/2021/04/22/V8%E5%BC%95%E6%93%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E6%9E%90%E5%99%A8/image-20210306111037818.png" alt="image-20210306111037818"></p>
<p>​    从图中可以看出，通过<code>var myName = “极客时间”</code>简单地定义了一个变量，其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。</p>
<p><strong>第二阶段是解析（parse），又称为语法分析</strong>，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p>
<p><strong>有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。</strong></p>
<h5 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h5><p>​    有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。</p>
<p><strong>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</strong></p>
<p><img src="/2021/04/22/V8%E5%BC%95%E6%93%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E6%9E%90%E5%99%A8/image-20210306111747379.png" alt="image-20210306111747379"></p>
<p>​    从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。</p>
<h5 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h5><p>​    通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码(HotSpot)，比如一段代码被重复执行多次，这种就称为<strong>热点代码</strong>，那么后台的编译器(TurboFan) 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p>
<p>​    其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为<strong>即时编译（JIT）</strong>。</p>
<h4 id="JavaScript的性能优化"><a href="#JavaScript的性能优化" class="headerlink" title="JavaScript的性能优化"></a>JavaScript的性能优化</h4><p>主要关注以下三点：</p>
<ol>
<li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>
<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>
<li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    （1）解释器和编译器在执行代码时都会先将代码通过词法分析、语法分析生成抽象语法树（AST），不同的是解释型语言会通过解释器将AST转换为字节码并直接逐条执行；而编译器会在AST的基础上先优化代码然后生成机器码进而编译生成二进制文件，执行时直接执行这个二进制文件。</p>
<p>​    （2）JavaScript的编译流程是：先通过词法分析和语法分析生成AST和可执行上下文，然后通过解释器将AST转换为字节码，并逐条执行。在生成AST时主要分为两步：第一步先通过词法分析生成token，第二步通过语法分析将token转换为AST。</p>
<p>​    （3）V8在代码的编译过程中采用的JIT（即时编译）技术来实现的。就是在生成字节码后，先使用解释器逐条解释并执行代码，如果遇到热点代码（被多次重复执行的代码），就会把这段字节码通过编译器编译为机器码，当再次遇到改代码是就可以直接执行。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器工作原理</tag>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>原型与原型链</title>
    <url>/2021/04/17/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>​    帮助理解前端常考知识点原型与原型链，介绍他们的相关概念以及他们是如何指向的。</p>
<span id="more"></span>

<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>显示原型</strong>：prototype</p>
<ul>
<li>每个class/函数都有显示原型prototype，它默认指向一个Object空对象（即称为原型对象）</li>
<li>原型对象中一个属性constructor，它指向函数对象</li>
</ul>
<p><strong>隐式原型</strong>：<strong>proto</strong></p>
<ul>
<li>每个实例都有隐式原型__proto__</li>
<li>实例的__proto__指向对应的class/函数的prototype。</li>
</ul>
<p><strong>相关概念</strong>：</p>
<ol>
<li>Function是所有函数(function)的父亲，所有函数都是它的实例。</li>
<li>Object也是一个函数，所以Object是Function的实例对象。</li>
<li>任何对象的原型链顶端最终都指向Object.prototype,Object.prototype再往上已经没有东西了，所以指向null。</li>
<li>Function比较特殊它的原型指向自己，即Function.<strong>proto</strong> === Function.prototype。</li>
<li>同时，Function是对象，由(3)可知Function必然有一个地方（即Function.prototype.__proto__）指向Object.prototype。</li>
</ol>
<p><strong>先来看一个简化版的原型链图：</strong></p>
<p><img src="/2021/04/17/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/image-20210303222509043.png" alt="image-20210303222509043"></p>
<p>再来看一个完整版的：</p>
<p><img src="/2021/04/17/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型与原型链"></p>
<p><font color="red">总之，记住一句话：A是B的实例，则A.__ proto __  === B.prototype；只要A是对象，那么A.prototype.__ proto__ 就指向Object.prototype；prototype中的constructor指向的是自己；</font></p>
<h4 id="原型链与函数的继承"><a href="#原型链与函数的继承" class="headerlink" title="原型链与函数的继承"></a>原型链与函数的继承</h4><ol>
<li><p>ES5中的继承</p>
<p><strong>构造函数继承</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Parent(); <span class="comment">//new一个Parent对象用来对比</span></span><br><span class="line">p.say(); <span class="comment">//输出say</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line">c.age <span class="comment">// 12</span></span><br><span class="line">c.name <span class="comment">//&#x27;parent&#x27;</span></span><br><span class="line">c.say(); <span class="comment">//undifined</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">say是Parent原型链上的方法，Parent对象调用方法时，如果自身不存在就回去原型链上寻找，在原型链上找到了say方法，而Child对象没有继承Parent对象的原型链，所以它在向上寻找时就找不到，输出undifined。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>原型链继承：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c.name); <span class="comment">//输出parent</span></span><br><span class="line">c.say() <span class="comment">//输出say</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原型链继承是直接让Child构造函数的prototype直接指向Parent对象，这样Parent的东西Child对象可以直接从它的原型链上找到。缺点就是：当创建多个实例时，如果不同实例可能互相存在影响。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数与原型链组合继承</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>); </span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c1.arr); <span class="comment">//[1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.arr);<span class="comment">//[1,2,3,4]</span></span><br><span class="line">c1.arr.push(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c1.arr); <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.arr); <span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure></li>
<li><p>ES6中的继承</p>
<p>ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法，才可使用this关键字，否则报错。），然后再用子类的构造函数修改this实现继承。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent2.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> Child2(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c2.name); <span class="comment">//输出parent</span></span><br><span class="line">c2.say(); <span class="comment">//输出say</span></span><br><span class="line"><span class="built_in">console</span>.log(c.constructor); </span><br><span class="line"><span class="comment">//输出function Child(age) &#123;Parent.call(this);this.age = age;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Parent().constructor); </span><br><span class="line"><span class="comment">//输出Parent() &#123;this.name = &#x27;parent&#x27;;this.arr = [1,2,3,4];&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化学术期刊汇总</title>
    <url>/2021/05/04/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E6%9C%AF%E6%9C%9F%E5%88%8A%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>​    整理一些自己知道的可视化学术期刊，信息主要来源于《中国计算机学会推荐国际学术会议和期刊目录(2019 年)》，从分类中摘取出本人所知的可视化期刊。后续将继续完善。</p>
<span id="more"></span>

<h4 id="A类期刊"><a href="#A类期刊" class="headerlink" title="A类期刊"></a>A类期刊</h4><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">刊物简称</th>
<th align="center">刊物名称</th>
<th align="center">出版社</th>
<th align="center">网址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">TVCG</td>
<td align="center">IEEE Transactions on Visualization and Computer Graphics</td>
<td align="center">IEEE</td>
<td align="center"><a href="http://dblp.uni-trier.de/db/journals/tvcg/">http://dblp.uni-trier.de/db/journals/tvcg/</a></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">SIGGRAPH</td>
<td align="center">ACM SIGGRAPH Annual Conference</td>
<td align="center">ACM</td>
<td align="center"><a href="http://dblp.uni-trier.de/db/conf/siggraph/index.html">http://dblp.uni-trier.de/db/conf/siggraph/index.html</a></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">IEEE VIS</td>
<td align="center">IEEE Visualization Conference</td>
<td align="center">IEEE</td>
<td align="center"><a href="http://dblp.uni-trier.de/db/conf/visualization/index.html">http://dblp.uni-trier.de/db/conf/visualization/index.html</a></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">TOCHI</td>
<td align="center">ACM Transactions on Computer-Human Interaction</td>
<td align="center">ACM</td>
<td align="center"><a href="http://dblp.uni-trier.de/db/journals/tochi/">http://dblp.uni-trier.de/db/journals/tochi/</a></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">HCI</td>
<td align="center">Human Computer Interaction</td>
<td align="center">Taylor &amp; Francis</td>
<td align="center"><a href="http://dblp.uni-trier.de/db/journals/hhci/">http://dblp.uni-trier.de/db/journals/hhci/</a></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">CHI</td>
<td align="center">ACM Conference on Human Factors in Computing Systems</td>
<td align="center">ACM</td>
<td align="center"><a href="http://dblp.uni-trier.de/db/conf/chi">http://dblp.uni-trier.de/db/conf/chi</a></td>
</tr>
</tbody></table>
<h4 id="B类期刊"><a href="#B类期刊" class="headerlink" title="B类期刊"></a>B类期刊</h4><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">刊物简称</th>
<th align="center">刊物名称</th>
<th align="center">出版社</th>
<th align="center">网址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">EuroVis</td>
<td align="center">Eurographics Conference on Visualization</td>
<td align="center">ACM</td>
<td align="center"><a href="http://dblp.uni-trier.de/db/conf/vissym/">http://dblp.uni-trier.de/db/conf/vissym/</a></td>
</tr>
</tbody></table>
<h4 id="C类期刊"><a href="#C类期刊" class="headerlink" title="C类期刊"></a>C类期刊</h4><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">刊物简称</th>
<th align="center">刊物名称</th>
<th align="center">出版社</th>
<th align="center">网址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">JVCIR</td>
<td align="center">Journal of Visual Communication and Image Representation</td>
<td align="center">Elsevier</td>
<td align="center"><a href="http://dblp.uni-trier.de/db/journals/jvcir/">http://dblp.uni-trier.de/db/journals/jvcir/</a></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">PacificVis</td>
<td align="center">IEEE Pacific Visualization Symposium</td>
<td align="center">IEEE</td>
<td align="center"><a href="http://dblp.uni-trier.de/db/conf/apvis/">http://dblp.uni-trier.de/db/conf/apvis/</a></td>
</tr>
</tbody></table>
<h4 id="其他期刊"><a href="#其他期刊" class="headerlink" title="其他期刊"></a>其他期刊</h4><ul>
<li>ChinaVIS<ul>
<li>中文《计算机辅助设计与图形学学报》</li>
<li>英文《Journal of Visualization》</li>
</ul>
</li>
</ul>
<p><strong>参考文献</strong>：中国计算机学会推荐国际学术会议和期刊目录(2019 年)</p>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue常用知识点总结</title>
    <url>/2021/04/22/Vue%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​    Vue在面试中的常考知识点总结。</p>
<span id="more"></span>

<h4 id="Vue的响应式系统（即双向绑定）"><a href="#Vue的响应式系统（即双向绑定）" class="headerlink" title="Vue的响应式系统（即双向绑定）"></a>Vue的响应式系统（即双向绑定）</h4><p>​    通过数据劫持监听加发布者-订阅者模式实现。我们在Observer中使用Object.defineProperty（或者proxy）函数来实现对数据的追踪。在该函数中有一个get方法和set方法，当外界通过Watcher读取数据时会触发get，进而将每个数据对应的依赖watcher添加到Dep数组中，当外界数据发生改变时，就会触发set函数，找到Dep中的依赖从而通知订阅者更新相应的页面。</p>
<p>​    Vue为MVVM框架，当数据模型data变化时，页面视图会得到响应更新，其原理对data的getter/setter方法进行拦截（Object.defineProperty或者Proxy），利用发布订阅的设计模式，在getter方法中进行订阅，在setter方法中发布通知，让所有订阅者完成响应。</p>
<p>​    在响应式系统中，Vue会为数据模型data的每一个属性新建一个订阅中心作为发布者，而监听器watch、计算属性computed、视图渲染template/render三个角色同时作为订阅者，对于监听器watch，会直接订阅观察监听的属性，对于计算属性computed和视图渲染template/render，如果内部执行获取了data的某个属性，就会执行该属性的getter方法，然后自动完成。</p>
<h4 id="Vue中几个基础的命令及含义"><a href="#Vue中几个基础的命令及含义" class="headerlink" title="Vue中几个基础的命令及含义"></a>Vue中几个基础的命令及含义</h4><ol>
<li>v-bind强制绑定，简写冒号，作用：把HTML元素转换为js元素</li>
<li>v-on简写@，绑定事件监听，@click=”test()”</li>
<li>v-if，条件渲染指令</li>
<li>v-show,条件渲染指令</li>
<li>v-for,循环指令</li>
</ol>
<h4 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h4><p>​    1、初始化显示</p>
<p>​        beforeCreate()：是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。</p>
<blockquote>
<p>beforeCreate()：是new Vue()之后触发的第一个勾子函数，当前阶段数据和方法都不能被访问</p>
</blockquote>
<p>​        Created()：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。</p>
<blockquote>
<p>Created()：在实例创建完成后发生，当前阶段已经完成了数据的观测，可以使用数据，更改数据且不会触发updated函数，但是当前阶段无法与DOM交互</p>
</blockquote>
<p>​        beforeMount()：发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。、</p>
<blockquote>
<p>发生在挂载之前，template模板已经被编译成了render函数，且虚拟DOM已经创建完成，即将开始渲染，此时更改数据，不会触发updated</p>
</blockquote>
<p>​        mounted()：在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。</p>
<blockquote>
<p>真实DOM已经挂载完毕，数据完成双向绑定，可以访问到DOM节点</p>
</blockquote>
<p>​    2、更新显示</p>
<p>​        beforeUpdate()：发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</p>
<blockquote>
<p>在响应式数据发生更新、虚拟DOM重新渲染之前被触发</p>
</blockquote>
<p>​        updated()：发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p>
<blockquote>
<p>发生在更新完成之后，当前阶段组件的DOM已经完成更新，需要避免在此期间更改数据</p>
</blockquote>
<p>​    3、销毁Vue实例</p>
<p>​        beforeDestroy()：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p>
<p>​        destroyed()：发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p>
<h4 id="computed与watch的区别"><a href="#computed与watch的区别" class="headerlink" title="computed与watch的区别"></a>computed与watch的区别</h4><p>​    计算属性computed和监听器watch都可以观察属性的变化从而做出响应，不同的是：</p>
<p>​    计算属性computed更多是作为<strong>缓存功能</strong>的观察者，它可以将一个或者多个data的属性进行复杂的计算生成一个新的值，提供给渲染函数使用，当依赖的属性变化时，computed不会立即重新计算生成新的值，而是先标记为脏数据，当下次computed被获取时候，才会进行重新计算并返回。</p>
<p>​    而监听器watch并<strong>不具备缓存性</strong>，监听器watch提供一个监听函数，当监听的属性发生变化时，会立即执行该函数。</p>
<h4 id="为什么组件的data必须是一个函数"><a href="#为什么组件的data必须是一个函数" class="headerlink" title="为什么组件的data必须是一个函数"></a>为什么组件的data必须是一个函数</h4><p>​    一个组件可能在很多地方使用，也就是会创建很多个实例，如果data是一个对象的话，对象是引用类型，一个实例修改了data会影响到其他实例，所以data必须使用函数，为每一个实例创建一个属于自己的data，<strong>使其同一个组件的不同实例互不影响。</strong></p>
<h4 id="组件之间通信的方式"><a href="#组件之间通信的方式" class="headerlink" title="组件之间通信的方式"></a>组件之间通信的方式</h4><ol>
<li>props，此方法只能用于父组件向子组件传递数据</li>
<li>Vue的自定义事件：<ul>
<li>通过v-on绑定</li>
<li>通过$on绑定</li>
<li>此方法仅适用于子组件向父组件传递消息</li>
</ul>
</li>
<li>PubSubJS库（使用消息的订阅预发布），该方式可实现任意关系组件间的通信（数据）</li>
<li>插槽：该方法用于父组件向子组件传递‘标签数据’</li>
<li>eventBus：每一个Vue实例都是一个Event Bus，都支持$on/$emit，可以为需要通信组件的实例之间new一个Vue实例，作为Event Bus进行通信。</li>
<li>Vuex：将状态和方法提取到Vuex，完成共享</li>
</ol>
<h4 id="Vue事件绑定原理"><a href="#Vue事件绑定原理" class="headerlink" title="Vue事件绑定原理"></a>Vue事件绑定原理</h4><p>​    vue中的事件绑定是有两种，一种是原生的事件绑定，另一种是组件的事件绑定。原生的事件绑定在普通元素上是通过@click进行绑定，在组件上是通过@click.native进行绑定，组件中的nativeOn是等价于on的。组件的事件绑定的@click是vue 中自定义的 $on 方法来实现的，必须有$emit才可以触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> compiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>); <span class="comment">// vue loader中的包</span></span><br><span class="line"><span class="keyword">let</span> r1 = compiler.compile(<span class="string">&#x27;&lt;div @click=&quot;fn()&quot;&gt;&lt;/div&gt;&#x27;</span>); <span class="comment">// 给普通标签绑定click事件</span></span><br><span class="line"><span class="comment">// 给组件绑定一个事件，有两种绑定方法</span></span><br><span class="line"><span class="comment">// 一种@click.native，这个绑定的就是原生事件</span></span><br><span class="line"><span class="comment">// 另一种@click，这个绑定的就是组件自定义事件</span></span><br><span class="line"><span class="keyword">let</span> r2 = compiler.compile(<span class="string">&#x27;&lt;my-component @click.native=&quot;fn&quot; @click=&quot;fn1&quot;&gt;&lt;/mycomponent&gt;&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r1.render); <span class="comment">// &#123;on:&#123;click&#125;&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(r2.render); <span class="comment">// &#123;nativeOn:&#123;click&#125;,on:&#123;click&#125;&#125;</span></span><br><span class="line"><span class="comment">// 为什么组件要加native？因为组件最终会把nativeOn属性放到on的属性中去，这个on会单独处理</span></span><br><span class="line"><span class="comment">// 组件中的nativeOn 等价于 普通元素on，组件on会单独处理</span></span><br></pre></td></tr></table></figure>

<p>1.原生的事件绑定，原生 dom 事件的绑定,采用的是 addEventListener 实现。</p>
<p>2.组件的事件绑定，组件绑定事件采用的是 $on 方法 。        </p>
<p>​    <strong>原生事件的绑定是通过addEventLister绑定给真实的元素的；组件事件绑定是通过vue自定义的$on实现的。</strong>如果要在组件上使用原生事件，需要加.native修饰符，这样就相当于在父组件中把子组件当做普通html标签，然后加上原生事件。</p>
<p>​    $on、$emit是基于订阅观察者模式的，维护一个事件中心，on的时候将事件按名称存在事件中心里，称之为订阅者，然后emit将对应的事件进行发布，去执行事件中心里的对应的监听器。</p>
<p>​    每一个Vue实例都是一个Event Bus，当子组件被创建的时候，父组件将事件传递给子组件，子组件初始化的时候是有$on方法将事件注册到内部，在需要的时候使用$emit触发函数，而对于原生native事件，使用addEventListener绑定到真实的DOM元素上。</p>
<h4 id="slot插槽及原理"><a href="#slot插槽及原理" class="headerlink" title="slot插槽及原理"></a>slot插槽及原理</h4><p>​    <strong>插槽（Slot）是Vue提出来的一个概念，插槽用于将所携带的内容插入到之指定的位置，从而使模板分块具有模块化的特质和作用。插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制</strong></p>
<p>slot又分三类，默认插槽，具名插槽和作用域插槽。</p>
<ul>
<li>默认插槽：又名匿名插槽（或单个插槽），当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li>
<li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li>
<li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以<strong>将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</strong></li>
</ul>
<p><strong>实现原理</strong>：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p>
<h4 id="Vue模板渲染的原理"><a href="#Vue模板渲染的原理" class="headerlink" title="Vue模板渲染的原理"></a>Vue模板渲染的原理</h4><p>​    vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要<strong>将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。</strong></p>
<p>模板编译又分三个阶段，解析（parse），优化（optimize），生成（generate），最终生成可执行函数render。</p>
<ul>
<li>parse阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li>
<li>optimize阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li>
<li>generate阶段：将最终的AST转化为render函数字符串。</li>
</ul>
<h4 id="template预编译"><a href="#template预编译" class="headerlink" title="template预编译"></a>template预编译</h4><p>​    <strong>对于 Vue 组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后在也不会进行编译。</strong>因此，编译对组件的 runtime 是一种性能损耗。</p>
<p>​    而模板编译的目的仅仅是将template转化为<code>render function</code>，这个过程，正好可以在项目构建的过程中完成，这样可以让实际组件在 runtime 时直接跳过模板渲染，进而提升性能，这个在项目构建的编译template的过程，就是预编译。</p>
<blockquote>
<p>对于Vue组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后就不会进行编译。而模板编译的目的仅仅是将template转换为render函数，而这个过程正好可以在项目构建的过程中完成，在项目构建的过程中完成编译template编译就叫做预编译。</p>
<p>​    比如webpack的vue-loader依赖了vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数，在 runtime 可直接跳过模板编译过程。</p>
</blockquote>
<h4 id="template和JSX有的区别"><a href="#template和JSX有的区别" class="headerlink" title="template和JSX有的区别"></a>template和JSX有的区别</h4><p>​    对于 runtime 来说，只需要保证组件存在 render 函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。</p>
<p>​    在 webpack 中，我们使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。</p>
<p>​    与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。</p>
<p>​    所以，template和jsx的都是render的一种表现形式，不同的是：</p>
<p>​    JSX相对于template而言，具有<strong>更高的灵活性</strong>，<strong>在复杂的组件中，更具有优势</strong>，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p>
<blockquote>
<p>总结，区别就是：</p>
<ul>
<li>JSX相对于template而言具有更高的灵活性，在复杂的组件中，更具优势。</li>
<li>template相对于JSX而言，在代码结构上更符合视图逻辑，更加简洁易维护。  </li>
</ul>
</blockquote>
<h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><p>​    Virtual DOM 是 DOM 节点在 JavaScript 中的一种抽象数据结构，之所以需要虚拟DOM，是因为浏览器中操作DOM的代价比较昂贵，频繁操作DOM会产生性能问题。虚拟DOM的作用是在每一次响应式数据发生变化引起页面重渲染时，Vue对比更新前后的虚拟DOM，匹配找出尽可能少的需要更新的真实DOM，从而达到提升性能的目的。</p>
<h4 id="Vue中的diff算法"><a href="#Vue中的diff算法" class="headerlink" title="Vue中的diff算法"></a>Vue中的diff算法</h4><p>在新老虚拟DOM对比时</p>
<ul>
<li>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换</li>
<li>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li>
<li>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。</li>
<li>匹配时，找到相同的子节点，递归比较子节点</li>
</ul>
<p><strong>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从<code>O(n^3)</code>降低值<code>O(n)</code>，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</strong></p>
<h4 id="key属性的作用"><a href="#key属性的作用" class="headerlink" title="key属性的作用"></a>key属性的作用</h4><p>​    在对节点进行diff的过程中，判断是否为相同节点的一个很重要的条件是key是否相等，如果是相同节点，则会尽可能的复用原有的DOM节点。所以key属性是提供给框架在diff的时候使用的，而非开发者。</p>
<h4 id="Vue2-0和Vue3-0的区别"><a href="#Vue2-0和Vue3-0的区别" class="headerlink" title="Vue2.0和Vue3.0的区别"></a>Vue2.0和Vue3.0的区别</h4><ol>
<li><p>重构响应式系统，使用Proxy替换Object.defineProperty，使用Proxy优势：</p>
<ul>
<li><p>可直接监听数组类型的数据变化</p>
</li>
<li><p>监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升</p>
</li>
<li><p>可拦截apply、ownKeys、has等13种方法，而Object.defineProperty不行</p>
</li>
<li><p>直接实现对象属性的新增/删除</p>
</li>
</ul>
</li>
<li><p>新增Composition API，更好的逻辑复用和代码组织</p>
</li>
<li><p>重构 Virtual DOM</p>
<ul>
<li><p>模板编译时的优化，将一些静态节点编译成常量</p>
</li>
<li><p>slot优化，将slot编译为lazy函数，将slot的渲染的决定权交给子组件</p>
</li>
<li><p>模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）</p>
</li>
</ul>
</li>
<li><p>代码结构调整，更便于Tree shaking，使得体积更小</p>
</li>
<li><p>使用Typescript替换Flow</p>
</li>
</ol>
<h4 id="Composition-API简介"><a href="#Composition-API简介" class="headerlink" title="Composition API简介"></a>Composition API简介</h4><p>​    Vue2.0中，随着功能的增加，组件变得越来越复杂，越来越难维护，而难以维护的根本原因是Vue的API设计迫使开发者使用watch，computed，methods选项组织代码，而不是实际的业务逻辑。</p>
<p>​    另外Vue2.0缺少一种较为简洁的低成本的机制来完成逻辑复用，虽然可以minxis完成逻辑复用，但是当mixin变多的时候，会使得难以找到对应的data、computed或者method来源于哪个mixin，使得类型推断难以进行。</p>
<p>​    所以Composition API的出现，主要是也是为了解决Option API带来的问题，第一个是代码组织问题，Compostion API<strong>可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性</strong>，也就是说当下一个开发者接触这一段不是他自己写的代码时，他可以更好的利用代码的组织反推出实际的业务逻辑，或者根据业务逻辑更好的理解代码。</p>
<p>​    <strong>第二个是实现代码的逻辑提取与复用</strong>，当然mixin也可以实现逻辑提取与复用，但是像前面所说的，多个mixin作用在同一个组件时，很难看出property是来源于哪个mixin，来源不清楚，另外，多个mixin的property存在变量命名冲突的风险。而Composition API刚好解决了这两个问题。</p>
<blockquote>
<p>1、可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性。</p>
<p>2、可以实现代码的逻辑复用。</p>
</blockquote>
<h4 id="Composition-API与React-Hook的区别"><a href="#Composition-API与React-Hook的区别" class="headerlink" title="Composition API与React Hook的区别"></a>Composition API与React Hook的区别</h4><p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</p>
<ul>
<li>不能在循环、条件、嵌套函数中调用Hook</li>
<li>必须确保总是在你的React函数的顶层调用Hook</li>
<li>useEffect、useMemo等函数必须手动确定依赖关系</li>
</ul>
<p>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</p>
<ul>
<li>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢</li>
<li>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用</li>
<li>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</li>
</ul>
<p>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</p>
<h4 id="SSR服务器端渲染原理"><a href="#SSR服务器端渲染原理" class="headerlink" title="SSR服务器端渲染原理"></a>SSR服务器端渲染原理</h4><p>​    在客户端请求服务器的时候，服务器到数据库中获取到相关的数据，并且在服务器内部将Vue组件渲染成HTML，并且将数据、HTML一并返回给客户端，这个在服务器将数据和组件转化为HTML的过程，<strong>叫做服务端渲染SSR</strong>。</p>
<p>而当客户端拿到服务器渲染的HTML和数据之后，由于数据已经有了，客户端不需要再一次请求数据，而只需要将数据同步到组件或者Vuex内部即可。除了数据以外，HTML也结构已经有了，客户端在渲染组件的时候，也只需要将HTML的DOM节点映射到Virtual DOM即可，不需要重新创建DOM节点，这个将数据和HTML同步的过程，又叫做客户端激活。</p>
<p>使用SSR的好处：</p>
<ul>
<li>有利于SEO：其实就是有利于爬虫来爬你的页面，因为部分页面爬虫是不支持执行JavaScript的，这种不支持执行JavaScript的爬虫抓取到的非SSR的页面会是一个空的HTML页面，而有了SSR以后，这些爬虫就可以获取到完整的HTML结构的数据，进而收录到搜索引擎中。</li>
<li><strong>白屏时间更短</strong>：相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。而客户端渲染，需要先得到一个空的HTML页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。</li>
</ul>
<p>更多详情查看<a href="https://github.com/yacan8/blog/issues/30">彻底理解服务端渲染 - SSR原理</a></p>
<h4 id="v-show和v-if的区别"><a href="#v-show和v-if的区别" class="headerlink" title="v-show和v-if的区别"></a>v-show和v-if的区别</h4><ul>
<li>v-if：是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</li>
<li><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</li>
<li><code>v-show</code> 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</li>
<li>如果需要频繁切换 v-show 较好</li>
</ul>
<h4 id="Vue渲染到视图的流程"><a href="#Vue渲染到视图的流程" class="headerlink" title="Vue渲染到视图的流程"></a>Vue渲染到视图的流程</h4><ol>
<li><p>把模板编译为render函数（在beforeMount之前，Created之后）</p>
</li>
<li><p>实例进行挂载, 根据根节点render函数的调用，递归的生成虚拟dom（beforeMount阶段）</p>
</li>
<li><p>对比虚拟dom，渲染到真实dom（Mounted之前）</p>
</li>
<li><p>组件内部data发生变化，组件和子组件引用data作为props重新调用render函数，生成虚拟dom, 返回到步骤3。（Mounted阶段）</p>
<p><img src="/2021/04/22/Vue%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Snipaste_2021-04-22_21-43-20.png" alt="Snipaste_2021-04-22_21-43-20"></p>
<p><img src="/2021/04/22/Vue%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Snipaste_2021-04-22_21-44-17.png" alt="Snipaste_2021-04-22_21-44-17"></p>
<p><img src="/2021/04/22/Vue%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Snipaste_2021-04-22_21-45-00.png" alt="Snipaste_2021-04-22_21-45-00"></p>
</li>
</ol>
<h4 id="vue中请求数据的方式"><a href="#vue中请求数据的方式" class="headerlink" title="vue中请求数据的方式"></a>vue中请求数据的方式</h4><ol>
<li>vue-resource 官方提供的 vue的一个插件</li>
<li>ajax</li>
<li>axios</li>
<li>fetch-jsonp</li>
</ol>
<p><a href="https://www.jb51.net/article/181876.htm">https://www.jb51.net/article/181876.htm</a></p>
<h4 id="Vue路由的两种实现方式"><a href="#Vue路由的两种实现方式" class="headerlink" title="Vue路由的两种实现方式"></a>Vue路由的两种实现方式</h4><p>​    前端不同页面的状态管理器，可以不向后台发送请求而直接通过前端技术实现多个页面的切换。</p>
<ol>
<li><p>hash模式</p>
<p>通过锚点定位原理进行无刷新跳转，触发后会在url后面多加一个#号</p>
</li>
<li><p>history模式</p>
<p>使用HTML5中的historyAPI实现客户端路由模式，触发后url中没有#</p>
</li>
</ol>
<h4 id="Vue中的this-nextTick"><a href="#Vue中的this-nextTick" class="headerlink" title="Vue中的this.$nextTick"></a>Vue中的this.$nextTick</h4><p>​    <strong>Vue.nextTick( <a href="https://cn.vuejs.org/v2/api/#Vue-nextTick">callback, context] )</a></strong></p>
<ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>&#123;Function&#125; [callback]</code></li>
<li><code>&#123;Object&#125; [context]</code></li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<p><strong>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">vm.msg = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="comment">// DOM 还没有更新</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span></span><br><span class="line">Vue.nextTick()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM 更新了</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Vue中的keep-alive"><a href="#Vue中的keep-alive" class="headerlink" title="Vue中的keep-alive"></a>Vue中的keep-alive</h4><p><keep-alive> 是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。<keep-alive>包裹动态组件时，会<strong>缓存不活动的组件实例</strong>，而不是销毁它们。</keep-alive></keep-alive></p>
<p><keep-alive> 与 <transition>相似，只是一个抽象组件，它不会在DOM树中渲染(真实或者虚拟都不会)，也不在父组件链中存在，比如：你永远在this.$parent 中找不到 keep-alive 。</transition></keep-alive></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>论文概览</title>
    <url>/2021/05/04/%E8%AE%BA%E6%96%87%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<p>​    在阅读论文时记录的一些论文信息和对该论文的简单介绍，记录这些可方便我在需要时快速查找和定位。以下主要记录的是可视化相关论文和迁移学习相关论文的简介。后续将继续完善。</p>
<span id="more"></span>

<h3 id="可视化相关"><a href="#可视化相关" class="headerlink" title="可视化相关"></a>可视化相关</h3><ul>
<li>2021 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=167n0gf0y90y0610033y0ce0aw359840&site=xueshu_se&hitarticle=1">TrammelGraph: visual graph abstraction for comparison</a> 【Journal of Visualization】<ul>
<li>整理中…..</li>
</ul>
</li>
<li>2020.11.25  <a href="http://www.shixialiu.com/publications/survey-cvm/paper.pdf">A Survey of Visual Analytics Techniques for Machine Learning</a><ul>
<li>该综述归纳整理了2010-2020年的可视化相关论文及2010年以前的少数可视化相关论文，共259篇；</li>
<li>论文范围包括：InfoVis，VAST，Vis（后来的SciVis）,EuroVis，PacificVis，IEEE TVCG，CGF和CG&A;</li>
</ul>
</li>
<li>2020.09.15  <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=16670240bn0c0xe0wy6f04r08j753432&site=xueshu_se&hitarticle=1">A Visual Analytics Framework for Explaining and Diagnosing Transfer Learning</a> 【TVCG】<ul>
<li>整理中…</li>
</ul>
</li>
<li>2019.08.01 <a href="https://ieeexplore.ieee.org/document/8827593">Ablate, Variate, and Contemplate: Visual Analytics for Discovering Neural Architectures.</a> 【TVCG】<ul>
<li>提出了快速探索模型结构和参数，或重新映射的一个可视化的分析工具，使模型建设者能够发现一个深入的学习模型，通过ablations, variations, or handcrafted templates创建新模型。</li>
</ul>
</li>
<li>2018.12.05 <a href="https://ieeexplore.ieee.org/document/8611178">Exploring the Sensitivity of Choropleths under Attribute Uncertainty</a> 【TVCG】<ul>
<li>提出了一个可视化分析系统，提高了我们对属性不确定性对数据可视化和统计分析的影响的理解。</li>
<li>通过系统设计的三种可视化视图及案列，来说明地理分析中属性不确定性的影响。</li>
</ul>
</li>
<li>2018.04.01 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=5c50030c63a9a4718e4923d4aa552d7e&site=xueshu_se&hitarticle=1">Visualizing Deep Neural Networks for Text Analytics</a> 【IEEE】<ul>
<li>整理中…</li>
</ul>
</li>
<li>2017 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=4740f0caa77d0d2302eef4020fe2d3de&site=xueshu_se">Towards Better Analysis of Deep Convolutional Neural Networks</a> 【TVCG】<ul>
<li>整理中…</li>
</ul>
</li>
<li>2015.10.25 <a href="https://ieeexplore.ieee.org/document/7194832">Task-Driven Comparison of Topic Models</a> 【TVCG】<ul>
<li>主题建模是一种从大量文本中统计提取主题内容的方法，用于文本分析中的各种任务。</li>
<li>本文探讨了以任务为中心的主题模型比较。主要分为理解主题、理解相似性和理解变化，并提供了一些可视化的技术来促进这些任务，如（buddy plots）。它结合了颜色和位置编码，允许分析人员随时查看文档相似性的变化。</li>
</ul>
</li>
<li>2014.11.09 <a href="https://ieeexplore.ieee.org/document/6876047/references#references">INFUSE: Interactive Feature Selection for Predictive Modeling of High Dimensional Data</a> 【TVCG】<ul>
<li>许多特征选择算法决定使用哪一个时，算法输出通常不适合用户解释。</li>
<li>旨在帮助分析人员<strong>了解</strong>预测特征在特征选择算法、交叉验证折叠和分类器中的排名。</li>
</ul>
</li>
<li>2011.10.14 <a href="https://ieeexplore.ieee.org/document/6065026/">DICON: Interactive Visual Analysis of Multidimensional Clusters</a> 【TVCG】<ul>
<li>DICON是一种基于动态图标的可视化技术，可以帮助用户理解、评估和调整复杂的多维聚类。它提供了描述簇的质量及其多个属性的视觉线索，并且可以嵌入到多种可视化中，如地图、散点图和图形。</li>
<li>用于复杂的多维聚类分析。</li>
</ul>
</li>
</ul>
<h3 id="迁移学习相关"><a href="#迁移学习相关" class="headerlink" title="迁移学习相关"></a>迁移学习相关</h3><ul>
<li>2020.08 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=1b320cs0q47c08u04y1m0m408x148126&site=xueshu_se&hitarticle=1">LEEP: A New Measure to Evaluate Transferability of Learned Representations</a> 【ICML】<ul>
<li>一种用于评估可迁移性的新方法；</li>
<li>该方法可以预测迁移学习方法的性能和收敛速度;</li>
<li>是第一个开发元迁移学习的可迁移性测量的工作；</li>
<li>对于小数据或不平衡数据也同样适用；</li>
</ul>
</li>
<li>2019.01 ICIP <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=1r6y0ty0bf4p0jy0np2e0cp058458877&site=xueshu_se&hitarticle=1">An information-theoretic approach to transferability in task transfer learning</a> 【IEEE】<ul>
<li>一种用于评估机器模型可迁移性的方法；</li>
<li>提出一种基于统计和信息理论的特征迁移能力度量标准——H-score；</li>
<li>使用该方法可以直接通过预训练模型和目标任务训练数据进行计算，无须在目标任务上训练模型；</li>
<li>适用于迁移学习中预训练模型选择问题；</li>
</ul>
</li>
<li>2018.08 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=a41fa8702b71de237b12337fec157b8d&site=xueshu_se&hitarticle=1">A Survey on Deep Transfer Learning</a> 【ICANN】<ul>
<li>给出了深度迁移学习的定义</li>
<li>通过收集整理近几年相关文献，将深度迁移学习分为四类，并具体对每一类进展进行了描述</li>
<li>适用于对深度迁移学习进一步了解</li>
</ul>
</li>
<li>2014.11 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=16510470du540gn0n15q0820xw060270&site=xueshu_se&hitarticle=1">How transferable are features in deep neural networks?</a> 【NIPS】<ul>
<li>论文深度神经网络中奇怪现象入手————前面几层都学习到的是通用的特征（general feature），随着网络的加深，后面的网络更偏重于学习特定的特征（specific feature），通篇以实验为主，提出并解决了在深度神经网络特征迁移中一些问题</li>
<li>深度神经网络特征迁移的程度如何受到高层特定化特征(specialization of higher layer features)和层之间的相互适应性(co-adapted layers)的影响</li>
<li>说明特征可转移性与任务间相关性正相关</li>
<li>指出通过可转移特征初始化网络能有效提高泛化性能并且由于随机权重</li>
<li>此篇论文对理解神经网络以及深度迁移学习都有着非常重要的意义，推荐阅读</li>
</ul>
</li>
</ul>
<h3 id="前端-浏览器相关"><a href="#前端-浏览器相关" class="headerlink" title="前端/浏览器相关"></a>前端/浏览器相关</h3><ul>
<li>2018 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=72090e5c4bd4bdb81083c1a8ccf196f4&site=xueshu_se&hitarticle=1">ECharts: A declarative framework for rapid construction of web-based visualization</a></li>
</ul>
]]></content>
      <categories>
        <category>论文概览</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>论文</tag>
        <tag>迁移学习</tag>
      </tags>
  </entry>
  <entry>
    <title>搞定前端手写题</title>
    <url>/2021/08/26/%E6%90%9E%E5%AE%9A%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%99%E9%A2%98/</url>
    <content><![CDATA[<p>​    本篇文章用于总结自己在前端面试的过程中所遇到的手撕题和前端常考的算法题，其主要包括题目与Javascript实现的解法。一部分题目的代码由自己编写实现，还有一部分题目的代码来源互联网，所有代码都经过自己的运行验证，请放心食用。后续还会持续更新。。。</p>
<span id="more"></span>

<h3 id="场景手写题"><a href="#场景手写题" class="headerlink" title="场景手写题"></a>场景手写题</h3><h4 id="手写debounce"><a href="#手写debounce" class="headerlink" title="手写debounce"></a>手写debounce</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,delay=<span class="number">100</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">input.addEventListener(<span class="string">&#x27;keyup&#x27;</span>,debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(input.value);</span><br><span class="line">&#125;,<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<h4 id="手写throttle"><a href="#手写throttle" class="headerlink" title="手写throttle"></a>手写throttle</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay = <span class="number">100</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">div.addEventListener(<span class="string">&#x27;drag&#x27;</span>,throttle(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.offsetX,e.offsetY);</span><br><span class="line">&#125;,<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<h4 id="手写flat"><a href="#手写flat" class="headerlink" title="手写flat"></a>手写flat</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*手写flat*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatDeep</span>(<span class="params">arr,deep = <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr[i]))&#123;</span><br><span class="line">         deep&gt;<span class="number">0</span>?(result = result.concat(flatDeep(arr[i],deep-<span class="number">1</span>))):(result.push(arr[i]))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手写深拷贝--初级版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj = &#123;&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj != <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">            result[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手写深拷贝升级版，克服对象循环引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj = &#123;&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj != <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(key)&amp;&amp;obj[key]!=obj)&#123;</span><br><span class="line">            result[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj[key]===obj)&#123;</span><br><span class="line">			result[key] = result;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手写call"><a href="#手写call" class="headerlink" title="手写call"></a>手写call</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    context =(context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) ? <span class="built_in">window</span> : context</span><br><span class="line">    <span class="comment">//其实就等价于 obj.fn = function say()&#123;&#125; 当指向 context.fn 时，say里面的this 指向obj</span></span><br><span class="line">    context.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//obj 此时变成 var obj = &#123;name:&#x27;innerName&#x27;,fn:function say()&#123;console.log(this.name)&#125;&#125;</span></span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>) <span class="comment">//截取第二个开始的所有参数</span></span><br><span class="line">    <span class="keyword">let</span> result= context.fn(...args)<span class="comment">//把执行的结果赋予result变量</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn <span class="comment">//删除执行上下文上的属性 （还原）由var obj = &#123;name:&#x27;innerName&#x27;,fn:function say()&#123;console.log(this.name)&#125;&#125;删除fn</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    context =(context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) ? <span class="built_in">window</span> : context;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">arguments</span>[<span class="number">1</span>] ? context.fn(...arguments[<span class="number">1</span>]) : context.fn()</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    context =(context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) ? <span class="built_in">window</span> : context</span><br><span class="line">    <span class="keyword">let</span> o = <span class="built_in">Object</span>.create(context)</span><br><span class="line">    o.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> result= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">       	 o.fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手写promise-all"><a href="#手写promise-all" class="headerlink" title="手写promise.all"></a>手写promise.all</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  Promise函数对象的all方法</span></span><br><span class="line"><span class="comment">  返回一个promise, 只有当所有proimse都成功时才成功, 否则只要有一个失败的就失败</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用来保存所有成功value的数组</span></span><br><span class="line">    <span class="keyword">const</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(arr.length) </span><br><span class="line">    <span class="comment">// 用来保存成功promise的数量</span></span><br><span class="line">    <span class="keyword">let</span> resolvedCount = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 返回一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 遍历promises获取每个promise的结果</span></span><br><span class="line">      arr.forEach(<span class="function">(<span class="params">p, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">          value =&gt; &#123;</span><br><span class="line">            resolvedCount++ <span class="comment">// 成功的数量加1</span></span><br><span class="line">            <span class="comment">// p成功, 将成功的vlaue保存vlaues</span></span><br><span class="line">            <span class="comment">// values.push(value)</span></span><br><span class="line">            values[index] = value</span><br><span class="line">            <span class="comment">// 如果全部成功了, 将return的promise改变成功</span></span><br><span class="line">            <span class="keyword">if</span> (resolvedCount===promises.length) &#123;</span><br><span class="line">              resolve(values)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          reason =&gt; &#123; <span class="comment">// 只要一个失败了, return的promise就失败</span></span><br><span class="line">            reject(reason)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="手写promise-race"><a href="#手写promise-race" class="headerlink" title="手写promise.race"></a>手写promise.race</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现Promise.race()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     Promise函数对象的race方法</span></span><br><span class="line"><span class="comment">     返回一个promise对象，状态由第一个完成的promise决定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Promise</span>.myRace = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function">(<span class="params">p,index</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">            	value=&gt;&#123;</span><br><span class="line">                    resolve(value)</span><br><span class="line">                &#125;,</span><br><span class="line">                reason=&gt;&#123;</span><br><span class="line">                    reject(reason);</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;ok1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;resolve(<span class="string">&#x27;ok2&#x27;</span>)&#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;ok3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.myRace([p2,p1,p3]).then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="手写promise-resolveDelay"><a href="#手写promise-resolveDelay" class="headerlink" title="手写promise.resolveDelay"></a>手写promise.resolveDelay</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolveDelay = <span class="function"><span class="keyword">function</span> (<span class="params">value, time</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123; </span><br><span class="line">              <span class="comment">// 如果 value 是一个 promise, 取这个 promise 的结果值作为返回的 promise 的结果值 </span></span><br><span class="line">                value.then(resolve, reject) </span><br><span class="line">                <span class="comment">// 如果 value 成功, 调用 resolve(val), 如果 value 失败了, 调用reject(reason) </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                resolve(value) </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;, time); </span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手写Promise-rejectDelay"><a href="#手写Promise-rejectDelay" class="headerlink" title="手写Promise.rejectDelay"></a>手写Promise.rejectDelay</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.rejectDelay = <span class="function"><span class="keyword">function</span> (<span class="params">reason, time</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">            reject(reason);</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手写LazyMan函数"><a href="#手写LazyMan函数" class="headerlink" title="手写LazyMan函数"></a>手写LazyMan函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现：lazyman(&quot;hack&quot;).sleep(10).eat(&quot;food&quot;);</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">	Hi，你好Hack</span></span><br><span class="line"><span class="comment">	wait(10)...</span></span><br><span class="line"><span class="comment">	eat food;</span></span><br><span class="line"><span class="comment">注释：其中eat()和sleep()没有顺序关系，可以且可以多次调用</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">const</span> lazyman = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">`Hi,你好<span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     executeChain: <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">     eat,</span><br><span class="line">     sleep</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.executeChain = <span class="built_in">this</span>.executeChain.then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`eat <span class="subst">$&#123;food&#125;</span>`</span>);</span><br><span class="line">     resolve();</span><br><span class="line">   &#125;))</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> sleep = <span class="function"><span class="keyword">function</span> (<span class="params">time</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.executeChain = <span class="built_in">this</span>.executeChain.then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       resolve();</span><br><span class="line">     &#125;, time)</span><br><span class="line">   &#125;))</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Promise超时控制"><a href="#Promise超时控制" class="headerlink" title="Promise超时控制"></a>Promise超时控制</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原理其实很简单，就是利用Promise.race，我们先创建一个Promise，里面用setTimeout进行处理，然后将新创建的Promise与我们之前使用的Promise&quot;比赛&quot;一下。</span></span><br><span class="line"><span class="keyword">let</span> rest=<span class="function"><span class="keyword">function</span>(<span class="params">_data=<span class="number">1000</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Promise</span>.race([</span><br><span class="line">		upload(),</span><br><span class="line">		uploadTimeout(_data)</span><br><span class="line">	]).then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(value)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;请求进行中...&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">		xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&quot;https://www.baidu.com&quot;</span>);</span><br><span class="line">		xhr.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(xhr.readyState==<span class="number">4</span> &amp;&amp; (xhr.status&gt;=<span class="number">200</span> &amp;&amp; xhr.status&lt;<span class="number">300</span>))&#123;</span><br><span class="line">				<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">					resolve(<span class="string">&quot;请求成功！&quot;</span>)</span><br><span class="line">				&#125;,<span class="number">2000</span>)</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				reject(xhr.status)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		xhr.onerror=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			reject(<span class="string">&#x27;请求失败了...&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		xhr.send(<span class="literal">null</span>);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadTimeout</span>(<span class="params">times</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">			reject(<span class="string">&#x27;请求超时，请重试&#x27;</span>);</span><br><span class="line">		&#125;,times)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise取消重复请求"><a href="#Promise取消重复请求" class="headerlink" title="Promise取消重复请求"></a>Promise取消重复请求</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CancelablePromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.pendingPromise = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包装一个请求并取消重复请求</span></span><br><span class="line">CancelablePromise.prototype.request = <span class="function"><span class="keyword">function</span> (<span class="params">requestFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.pendingPromise) &#123;</span><br><span class="line">    <span class="built_in">this</span>.cancel(<span class="string">&quot;取消重复请求&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> _promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> (<span class="built_in">this</span>.reject = reject));</span><br><span class="line">  <span class="built_in">this</span>.pendingPromise = <span class="built_in">Promise</span>.race([requestFn(), _promise]);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.pendingPromise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消当前请求</span></span><br><span class="line">CancelablePromise.prototype.cancel = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(reason));</span><br><span class="line">  <span class="built_in">this</span>.pendingPromise = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------下面是测试用例------------</span></span><br><span class="line"><span class="comment">// 模拟一个异步请求函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRequest</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cancelPromise = <span class="keyword">new</span> CancelablePromise();</span><br><span class="line"><span class="comment">// 前四个请求将被自动取消</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  cancelPromise</span><br><span class="line">    .request(createRequest(<span class="number">1000</span>))</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// 最后一个 done</span></span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.error(err)); <span class="comment">// 前四个 error: 取消重复请求</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置一个定时器等3s，让前面的请求都处理完再继续测试</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 手动取消最后一个请求</span></span><br><span class="line">  cancelPromise</span><br><span class="line">    .request(createRequest(<span class="number">1000</span>))</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.error(err)); <span class="comment">// error:手动取消</span></span><br><span class="line">  cancelPromise.cancel(<span class="string">&quot;手动取消&quot;</span>);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个定时器等4s，让前面的请求都处理完再继续测试</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  cancelPromise</span><br><span class="line">    .request(createRequest(<span class="number">1000</span>))</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// done</span></span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.error(err));</span><br><span class="line">&#125;, <span class="number">4000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Promise并发控制"><a href="#Promise并发控制" class="headerlink" title="Promise并发控制"></a>Promise并发控制</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发请求限制并发数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;()=&gt;Promise&lt;any&gt; []&#125;</span> </span>requestFns 并发请求函数数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;numer&#125;</span> </span>limit 限制最大并发数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concurrentRequest</span>(<span class="params">requestFns, limit</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recursion</span>(<span class="params">requestFn</span>) </span>&#123;</span><br><span class="line">    requestFn().finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (_requestFns.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        recursion(_requestFns.pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> _requestFns = [...requestFns];</span><br><span class="line">  <span class="comment">// 限制最大并发量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; limit &amp;&amp; _requestFns.length &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">    recursion(_requestFns.pop());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------下面是测试用例------------</span></span><br><span class="line"><span class="comment">// 模拟一个异步请求函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRequest</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> requestFns = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  requestFns.push(createRequest(<span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line">concurrentRequest(requestFns, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Promise全局loading态"><a href="#Promise全局loading态" class="headerlink" title="Promise全局loading态"></a>Promise全局loading态</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseManager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.pendingPromise = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="built_in">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给每个pending态的promise生成一个身份标志</span></span><br><span class="line">PromiseManager.prototype.generateKey = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()&#125;</span>-<span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">1000</span>)&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line">PromiseManager.prototype.push = <span class="function"><span class="keyword">function</span> (<span class="params">...requestFns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> requestFn <span class="keyword">of</span> requestFns) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="built_in">this</span>.generateKey();</span><br><span class="line">    <span class="built_in">this</span>.pendingPromise.add(key);</span><br><span class="line">    requestFn().finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.pendingPromise.delete(key);</span><br><span class="line">      <span class="built_in">this</span>.loading = <span class="built_in">this</span>.pendingPromise.size !== <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ----------下面是测试用例------------</span></span><br><span class="line"><span class="comment">// 模拟一个异步请求函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRequest</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> manager = <span class="keyword">new</span> PromiseManager();</span><br><span class="line"><span class="comment">// 增加多个请求</span></span><br><span class="line">manager.push(createRequest(<span class="number">1000</span>));</span><br><span class="line">manager.push(createRequest(<span class="number">4500</span>));</span><br><span class="line"><span class="comment">// 每秒轮询loading态，直到loading为false</span></span><br><span class="line"><span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(manager.loading);</span><br><span class="line">  <span class="keyword">if</span> (!manager.loading) <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="手写柯里化"><a href="#手写柯里化" class="headerlink" title="手写柯里化"></a>手写柯里化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Curry</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            arr = arr.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="literal">null</span>,arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = Curry(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total,item</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total+item;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> s= fn(<span class="number">1</span>)(<span class="number">2</span>)()</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br></pre></td></tr></table></figure>

<h4 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：左侧float:left;右侧margin-left;</span></span><br><span class="line"><span class="comment">//因为块级元素有流体特性，即默认会填充满外部容器，所以只需要设置margin，不需要设置width就可以让content填满剩余的部分。</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;left&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;right&lt;/div&gt;</span><br><span class="line">body,div&#123;</span><br><span class="line">    padding: <span class="number">0</span>;</span><br><span class="line">    margin:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.left,.right&#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background-color:skyblue;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    margin-left: 200px;</span><br><span class="line">    background-color: greenyellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：左侧float:left; 右侧overflow:hidden；</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;left&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;right&lt;/div&gt;</span><br><span class="line">body,div&#123;</span><br><span class="line">    padding: <span class="number">0</span>;</span><br><span class="line">    margin:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.left,.right&#123;</span><br><span class="line">    height:200px;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    float:left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background-color:skyblue;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">    background-color: greenyellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式三</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;wrap&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;left&lt;/div&gt;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;right&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">body,div&#123;</span><br><span class="line">    padding: <span class="number">0</span>;</span><br><span class="line">    margin:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.wrap&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.left,.right&#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background-color:skyblue;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    flex: <span class="number">1</span>; </span><br><span class="line">    background-color: greenyellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//flex:1</span></span><br><span class="line">	flex-grow : <span class="number">1</span>; <span class="comment">// 这意味着div将以与窗口大小相同的比例增长</span></span><br><span class="line">	flex-shrink : <span class="number">1</span>; <span class="comment">// 这意味着div将以与窗口大小相同的比例缩小</span></span><br><span class="line">	flex-basis : <span class="number">0</span>; <span class="comment">// 给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小。等于0就是均分的意思；</span></span><br></pre></td></tr></table></figure>

<h4 id="双飞翼布局（三栏布局）"><a href="#双飞翼布局（三栏布局）" class="headerlink" title="双飞翼布局（三栏布局）"></a>双飞翼布局（三栏布局）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="comment">/*给内部div添加margin，把内容放到中间栏，其实整个背景还是100%*/</span></span><br><span class="line">#inside &#123;</span><br><span class="line">    margin: <span class="number">0</span> 200px <span class="number">0</span> 180px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">#center &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: <span class="number">100</span>%;</span><br><span class="line">    <span class="comment">/*左栏上去到第一行*/</span></span><br><span class="line">    height: 100px;</span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br><span class="line">#left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 180px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-left: -<span class="number">100</span>%;</span><br><span class="line">    background: #0c9;</span><br><span class="line">&#125;</span><br><span class="line">#right &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-left: -200px;</span><br><span class="line">    background: #0c9;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;inside&quot;</span>&gt;middle&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;left&quot;</span>&gt;left&lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;right&quot;</span>&gt;right&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h4 id="圣杯布局（三栏布局）"><a href="#圣杯布局（三栏布局）" class="headerlink" title="圣杯布局（三栏布局）"></a>圣杯布局（三栏布局）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">#bd&#123;</span><br><span class="line">    padding: <span class="number">0</span> 200px <span class="number">0</span> 180px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">#middle&#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: <span class="number">100</span>%;</span><br><span class="line">    height: 500px;</span><br><span class="line">    background:blue;</span><br><span class="line">&#125;</span><br><span class="line">#left&#123;</span><br><span class="line">    float:left;</span><br><span class="line">    width:180px;</span><br><span class="line">    height:500px;</span><br><span class="line">    margin-left:-<span class="number">100</span>%;</span><br><span class="line">    background: #0c9;</span><br><span class="line">    position: relative;</span><br><span class="line">    left: -180px;</span><br><span class="line">&#125;</span><br><span class="line">#right&#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 500px;</span><br><span class="line">    margin-left: -200px;</span><br><span class="line">    background: #0c9;</span><br><span class="line">    position: relative;</span><br><span class="line">    right: -200px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;bd&quot;</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;middle&quot;</span>&gt;middle&lt;/div&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;left&quot;</span>&gt;left&lt;/div&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;right&quot;</span>&gt;right&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>



<h3 id="排序及查找算法"><a href="#排序及查找算法" class="headerlink" title="排序及查找算法"></a>排序及查找算法</h3><h4 id="快速排序O-nlogn"><a href="#快速排序O-nlogn" class="headerlink" title="快速排序O(nlogn)"></a>快速排序O(nlogn)</h4><p>不稳定的排序</p>
<p>思想：划定两个区域，-1位置表示小于num的区域，数组长度+1的位置表示大于num的区域，然后cur指针从0位置开始遍历。如果小于num，把<strong>小于区域的下一个位置</strong>和cur位置交换，交换完之后小于等于区域扩大一个位置cur也++。如果等于num，cur直接+1其他不变。如果大于num,把大于区域的前一个位置和cur交换，more前移动一个位置，cur不变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr,L=<span class="number">0</span>,R=arr.length-<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;R)&#123;</span><br><span class="line">		<span class="keyword">let</span> p = partition(arr,L,R);</span><br><span class="line">		quickSort(arr,L,p[<span class="number">0</span>]);</span><br><span class="line">		quickSort(arr,p[<span class="number">1</span>],R);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr,L,R</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> less = L-<span class="number">1</span>,more = R+<span class="number">1</span>,cur = L;</span><br><span class="line">		<span class="keyword">let</span> num = arr[R];</span><br><span class="line">		<span class="keyword">while</span>(cur&lt;more)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[cur]&lt;num)&#123;</span><br><span class="line">				swap(arr,++less,cur++);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[cur]&gt;num)&#123;</span><br><span class="line">				swap(arr,cur,--more);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				cur++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> [less,more];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr,i,j</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> temp = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序O-nlogn"><a href="#归并排序O-nlogn" class="headerlink" title="归并排序O(nlogn)"></a>归并排序O(nlogn)</h4><p>可以实现稳定的排序</p>
<p>思想：使用递归先对数组进行无限分割，然后再对分割出来的两块进行合并；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr,l,r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((l+r)/<span class="number">2</span>);</span><br><span class="line">    mergeSort(arr,l,mid);</span><br><span class="line">    mergeSort(arr,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">let</span> temp=[];</span><br><span class="line">    <span class="keyword">let</span> i = l;</span><br><span class="line">    <span class="keyword">let</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;=arr[j])&#123;</span><br><span class="line">            temp.push(arr[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp.push(arr[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        temp.push(arr[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)&#123;</span><br><span class="line">        temp.push(arr[j]);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++)&#123;</span><br><span class="line">        arr[i] = temp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆排序O-nlogn"><a href="#堆排序O-nlogn" class="headerlink" title="堆排序O(nlogn)"></a>堆排序O(nlogn)</h4><p>不稳定的排序</p>
<p>思想：</p>
<ol>
<li>建立大根堆：对于每个小二叉树，通过其子节点的(n-1)/2找到其父节点的位置，当父节点小于子节点时交换位置，依次循环。</li>
<li>然后将堆顶元素和树的最后一个叶子节点进行交换，此时最后一个叶子节点上的值为当前树中的最大值，然后将除开此叶子节点的树重复1-2的过程。</li>
</ol>
<h4 id="冒泡排序O-n-2"><a href="#冒泡排序O-n-2" class="headerlink" title="冒泡排序O(n^2)"></a>冒泡排序O(n^2)</h4><p>可以实现稳定的排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length === <span class="number">0</span> ) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=arr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">let</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序O-n-2"><a href="#插入排序O-n-2" class="headerlink" title="插入排序O(n^2)"></a>插入排序O(n^2)</h4><p>可以实现稳定的排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length===<span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">let</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序O-n-2"><a href="#选择排序O-n-2" class="headerlink" title="选择排序O(n^2)"></a>选择排序O(n^2)</h4><p>不稳定的排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length===<span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">let</span> min,temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        min=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;arr.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[min]&gt;arr[j])&#123;</span><br><span class="line">              	min =j;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[min];</span><br><span class="line">        arr[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">arr,data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = arr.length-<span class="number">1</span>, <span class="comment">//最大值</span></span><br><span class="line">        min = <span class="number">0</span>;  <span class="comment">//最小值</span></span><br><span class="line">    <span class="keyword">while</span>(min&lt;=max)&#123;</span><br><span class="line">        <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor((max+min)/<span class="number">2</span>); <span class="comment">//中间值</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;data)&#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&gt;data)&#123;</span><br><span class="line">            max = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//没找到返回false</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h3 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h3><h4 id="先序遍历（递归）"><a href="#先序遍历（递归）" class="headerlink" title="先序遍历（递归）"></a>先序遍历（递归）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        res.push(root.val);</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="先序遍历（非递归）"><a href="#先序遍历（非递归）" class="headerlink" title="先序遍历（非递归）"></a>先序遍历（非递归）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">while</span>(root || stack.length!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            res.push(root.val);</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历（递归）"><a href="#中序遍历（递归）" class="headerlink" title="中序遍历（递归）"></a>中序遍历（递归）</h4><p>按先序类推</p>
<h4 id="中序遍历（非递归）"><a href="#中序遍历（非递归）" class="headerlink" title="中序遍历（非递归）"></a>中序遍历（非递归）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">while</span>(root || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        res.push(root.val);</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="后续遍历（递归）"><a href="#后续遍历（递归）" class="headerlink" title="后续遍历（递归）"></a>后续遍历（递归）</h4><p>按先序类推</p>
<h4 id="后续遍历（非递归）"><a href="#后续遍历（非递归）" class="headerlink" title="后续遍历（非递归）"></a>后续遍历（非递归）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">while</span>(root || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            res.unshift(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res = [],stack=[root];</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> len = stack.length;</span><br><span class="line">        res[i] = [];</span><br><span class="line">        <span class="keyword">while</span>(len)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur = stack.shift();</span><br><span class="line">            res[i].push(cur.val)</span><br><span class="line">            <span class="keyword">if</span>(cur.left) stack.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right) stack.push(cur.right);</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="js实现大数相加"><a href="#js实现大数相加" class="headerlink" title="js实现大数相加"></a>js实现大数相加</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	如：3473243899994324123+142325235</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addString</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.length&lt;b.length)&#123;</span><br><span class="line">        a = a.padStart(b.length,<span class="string">&quot;0&quot;</span>)  <span class="comment">//padStart从头开始补全，padEnd从尾部开始补全</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.length&gt;b.length)&#123;</span><br><span class="line">        b = b.padStart(a.length,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> addOne = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=a.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="built_in">Number</span>(a[i])+<span class="built_in">Number</span>(b[i])+addOne;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;<span class="number">9</span>)&#123;</span><br><span class="line">            res.unshift(sum-<span class="number">10</span>);</span><br><span class="line">            addOne = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.unshift(sum);</span><br><span class="line">            addOne = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(addOne)&#123;</span><br><span class="line">        res.unshift(addOne);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断表达式是否闭合"><a href="#判断表达式是否闭合" class="headerlink" title="判断表达式是否闭合"></a>判断表达式是否闭合</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	如：</span></span><br><span class="line"><span class="comment">		输入：&#123;[]&#125;&#123;</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">    如：</span></span><br><span class="line"><span class="comment">    	输入：&#123;[]&#125;</span></span><br><span class="line"><span class="comment">    	输出：true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">while</span>(arr.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = arr.shift();</span><br><span class="line">        <span class="keyword">if</span>(c === <span class="string">&quot;(&quot;</span> || c===<span class="string">&quot;[&quot;</span> || c=== <span class="string">&quot;&#123;&quot;</span>)&#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c===<span class="string">&quot;)&quot;</span> || c===<span class="string">&quot;]&quot;</span> || c=== <span class="string">&quot;&#125;&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(test(stack.pop()) != c)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(str === <span class="string">&quot;(&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(str === <span class="string">&quot;[&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(str === <span class="string">&quot;&#123;&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack.length ===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化使用工具总结</title>
    <url>/2021/04/22/%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​    可视化使用工具根据其使用的可拓展性（即灵活性）可分为三类：交互式可视化工具、配置式可视化工具、编程式可视化工具。其中他们的可拓展性依次递增，编程式可视化工具可拓展性最好，但同时由于：交互式可视化工具可能仅需要用户掌握软件使用方法；配置式可视化工具需要使用人员具有一定基础编程能力；编程式可视化工具更是需要使用者熟练掌握相应的编程语言。故这三类可视化工具的使用难度也依次递增。其详细信息如下：</p>
<span id="more"></span>

<p><img src="/2021/04/22/%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/image-20210406100636328.png" alt="image-20210406100636328"></p>
<h4 id="交互式可视化工具"><a href="#交互式可视化工具" class="headerlink" title="交互式可视化工具"></a>交互式可视化工具</h4><p>以Power BI &amp; Tableau为例，一般为商业性软件，可方便的绘制图表</p>
<p><img src="/2021/04/22/%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/image-20210406100808525.png" alt="image-20210406100808525"></p>
<p>  tableau:商业智能软件，适用于商业报表、数据分析等场景。可以提供简单的图表的创建。</p>
<p>  将分析和构建可视化图表的过程分为了以下五步:</p>
<p>  连接数据源——&gt;构建可视化视图———&gt;创建工作表——–&gt;构建仪表盘——–&gt;数据故事</p>
<p>   一般交互式可视化工具它适用于如用户缺少编程基础、数据是简单的数据、任务需求比较简单和直接，只需要对数据集进行一个简单的了解这类应用场景，以下是一些适用于不同场景的交互式可视化工具：</p>
<p><img src="/2021/04/22/%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/image-20210406101035688.png" alt="image-20210406101035688"></p>
<h4 id="配置式可视化工具"><a href="#配置式可视化工具" class="headerlink" title="配置式可视化工具"></a>配置式可视化工具</h4><p>​      例如：Vega Lite、Echarts、Plotly,一般是通过用户传入特定的配置选项来完成既定的可视化形式。其中配置式一般是指用json对象来完成可视化的配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Vega-Lite：在2016年的Infovis上，华盛顿大学的交互实验室在发表的一篇文章中定义了一种交互式的可视化语法Vega Lite。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;data&quot;</span>:&#123;<span class="string">&quot;url&quot;</span>:<span class="string">&quot;data/cars.json&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&quot;mark&quot;</span>:<span class="string">&quot;circle&quot;</span>,</span><br><span class="line">    <span class="string">&quot;select&quot;</span>：&#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;point&quot;</span>,<span class="string">&quot;on&quot;</span>:<span class="string">&quot;mouseover&quot;</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;encoding&quot;</span>:&#123;</span><br><span class="line">         <span class="string">&quot;x&quot;</span>:&#123;<span class="string">&quot;field&quot;</span>:<span class="string">&quot;horsepower&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;quantitative&quot;</span>&#125;,</span><br><span class="line">         <span class="string">&quot;y&quot;</span>:&#123;<span class="string">&quot;field&quot;</span>:<span class="string">&quot;Miles_per_Gallon&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;quantitative&quot;</span>&#125;,</span><br><span class="line">         <span class="string">&quot;color&quot;</span>:[</span><br><span class="line">                &#123;<span class="string">&quot;if&quot;</span>:<span class="string">&quot;id&quot;</span>,<span class="string">&quot;value&quot;</span>:<span class="string">&quot;orange&quot;</span>&#125;</span><br><span class="line">                &#123;<span class="string">&quot;value&quot;</span>:<span class="string">&quot;steeblue&quot;</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>


<p>​    到目前为止，Vega-Lite已支持条形图、散点图、河流图、折线图、地图等多种图形，网址：<a href="https://vega.github.io/vega-lite/">https://vega.github.io/vega-lite/</a>.</p>
<p>echarts :由百度开发的基于js的图表库，可解决一些简单的可是分析需求。（详情请查询echarts官网配置项手册）</p>
<p>与Vega-Lite的不同之处在于，除了一般的二维平面可视化，他还提供了三维的可视化版本称为Echarts GL。</p>
<p>总结：相比于交互式可视化工具，配置式可视化工具适用于稍加复杂的场景，一般要求：</p>
<ol>
<li>用户：对编程有所了解。</li>
<li>数据：简单。 </li>
<li>任务/需求：中等复杂度，交互任务较多。往往可结合编程可视化工具来完成更加复杂的任务。</li>
</ol>
<p>除上述配置式可视化工具，现有的配置式可视化工具还有：由蚂蚁金服推出的国产可视化工具ANTV；由Uber官方推出的DECK.GL主要是面向城市数据、地理空间数据、三维可视化；PLOT.LY类似于echarts也是利用配置项来配制出具有交互的可视化图表，主要提供了面向python和R语言的可视化相关组件库，所以受众十分广；P4专门用于高性能可视化的一款工具，利用GPU的硬件进行加速，所以他能进行大规模的数据可视化，可以适用不同复杂的可视化场景。</p>
<h4 id="编程式可视化工具"><a href="#编程式可视化工具" class="headerlink" title="编程式可视化工具"></a>编程式可视化工具</h4><p>Processing：特性：</p>
<ol>
<li>基于Java和JVM，跨平台。</li>
<li>语言简单易上手，配套开发工具。</li>
<li>集成了OpenGL,利用硬件加速。</li>
<li>用户社区的卓越贡献。2001年诞生于麻省理工的媒体实验室，诞生之初的主要目的是通过激励性的可视化反馈来帮助非程序员的入门编程的学习。在其社区的推动下逐渐演变成了一个媒体媒体表达的一个语言 。</li>
</ol>
<p>D3：在2011年斯坦福大学发表的论文中提出的Data-Driven Documents，是目前使用率较高的编程式可视化工具。相对于Processing，D3更贴近于可视化的编程，在D3他们的工作里面提出了一种数据驱动的文档的理念。它把数据和可视化元素绑定起来。当有新的元素进入的时候/有旧的元素退出的时候可视化元素就会进行相应的更新来保持数据和展现的一致。</p>
<p> 编程式可视化工具总结:适用于更加复杂的可视化场景，其要求：</p>
<ol>
<li>用户：编程能力强。</li>
<li>任务/需求：难度高，复杂。</li>
<li>数据：复杂。其他适用于不同场景编程式可视化工具：p5*JS、VTK基于OpenGL、PixiJS、Tulip。</li>
</ol>
<h4 id="参考资料：浙江大学2020年暑期可视化课程"><a href="#参考资料：浙江大学2020年暑期可视化课程" class="headerlink" title="参考资料：浙江大学2020年暑期可视化课程"></a><strong>参考资料：</strong>浙江大学2020年暑期可视化课程</h4>]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>笔记</tag>
        <tag>浙大可视化暑期班2020</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读-2021-07-13</title>
    <url>/2021/07/13/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-2021-07-13/</url>
    <content><![CDATA[<blockquote>
<p>SUMMIT: Scaling Deep Learning Interpretability by Visualizing Activation and Attribution Summarizations.</p>
</blockquote>
<p>​    SUMMIT是一种较为新颖的用于总结和解释深度神经网络的方案。该方案主要通过聚合深度学习模型中的“ 重要神经元” 和 “神经元影响” 来创建归因图，进而通过可视化探索揭示深度学习模型中的关键神经元之间的关联和子结构。该方案将大型复杂的神经网络模型提炼成紧凑的交互式可视化系统，对大型数据模型也具有效性。本文还开源的他们可视化系统以及神经网络模型的训练代码，其网站如下：Visualization: <a href="https://github.com/fredhohman/summit">https://github.com/fredhohman/summit</a>. ；Code: <a href="https://github.com/fredhohman/summit-notebooks">https://github.com/fredhohman/summit-notebooks</a>. ；Data: <a href="https://github.com/fredhohman/summit-data">https://github.com/fredhohman/summit-data</a>. </p>
<p>整理中…..</p>
<span id="more"></span>

<p><img src="/2021/07/13/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-2021-07-13/1626225700820.png" alt="1626225700820"></p>
<h3 id="论文及作者"><a href="#论文及作者" class="headerlink" title="论文及作者"></a>论文及作者</h3><p>​    该论文来源于2019年TVCG作者是Fred Hohman, Haekyu Park,等人。乔治亚理工大学、麻省理工、加州理工美国并列的三大理工大学。</p>
<h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ol>
<li>通过聚合激活来发现重要神经元；</li>
<li>通过聚合神经元影响来识神经元之间的关系；</li>
<li>Attribution graph：用于显示那些对模型有贡献的神经元关系和子结构；</li>
</ol>
<h3 id="聚合激活"><a href="#聚合激活" class="headerlink" title="聚合激活"></a>聚合激活</h3><h3 id="聚合影响"><a href="#聚合影响" class="headerlink" title="聚合影响"></a>聚合影响</h3><h3 id="生成归因图"><a href="#生成归因图" class="headerlink" title="生成归因图"></a>生成归因图</h3><h3 id="可视化探索"><a href="#可视化探索" class="headerlink" title="可视化探索"></a>可视化探索</h3><h3 id="引用论文"><a href="#引用论文" class="headerlink" title="引用论文"></a>引用论文</h3><ol>
<li><p>现有用于解释图像神经网络预测的工作通常集中于解释单个图像或神经元的预测，如论文[40，41，49，53]。</p>
</li>
<li><p>使用交互式可视化来解释现代机器学习技术的复杂内部工作，论文[25，39，52]。</p>
</li>
<li><p>当模型表现不佳时，开发人员需要去了解他们的原因来修复他们。论文[24]、[46]介绍了此类方法或途径。</p>
<ul>
<li><p>[24] M. Kahng, P. Y. Andrews, A. Kalro, and D. H. P. Chau. <strong>Activis: Visual exploration of industry-scale deep neural network models</strong>. IEEE Transactions on Visualization and Computer Graphics, 24(1):88–97, 2018.</p>
</li>
<li><p>[46] Ribeiro M T ,  Singh S ,  Guestrin C . <strong>“Why Should I Trust You?”: Explaining the Predictions of Any Classifier</strong>[J]. ACM, 2016.</p>
</li>
</ul>
</li>
<li><p>了解整个类在模型中是如何表示的，这对于信任模型的预测和解读模型所学到的知识非常重要。因为这些表示被用于不同的任务，如迁移学习[43，59]。</p>
<ul>
<li>[59] A. R. Zamir, A. Sax, W. Shen, L. J. Guibas, J. Malik, and S. Savarese. <strong>Taskonomy: Disentangling task transfer learning.</strong> In <em>Proceedings of the</em> IEEE Conference on Computer Vision and Pattern Recognition, pp. 3712–3722, 2018.</li>
</ul>
</li>
<li><p>一种称为特征可视化的技术不是只考虑激活的大小，而是通过算法生成合成图像，最大化特定神经元 。论文包括[7, 11, 37, 38, 40, 50]。这些特征可视化针对单个神经元进行了优化，因此用户可以开始破译单个神经元可能学到的特征。</p>
</li>
<li><p>视觉分析系统 Blocks 显示类混淆模式遵循类的层次结构 [5]。Activation Atlases，大规模降维，显示许多平均激活 [7]。两种可视化都揭示了神经网络的有趣特性。</p>
</li>
<li><p>早期的可视化分析方法之一 CNNVis 为模型诊断和细化导出神经元连接，但没有扩展到具有许多类的大型数据集 [32]。</p>
</li>
<li><p>在对抗性机器学习的背景下，AEVis 使用反向传播来识别网络中良性和受攻击实例的数据路径发散的位置 [31]。</p>
</li>
<li><p>Building Blocks，建议使用矩阵分解将一层内的神经元集组合在一起，并跨层派生出“兼容”的神经元组[41]。</p>
</li>
<li><p>帮助不同的用户群体使用各种交互式和可视化技术来解释模型 [22]。</p>
</li>
<li><p>预测可视化分析通过可视化预测实例的分布、计算特征重要性以及直接检查模型和实例错误以支持调试，支持专家对机器学习模型进行性能分析 [2, 21, 34, 45, 58]。 </p>
</li>
<li><p>由于现代社会机器学习的普遍性和公众的普遍兴趣，使用直接操作向非专家解释模型的交互式可视化也受到关注 [19, 25, 52]。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>论文</tag>
        <tag>迁移学习</tag>
      </tags>
  </entry>
  <entry>
    <title>高维数据可视化</title>
    <url>/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p>​    高维数据可视化记录了学习《2020浙大可视化暑期班》的相关笔记。主要内容包括对数据维度的介绍、高维数据可视化的方法等。</p>
<span id="more"></span>

<h3 id="数据维度-Data-Dimension"><a href="#数据维度-Data-Dimension" class="headerlink" title="数据维度(Data Dimension)"></a>数据维度(Data Dimension)</h3><h4 id="一维-1-D"><a href="#一维-1-D" class="headerlink" title="一维(1-D)"></a>一维(1-D)</h4><p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620053725112.png" alt="1620053725112"></p>
<h4 id="二维-2-D"><a href="#二维-2-D" class="headerlink" title="二维(2-D)"></a>二维(2-D)</h4><p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620053817171.png" alt="1620053817171"></p>
<h4 id="三维-3-D"><a href="#三维-3-D" class="headerlink" title="三维(3-D)"></a>三维(3-D)</h4><p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620053851999.png" alt="1620053851999"></p>
<p>对于这种可视化的方法，它并不是一种非常好或者非常妥当的一种方法，作为可视化的专业人员会非常反对使用这种三维的数据可视化。在实际的使用或应用中，会极少的使用这种三维的散点图。因为它让我们用户去认识、感知和读出它的数据的效率是极低的。它会给人们带来非常大的偏差甚至误导， 主要有两点原因：</p>
<ol>
<li>由于它是一个三维的空间，所以我们从不同的视角上看过去，能够观察到这种数据的分布或模式是非常的不同的，这就给做数据分析带了极大的不可预测性和不确定性。</li>
<li>由于在三维的空间，所以不可避免的有数据的遮挡的问题。</li>
</ol>
<p>所以，如无必要尽量避免使用这种三维的可视化，除非数据本身是具有这种三维属性的。如飞机的起降数据、基于流场的可视化数据等。</p>
<h4 id="高维-High-Dimension"><a href="#高维-High-Dimension" class="headerlink" title="高维(High Dimension)"></a>高维(High Dimension)</h4><ul>
<li><p>对于高维数据如何实现可视化？</p>
<ol>
<li><p>通过增加视觉通道，如样式、颜色、大小等，以表达更多的属性信息</p>
<p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620053883695.png" alt="1620053883695"></p>
</li>
<li><p>多视图协调关联的方法(Multiple coordinated view:present some attributes of objects in a view)</p>
<p>​    这种方法主要是通过在每一个视图上，分别展现相同数据集的某几个数据的维度，我们可以通过增加视图的方法来支持呈现更多的属性的可视化。下图是一个多视图协调关联的例子：</p>
</li>
</ol>
<p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620053909829.png" alt="1620053909829"></p>
<p>   存在的问题：有关研究/心里学表明：太多的视图很容易会造成视觉的混淆，降低分析的效率。所以在进行多视图关联时，我们在视图之间关联的选择上也是要经过慎重的考虑的。因为不同的视图之间有可能会产生相互的干扰，设置不和谐不同意。</p>
<p>以上两种方法是最常见的两种处理高维数据可视化的方法，在接下来的一小节中进行重点介绍。</p>
</li>
</ul>
<h3 id="高维数据可视化-High-Dimensional-Data-Visualization"><a href="#高维数据可视化-High-Dimensional-Data-Visualization" class="headerlink" title="高维数据可视化(High-Dimensional Data Visualization)"></a>高维数据可视化(High-Dimensional Data Visualization)</h3><p>下面介绍的是几类比较经典的高维数据可视化的方法，以下高维数据可视化的方法可简单分为三大类型：数据的变换、数据的呈现、数据的交互。</p>
<h4 id="数据的变换"><a href="#数据的变换" class="headerlink" title="数据的变换"></a>数据的变换</h4><ul>
<li><p>降维(Dimensionality Reduction)</p>
<p>使用各种线性的或者非线性的变换，把高维的数据通过降维或者投影的方式，从高维的空间变换到低维的空间，从而降低数据的复杂度。原因是由于高维的数据中很有可能会存在大量的冗余，这种大量的冗余很有可能隐藏了重要关系的相关性，隐藏了重要的数据规律。所以通过降维不仅仅可以消除数据的冗余，减少被处理数据的数量，而且可以方便的在低维空间上将数据呈现。因此，该方法广泛的应用于数据可视化、数据挖掘和模式识别等领域。</p>
<p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620053940127.png" alt="1620053940127"></p>
<ol>
<li><p>线性的方法</p>
<ul>
<li><p>Principal Comonent Analysis (PCA)</p>
<p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620053965131.png" alt="1620053965131"></p>
<ol>
<li><p>如上图所示，对于具有两个属性的数据（一行代表一个属性），首先将每个数据减去它的一个均值。</p>
</li>
<li><p>将变化后的数据放到一个坐标系上。</p>
</li>
<li><p>在二维的平面当中去选择一个方向，将这五个点都投影到这个方向所在的直线上，用投影后的值来表示原始的记录。</p>
<p>如何去选择这个方向？我们希望降维后的值要尽可能的分散，而不是聚在一起</p>
<p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620053994363.png" alt="1620053994363"></p>
<p>选择一个方向，这个方向使得投影后的方差值最大。但是当维度多了之后就会出现维度的相关性，所以我们通过两个字段的协方差来表示相关性。</p>
<p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620054023121.png" alt="1620054023121"></p>
</li>
</ol>
</li>
<li><p>Multidimensional Scaling (MDS) 多尺度投影</p>
<p>通过输入一个原始数据集的矩阵，这个数据集是两两数据之间的相似程度。</p>
</li>
</ul>
</li>
<li><p>非线性的方法</p>
<ul>
<li>ISOMAP</li>
<li>Local Linear Embedding(LLE)</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="数据的呈现"><a href="#数据的呈现" class="headerlink" title="数据的呈现"></a>数据的呈现</h4><p>通过一些巧妙的数据可视化的布局方法，忠实、直观、生动的展现高维数据。</p>
<ul>
<li><p>散点图矩阵(Scatter-plot Matrix)</p>
<p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620054048474.png" alt="1620054048474"></p>
<p>存在的问题：当我们有很多的维度的时候，仅仅用肉眼去发现其中的规律或者模式往往比较困难，为了解决这种问题，有人就使用了一些智能的算法去自动的发现在散点图里面，哪一些散点图是更有意义的。</p>
<p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620054081364.png" alt="1620054081364"></p>
</li>
<li><p>平行坐标轴(Parallel Coordinates)</p>
<p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620054111193.png" alt="1620054111193"></p>
<p>存在的问题：当我们的数据很多时，往往会形成以下图案，我们从中发现不了它里面有什么关联（如左图），我们可以给每一个折线加一个透明度（如右图）。</p>
<p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620054137614.png" alt="1620054137614"></p>
</li>
<li><p>基于图标的方式(Glyph-based Methods)</p>
<ol>
<li><p>Star Plots(雷达图) </p>
<blockquote>
<p>可看做平行坐标轴的一个变种</p>
</blockquote>
</li>
<li><p>Chernoff Faces(脸谱图）</p>
<p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620054163274.png" alt="1620054163274"></p>
</li>
<li><p>Text+Glyph(将图标嵌入文本之中)</p>
<p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620054188553.png" alt="1620054188553"></p>
</li>
</ol>
</li>
<li><p>Small Multiples(小图标法)</p>
<p>用一系列的排列非常整齐的图表来做多维数据的可视化，从而方便我们进行对比，其案例主要如下：</p>
<p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620054214467.png" alt="1620054214467"></p>
<p><img src="/2021/05/03/%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/1620054242206.png" alt="1620054242206"></p>
</li>
</ul>
<h4 id="数据的交互"><a href="#数据的交互" class="headerlink" title="数据的交互"></a>数据的交互</h4><p>通过有效的人机交互的技术，帮助人们交互式的探索和分析高维的数据。</p>
<ul>
<li>Iteraction:”Dust &amp; Magnet”<ul>
<li>使用一个个类似于灰尘的点来代表数据点（Dust-Data points）</li>
<li>用磁铁来代表数据属性的过滤器（Magnet-Attribute Filters）</li>
<li>通过不断的抖动磁铁，就会把与这个磁铁相关的属性的灰尘往该磁铁的方向吸引</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>笔记</tag>
        <tag>浙大可视化暑期班2020</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读-2021-04-23</title>
    <url>/2021/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-2021-04-23/</url>
    <content><![CDATA[<blockquote>
<p>LEEP: A New Measure to Evaluate Transferability of Learned Representations</p>
</blockquote>
<p>​    良好的可迁移性估计有助于理解任务之间的关系，从而选择可迁移性强的任务进行训练，或者为给定的目标任务选择良好的源模型。迁移学习何时有效，何时无效？要进行迁移学习，应该用什么样的任务进行预训练？这些问题对了解和改善迁移学习十分重要。LEEP是一种用于评价学习表征可迁移性的新方法，可帮助我们解决以上遇到的问题。</p>
<span id="more"></span>

<h4 id="论文及作者"><a href="#论文及作者" class="headerlink" title="论文及作者"></a>论文及作者</h4><ul>
<li>该论文于2020年8月发表在37 th ICML会议(ICML是国际人工智能A类会议) </li>
<li>作者<ul>
<li>Cuong V. Nguyen（Amazon Web Services）</li>
<li>Tal Hassner（Facebook AI ）</li>
</ul>
</li>
</ul>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol>
<li><p>迁移学习何时有效，何时无效？如果你要进行迁移学习，你应该用什么样的任务进行预训练？</p>
</li>
<li><p>迁移学习三要素</p>
<ol>
<li><p>可迁移性</p>
<p>本文主要针对可迁移性的评估方法</p>
</li>
<li><p>迁移策略</p>
</li>
<li><p>迁移方法</p>
</li>
</ol>
</li>
<li><p>什么是可迁移性的评估？</p>
<p>是定量估计将一个分类任务中学习到的知识迁移到另一个分类任务有多容易的问题。</p>
<p>通俗的来讲就是：<br>​    给定一个源任务（由标记数据集或预先训练的模型表示）和一个目标任务（由标记数据集表示），可迁移性估计的目的是开发一个度量（或分数），该度量可以告诉我们，理想情况下，不需要对目标任务进行训练，迁移学习算法如何有效地从从源任务向目标任务中转移知识的。</p>
</li>
<li><p>为什么需要可迁移性的评估？</p>
<p>因为良好的可迁移性估计有助于理解任务之间的关系，从而选择可迁移性强的任务进行训练，或者为给定的目标任务选择良好的源模型。</p>
</li>
<li><p>早期的一些可迁移性评估的方法存在哪些问题？</p>
<ol>
<li><p>有助于理论分析，但由于不易计算</p>
</li>
<li><p>具有对称性，不适合于实际测量可迁移性</p>
</li>
<li><p>应用条件过于严格，不适用于一般性</p>
</li>
<li><p>度量很难解释</p>
<p>如：基于H分数的可转移性度量，它涉及到解决Hirschfeld-Gebelein-R’enyi最大相关问题</p>
</li>
<li><p>不能用于评估元迁移学习</p>
</li>
</ol>
</li>
<li><p>迁移学习、元学习和元迁移学习（Meta-transfer learning）</p>
<p><strong>迁移学习：</strong>利用已经训练好的开源网络模型和其已经在其他大型数据集上训练好的权重参数，将自己的任务数据集在这些迁移过来的网络上进行训练或者微调。</p>
<p><strong>元学习：</strong>利用以往的知识经验来指导新任务的学习，具有学会学习的能力。</p>
<p><strong>元迁移学习：</strong>学习从源任务迁移到目标任务的框架</p>
</li>
</ol>
<h4 id="本文工作"><a href="#本文工作" class="headerlink" title="本文工作"></a>本文工作</h4><ol>
<li><p>本文贡献</p>
<ul>
<li>提出了一种新的迁移学习评估方法-数学期望经验预测（LEEP），该方法可以预测迁移学习方法的性能和收敛速度。该方法与其他评价方法相比的优点在于：<ul>
<li>LEEP评分不需要对目标任务进行训练，从而避免了昂贵的参数优化步骤。</li>
<li>不仅适用于大目标数据集，而且适用于难以再训练的小型或不平衡的目标数据集。</li>
<li>可以在一般情况下广泛的应用于现代深层网络。</li>
</ul>
</li>
<li>不仅可以用于评估常规迁移学习机制，还可以用于评估元迁移学习。且是第一个开发元迁移学习的可迁移性测量的工作</li>
<li>对于小数据或不平衡数据也同样适用</li>
</ul>
</li>
<li><p>方法步骤</p>
<ol>
<li><p>计算目标数据集D中的虚拟标签分布θ(xi)</p>
<p>​    使用源域模型θ去对目标数据集D上的每个xi进行预测，得到源任务的标签集Z的预测分布。把这个分布定义为 θ(xi)，称为：Z上的范畴分布。注意：这个θ(xi)是源域任务标签上的虚拟分布，因为这些标签可能是没有意义的对于用例xi。</p>
</li>
<li><p>计算在给定源标签z下的目标标签y的经验条件分布</p>
<p><img src="/2021/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-2021-04-23/image-20210423160144643.png" alt="image-20210423160144643"></p>
<ol>
<li><p>首先计算所有标签对(y, z) ∈ Y × Z的经验联合分布</p>
<p><img src="/2021/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-2021-04-23/image-20210423160251645.png" alt="image-20210423160251645"></p>
</li>
<li><p>计算经验边际分布</p>
<p><img src="/2021/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-2021-04-23/image-20210423160322501.png" alt="image-20210423160322501"></p>
</li>
<li><p>计算经验条件分布</p>
<p><img src="/2021/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-2021-04-23/image-20210423160359291.png" alt="image-20210423160359291"></p>
</li>
</ol>
</li>
<li><p>LEEP度量总是负值，较大的值（即，较小的绝对值）表示更好的可转移性。当目标任务包含更多的类时，LEEP分数往往较小。由于度量的计算瓶颈（上面的步骤1）只需要一次通过目标数据集D的前向传递，因此该度量的计算效率也很高。</p>
</li>
</ol>
</li>
</ol>
<h4 id="案列分析"><a href="#案列分析" class="headerlink" title="案列分析"></a>案列分析</h4><ol>
<li><p>实验1</p>
<p>使用ResNet18在ImageNet上进行了预训练，使用ResNet20在CIFAR10上进行了预训练，目标任务的训练集和测试集来自CIFAR100数据集中的100类数据的子集。总共构造了200个不同的目标任务。采用两种常用的迁移学习方法进行实验。</p>
<p><img src="/2021/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-2021-04-23/image-20210423160709198.png" alt="image-20210423160709198"></p>
</li>
<li><p>实验2</p>
<p>使用FashionMNIST数据集构建目标数据集，目标数据集是从中从中抽取的四个随机类，每个类包含30个随<br>机示例。为了在评估小目标数据集上的LEEP分数时排除噪声，考虑将分数范围划分为五个相等的单元，并平均每个单元中任务的测试精度。</p>
<p><img src="/2021/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-2021-04-23/image-20210423160809846.png" alt="image-20210423160809846"></p>
<p>LEEP分数可以很好的评估可迁移性，即使在小数据也表现良好</p>
</li>
<li><p>实验3</p>
<p><img src="/2021/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-2021-04-23/image-20210423160853357.png" alt="image-20210423160853357"></p>
<p>LEEP分数可以很好的评估可迁移性即使对于不平衡的目标数据集也表现良好。</p>
</li>
<li><p>实验4</p>
<ul>
<li><p>使用ImageNet预训练ResNet18,并使用元数据集训练自适应网络。</p>
</li>
<li><p>目标数据集来自CIFAR100，每个目标数据集包含5个随机标签、每个类有50个样例。</p>
<p><img src="/2021/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-2021-04-23/image-20210423161002157.png" alt="image-20210423161002157"></p>
</li>
<li><p>从LEEP分数预测CNAPs在五个可迁移水平上的平均测试准确率。</p>
</li>
<li><p>证明LEEP也可以预测CNAPs（一种元迁移学习的方法）的测试精度。</p>
</li>
</ul>
</li>
<li><p>实验5</p>
<ul>
<li><p>为每个目标任务训练一个参考模型</p>
<p><img src="/2021/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-2021-04-23/image-20210423161532916.png" alt="image-20210423161532916"></p>
</li>
<li><p>证明了LEEP分数可以预测fine-tune的收敛</p>
</li>
</ul>
</li>
<li><p>实验6</p>
<ul>
<li>将LEEP度量与Tran等人（2019）提出的NCE度量以及Bao等人（2019）提出的H得分进行了比较。</li>
<li>实验设置：使用实验1、2、3、4中同样的数据集，进行训练。然后分别计算他们的NCE分数和H得分。</li>
<li>LEEP与另外两种可迁移性评估方法的对比（NCE、H scores）</li>
</ul>
</li>
<li><p>实验7</p>
<p>LEEP如何指导源模型的选择</p>
</li>
</ol>
<p><img src="/2021/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-2021-04-23/image-20210423161228179.png" alt="image-20210423161228179"></p>
<h4 id="文中提到的其他相关方法-可做后续阅读"><a href="#文中提到的其他相关方法-可做后续阅读" class="headerlink" title="文中提到的其他相关方法(可做后续阅读)"></a>文中提到的其他相关方法(可做后续阅读)</h4><ol>
<li>Tran等人（2019）提出的NCE度量</li>
<li>Bao等人（2019）提出的H得分</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><p>LEEP的作用</p>
<ol>
<li>可以用来选择迁移学习的源模型</li>
<li>可以帮助选择一组具有高度可迁移性的任务进行多任务学习</li>
<li>可以用于超参数的传递和优化，有助于最大限度地提高对特定数据的训练效果。</li>
</ol>
</li>
<li><p>论文思考</p>
<p>由于LEEP可以预测迁移学习微调方法的收敛速度，可作为迁移学习可视化方案中的可迁移性评估的理论支持</p>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>迁移学习</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读-2020-12-21</title>
    <url>/2020/12/21/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-2020-12-21/</url>
    <content><![CDATA[<blockquote>
<p>A Visual Analytics Framework for Explaining and Diagnosing Transfer Learning Processes.</p>
</blockquote>
<p>整理中….</p>
<span id="more"></span>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>论文</tag>
        <tag>迁移学习</tag>
      </tags>
  </entry>
</search>
