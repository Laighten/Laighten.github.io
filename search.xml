<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>V8垃圾回收机制</title>
    <url>/2021/04/17/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p> 目录：</p>
<ol>
<li>调用栈中的数据如何回收</li>
<li>堆中的数据是如何回收的</li>
<li>副垃圾回收器</li>
<li>主垃圾回收器</li>
<li>全停顿</li>
</ol>
</blockquote>
<span id="more"></span>

<p>JavaScript、Java、Python 等语言，<strong>产生的垃圾数据是由垃圾回收器来释放的</strong>，并不需要手动通过代码来释放。</p>
<h4 id="调用栈中的数据如何回收"><a href="#调用栈中的数据如何回收" class="headerlink" title="调用栈中的数据如何回收"></a>调用栈中的数据如何回收</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客邦 &quot;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> c = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">      <span class="keyword">var</span> d = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    showName()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>​    执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如下图所示。与此同时，还有一个<strong>记录当前执行状态的指针（称为 ESP）</strong>，指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p>
<!--more-->

<p>​    接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，<strong>这个下移操作就是销毁 showName 函数执行上下文的过程</strong>。</p>
<p><img data-src="image-20210304112315040.png" alt="image-20210304112315040"></p>
<p>所以说，当一个函数执行结束之后，<strong>JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文</strong>。</p>
<h4 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h4><p><strong>代际假说（The Generational Hypothesis）</strong>：</p>
<ul>
<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>
<li>第二个是不死的对象，会活得更久。</li>
</ul>
<p><strong>分代收集</strong>：</p>
<p>​    在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>
<ul>
<li><strong>副垃圾回收器，主要负责新生代的垃圾回收。</strong></li>
<li><strong>主垃圾回收器，主要负责老生代的垃圾回收。</strong></li>
</ul>
<p><strong>垃圾回收器的工作流程</strong>：</p>
<p>​    不管是主垃圾回收器还是副垃圾回收器都遵循以下这套公共的执行流程：</p>
<p>​    1、<strong>标记空间中活动对象和非活动对象</strong>。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p>
<p>​    2、<strong>回收非活动对象所占据的内存</strong>。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>
<p>​    3、<strong>内存整理</strong>。频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当出现量不连续的内存碎片后，我们再想分配一个较大的连续空间就会出现内存不足的情况。</p>
<h4 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h4><p>​    副垃圾回收器主要负责新生区的垃圾回收，用<strong>Scavenge 算法</strong>来处理。其原理就是：把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，新加入的对象都会存放到对象区域，<strong>当对象区域快被写满时</strong>，就需要执行一次垃圾清理操作。</p>
<p><img data-src="image-20210304114240567.png" alt="image-20210304114240567"></p>
<p>其回收过程如下：</p>
<p>​    1、对对象区域中的垃圾做标记，活动对象和非活动会对象；</p>
<p>​    2、标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些<strong>仍然存活的对象</strong>复制到空闲区域中，<strong>同时它还会把这些对象有序地排列起来，所以这个复制过程</strong>，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>
<p>​    3、完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。</p>
<p><strong>对象晋升策略</strong>：由于为了执行效率，新生区的空间通常会被设置的比较小，所以很容易被存满，为此JavaScript引擎引入了晋升策略，即：<strong>经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</strong></p>
<h4 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h4><p>​    老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p>
<p>​    主垃圾回收器是采用<strong>标记 - 清除（Mark-Sweep）</strong>的算法进行垃圾回收的。</p>
<p>1、<strong>对垃圾数据做标记</strong>。当调用栈中的ESP指向下一个执行上下文后，上一个执行上下文中引用对象在堆中的数据就会被当做垃圾数据被<strong>标为红色</strong>，而当前正被ESP指向的指向上下文中指针指向的栈中数据会被标为<strong>活动数据</strong>。</p>
<p>2、<strong>垃圾数据的清除</strong>。使用<strong>Mark-Sweep</strong>算法清除掉被标记为红色的垃圾数据。</p>
<p><img data-src="image-20210304115832389.png" alt="image-20210304115832389.png"></p>
<p>3、<strong>内存整理</strong>。使用<strong>标记 - 整理（Mark-Compact）</strong>对内存碎片进行整理。</p>
<p><img data-src="image-20210304115856708.png" alt="image-20210304115856708"></p>
<h4 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h4><p>​    于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p>
<p>​    为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记（Incremental Marking）算法</strong>。如下图所示：</p>
<p><img data-src="image-20210304120112556.png" alt="image-20210304120112556"></p>
<p>​    使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器工作原理</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>V8引擎编译器和解析器</title>
    <url>/2021/04/22/V8%E5%BC%95%E6%93%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>目录：</p>
<ol>
<li>编译器和解释器</li>
<li>V8 是如何执行一段 JavaScript 代码的</li>
<li>JavaScript的性能优化</li>
<li>总结</li>
</ol>
</blockquote>
<span id="more"></span>

<h4 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h4><p>​    <strong>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。</strong>比如 C/C++、GO 等都是编译型语言。</p>
<p>​    <strong>解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行</strong>。比如 Python、JavaScript 等都属于解释型语言。</p>
<p><img data-src="image-20210306105157354.png" alt="image-20210306105157354"></p>
<p><strong>（1）编译型语言的执行流程：</strong>编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</p>
<p><strong>（2）解释型语言的执行流程：</strong>解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</p>
<h4 id="V8-是如何执行一段-JavaScript-代码的"><a href="#V8-是如何执行一段-JavaScript-代码的" class="headerlink" title="V8 是如何执行一段 JavaScript 代码的"></a>V8 是如何执行一段 JavaScript 代码的</h4><p>​    V8 在执行过程中既有<strong>解释器 Ignition</strong>，又有<strong>编译器 TurboFan</strong>。其全局执行流程如下所示：</p>
<p><img data-src="image-20210306105718810.png" alt="image-20210306105718810"></p>
<h5 id="生成抽象语法树（AST）和执行上下文"><a href="#生成抽象语法树（AST）和执行上下文" class="headerlink" title="生成抽象语法树（AST）和执行上下文"></a>生成抽象语法树（AST）和执行上下文</h5><p>​    首先，将源代码转换成<strong>抽象语法树（AST）</strong>和<strong>执行上下文</strong>。高级语言是开发者可以理解的语言，而对于编译器和解释器来说他们可以理解的就是抽象语法树（AST）。这和渲染引擎将HTML格式的文件转换为自己可以理解的DOM树类似。</p>
<p>​    AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。<strong>Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</strong></p>
<p>​    除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p>
<p><strong>生成AST的两个阶段：</strong></p>
<p><strong>第一阶段是分词（tokenize），又称为词法分析</strong>，其作用是将一行行的源码拆解成一个个 token。所谓<strong>token</strong>，指的是语法上不可能再分的、最小的单个字符或字符串。</p>
<p><img data-src="image-20210306111037818.png" alt="image-20210306111037818"></p>
<p>​    从图中可以看出，通过<code>var myName = “极客时间”</code>简单地定义了一个变量，其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。</p>
<p><strong>第二阶段是解析（parse），又称为语法分析</strong>，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p>
<p><strong>有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。</strong></p>
<h5 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h5><p>​    有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。</p>
<p><strong>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</strong></p>
<p><img data-src="image-20210306111747379.png" alt="image-20210306111747379"></p>
<p>​    从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。</p>
<h5 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h5><p>​    通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码(HotSpot)，比如一段代码被重复执行多次，这种就称为<strong>热点代码</strong>，那么后台的编译器(TurboFan) 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p>
<p>​    其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为<strong>即时编译（JIT）</strong>。</p>
<h4 id="JavaScript的性能优化"><a href="#JavaScript的性能优化" class="headerlink" title="JavaScript的性能优化"></a>JavaScript的性能优化</h4><p>主要关注以下三点：</p>
<ol>
<li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>
<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>
<li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    （1）解释器和编译器在执行代码时都会先将代码通过词法分析、语法分析生成抽象语法树（AST），不同的是解释型语言会通过解释器将AST转换为字节码并直接逐条执行；而编译器会在AST的基础上先优化代码然后生成机器码进而编译生成二进制文件，执行时直接执行这个二进制文件。</p>
<p>​    （2）JavaScript的编译流程是：先通过词法分析和语法分析生成AST和可执行上下文，然后通过解释器将AST转换为字节码，并逐条执行。在生成AST时主要分为两步：第一步先通过词法分析生成token，第二步通过语法分析将token转换为AST。</p>
<p>​    （3）V8在代码的编译过程中采用的JIT（即时编译）技术来实现的。就是在生成字节码后，先使用解释器逐条解释并执行代码，如果遇到热点代码（被多次重复执行的代码），就会把这段字节码通过编译器编译为机器码，当再次遇到改代码是就可以直接执行。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器工作原理</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>this的指向问题</title>
    <url>/2021/04/18/this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>目录：</p>
<ol>
<li>如何判断this的指向</li>
<li>如何改变this的指向</li>
<li>使用fn.apply(this,arr)和fn(…arr)的区别</li>
<li>面试真题</li>
</ol>
</blockquote>
<span id="more"></span>

<h4 id="如何判断this的指向"><a href="#如何判断this的指向" class="headerlink" title="如何判断this的指向"></a>如何判断this的指向</h4><p>在使用 this 时，为了避坑，你要谨记以下四点：</p>
<ol>
<li>当函数作为对象的方法调用时，函数中的 this 就是该对象；</li>
<li>当函数被正常调用时，<strong>在严格模式下，this 值是 undefined</strong>，非严格模式下 this 指向的是全局对象 window；</li>
<li>嵌套函数中的 this 不会继承外层函数的 this 值。</li>
<li>我们还提了一下箭头函数，因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。</li>
<li>当this遇到return时，如果返回值是一个对象，那么this指向的是构造函数的实例但是并没有被返回，如果返回值不是一个对象，那么this还是指向构造函数创建的实例。</li>
</ol>
<p>下面从几道例题中去验证：</p>
<ol>
<li><p>直接使用的函数this指向window</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> user= <span class="string">&quot;呵呵&quot;</span>，</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.user),</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>),</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// window</span></span><br></pre></td></tr></table></figure></li>
<li><p>嵌套函数中的 this 不会继承外层函数的 this 值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> user = <span class="string">&quot;呵呵&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="built_in">this</span>.user);</span><br><span class="line">    &#125;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">o();</span><br></pre></td></tr></table></figure></li>
<li><p>当函数作为对象的方法调用时，函数中的 this 就是该对象，且永远指向最后调用它的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目一</span></span><br><span class="line"><span class="keyword">var</span> o=&#123;</span><br><span class="line">	a:<span class="number">10</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">    	a=<span class="number">12</span>,</span><br><span class="line">        fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.b.fn() <span class="comment">//12</span></span><br><span class="line"><span class="comment">//题目二</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	a:<span class="number">10</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">    	a:<span class="number">12</span></span><br><span class="line">        fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    		<span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">        	<span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j = o.b.fn;</span><br><span class="line">j(); <span class="comment">// undefined //window</span></span><br></pre></td></tr></table></figure></li>
<li><p>构造函数中的this指向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&#x27;呵呵&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Fn()</span><br><span class="line"><span class="built_in">console</span>.log(p.user) <span class="comment">// 呵呵</span></span><br></pre></td></tr></table></figure></li>
<li><p>当this遇到return时</p>
<p>如果返回值是一个对象，那么this指向的是构造函数的实例但是并没有被返回，如果返回值不是一个对象，那么this还是指向构造函数创建的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//undefined</span></span><br><span class="line">==============================</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//undefined</span></span><br><span class="line">==============================</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//呵呵</span></span><br><span class="line">==============================</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//呵呵</span></span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数中的this指向</p>
<p>箭头函数是ES6中的特性，箭头函数没有执行上下文本所以没有this，它会沿用/捕获外部环境的this。也就是说，箭头函数内部与外部的this是保持一致的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 题目一 */</span></span><br><span class="line"><span class="built_in">this</span>.a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">	a:<span class="number">40</span>,</span><br><span class="line">    init:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	<span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">        go.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> go</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = test.init()</span><br><span class="line">p()</span><br><span class="line"><span class="keyword">new</span> (test.init())()</span><br><span class="line"><span class="comment">/* 题目二 */</span></span><br><span class="line"><span class="built_in">this</span>.a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">	a:<span class="number">40</span>,</span><br><span class="line">    init:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	<span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">        go.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> go</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = test.init()</span><br><span class="line">p()</span><br><span class="line"><span class="keyword">new</span> (test.init())()</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="如何改变this的指向"><a href="#如何改变this的指向" class="headerlink" title="如何改变this的指向"></a>如何改变this的指向</h4><p><strong>1、call()和apply()</strong></p>
<p>​    **call():**第一个参数表示要把this指向的新目标，第二个之后的参数其实相当于传参，参数以逗号隔开（性能较apply略好）。</p>
<p>​    用法：a.call(b,1,2)；表示要把a函数的this指向修改为b的this指向，并运行a函数，传入参数是（1,2）</p>
<p>​    <strong>apply()：</strong>第一个参数同上，第二个参数接收一个数组，里面也是传参，只是以数组的方式，相当于arguments</p>
<p>用法：a.apply(b,[1,2])；表示要把a函数的this指向修改为b的this指向，并运行a函数，传进去的参数是(1,2);</p>
<p>*<strong>注意：即使只有一个参数的话，也要是数组的形式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//call 的传参和apply的传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">arg1,arg2</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name,arg1,arg2);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name : <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  say : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">say.call(obj,<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>);<span class="comment">//tom one two</span></span><br><span class="line">say.spply(obj,[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>]);<span class="comment">//tom one two  效果一样</span></span><br></pre></td></tr></table></figure>

<p><strong>2、bind()</strong></p>
<p>​    作用：bind()方法会创建一个新的函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入bind()方法的第一个参数作为this，传入bind()的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p>​    用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar : <span class="number">1</span>,</span><br><span class="line">    eventBind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">&#x27;.someClass&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="comment">/* Act on the event */</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.bar);      <span class="comment">//1</span></span><br><span class="line">        &#125;.bind(<span class="built_in">this</span>));<span class="comment">//这里的this是eventBind的this，即指向的是foo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</p>
<p><strong>3、new</strong></p>
<p>new的运行原理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Animal(<span class="string">&#x27;cat&#x27;</span>) = &#123;<span class="comment">//类似这样</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;<span class="comment">//先定义一个空对象</span></span><br><span class="line">    obj.__proto__ = Animal.prototype;</span><br><span class="line">    <span class="comment">//把 obj 的__proto__ 指向构造函数 Animal 的原型对象 prototype，</span></span><br><span class="line">    <span class="comment">//此时便建立了 obj 对象的原型链：</span></span><br><span class="line">    <span class="comment">//obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null</span></span><br><span class="line">    <span class="keyword">var</span> result = Animal.call(obj,<span class="string">&quot;cat&quot;</span>);<span class="comment">//改变this指向，从Animal改变到obj上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span>? result : obj; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&quot;追梦子&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn();<span class="comment">//this指向a</span></span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//追梦子</span></span><br></pre></td></tr></table></figure>

<p><strong>4、return</strong></p>
<p>​    在构造函数的时候，使用return进行返回一个Object的时候，当去new一个实例对象的时候，会将this指向改变为return的Object；</p>
<p>​     用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&#x27;追梦子&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;user&quot;</span> : <span class="string">&quot;111&quot;</span></span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//111</span></span><br></pre></td></tr></table></figure>

<h4 id="使用fn-apply-this-arr-和fn-…arr-的区别"><a href="#使用fn-apply-this-arr-和fn-…arr-的区别" class="headerlink" title="使用fn.apply(this,arr)和fn(…arr)的区别"></a>使用fn.apply(this,arr)和fn(…arr)的区别</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">当然，在这道题目中用fn(...arr)也能成功的输出</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目描述</span></span><br><span class="line"><span class="comment">	将数组 arr 中的元素作为调用函数 fn 的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">greeting, name, punctuation</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> greeting + <span class="string">&#x27;, &#x27;</span> + name + (punctuation || <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;Ellie&#x27;</span>, <span class="string">&#x27;!&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argsAsArray</span>(<span class="params">fn, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, arr);</span><br><span class="line">    <span class="comment">//return fn(...arr)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：<a href="https://segmentfault.com/q/1010000004566233">https://segmentfault.com/q/1010000004566233</a></p>
<h4 id="面试真题"><a href="#面试真题" class="headerlink" title="面试真题"></a>面试真题</h4><ol>
<li><p>this的指向（from:字节跳动技术中台一面）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">	x: <span class="number">1</span>,</span><br><span class="line">    print () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.print();  <span class="comment">//1</span></span><br><span class="line"><span class="keyword">let</span> print = a.print()</span><br><span class="line">print();  <span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//问：如何改变this的指向</span></span><br><span class="line"><span class="keyword">let</span> print = a.print.bind(a);</span><br><span class="line">print()</span><br></pre></td></tr></table></figure></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>原型与原型链</title>
    <url>/2021/04/17/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<blockquote>
<p>目录：</p>
<ol>
<li>基本概念</li>
<li>原型链与函数的继承</li>
</ol>
</blockquote>
<span id="more"></span>

<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>显示原型</strong>：prototype</p>
<ul>
<li>每个class/函数都有显示原型prototype，它默认指向一个Object空对象（即称为原型对象）</li>
<li>原型对象中一个属性constructor，它指向函数对象</li>
</ul>
<p><strong>隐式原型</strong>：<strong>proto</strong></p>
<ul>
<li>每个实例都有隐式原型__proto__</li>
<li>实例的__proto__指向对应的class/函数的prototype。</li>
</ul>
<p><strong>相关概念</strong>：</p>
<ol>
<li>Function是所有函数(function)的父亲，所有函数都是它的实例。</li>
<li>Object也是一个函数，所以Object是Function的实例对象。</li>
<li>任何对象的原型链顶端最终都指向Object.prototype,Object.prototype再往上已经没有东西了，所以指向null。</li>
<li>Function比较特殊它的原型指向自己，即Function.<strong>proto</strong> === Function.prototype。</li>
<li>同时，Function是对象，由(3)可知Function必然有一个地方（即Function.prototype.__proto__）指向Object.prototype。</li>
</ol>
<p><strong>先来看一个简化版的原型链图：</strong></p>
<p><img data-src="image-20210303222509043.png" alt="image-20210303222509043"></p>
<p>再来看一个完整版的：</p>
<p><img data-src="%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型与原型链"></p>
<p><font color="red">总之，记住一句话：A是B的实例，则A.__ proto __  === B.prototype；只要A是对象，那么A.prototype.__ proto__ 就指向Object.prototype；prototype中的constructor指向的是自己；</font></p>
<h4 id="原型链与函数的继承"><a href="#原型链与函数的继承" class="headerlink" title="原型链与函数的继承"></a>原型链与函数的继承</h4><ol>
<li><p>ES5中的继承</p>
<p><strong>构造函数继承</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Parent(); <span class="comment">//new一个Parent对象用来对比</span></span><br><span class="line">p.say(); <span class="comment">//输出say</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line">c.age <span class="comment">// 12</span></span><br><span class="line">c.name <span class="comment">//&#x27;parent&#x27;</span></span><br><span class="line">c.say(); <span class="comment">//undifined</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">say是Parent原型链上的方法，Parent对象调用方法时，如果自身不存在就回去原型链上寻找，在原型链上找到了say方法，而Child对象没有继承Parent对象的原型链，所以它在向上寻找时就找不到，输出undifined。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>原型链继承：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c.name); <span class="comment">//输出parent</span></span><br><span class="line">c.say() <span class="comment">//输出say</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原型链继承是直接让Child构造函数的prototype直接指向Parent对象，这样Parent的东西Child对象可以直接从它的原型链上找到。缺点就是：当创建多个实例时，如果不同实例可能互相存在影响。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数与原型链组合继承</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>); </span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c1.arr); <span class="comment">//[1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.arr);<span class="comment">//[1,2,3,4]</span></span><br><span class="line">c1.arr.push(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c1.arr); <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.arr); <span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure></li>
<li><p>ES6中的继承</p>
<p>ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法，才可使用this关键字，否则报错。），然后再用子类的构造函数修改this实现继承。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent2.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> Child2(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c2.name); <span class="comment">//输出parent</span></span><br><span class="line">c2.say(); <span class="comment">//输出say</span></span><br><span class="line"><span class="built_in">console</span>.log(c.constructor); </span><br><span class="line"><span class="comment">//输出function Child(age) &#123;Parent.call(this);this.age = age;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Parent().constructor); </span><br><span class="line"><span class="comment">//输出Parent() &#123;this.name = &#x27;parent&#x27;;this.arr = [1,2,3,4];&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES</tag>
      </tags>
  </entry>
</search>
