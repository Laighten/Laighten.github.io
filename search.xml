<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>V8垃圾回收机制</title>
    <url>/2021/04/17/V8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<p>JavaScript、Java、Python 等语言，<strong>产生的垃圾数据是由垃圾回收器来释放的</strong>，并不需要手动通过代码来释放。</p>
<h4 id="调用栈中的数据如何回收"><a href="#调用栈中的数据如何回收" class="headerlink" title="调用栈中的数据如何回收"></a>调用栈中的数据如何回收</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客邦 &quot;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> c = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">      <span class="keyword">var</span> d = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    showName()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>​    执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如下图所示。与此同时，还有一个<strong>记录当前执行状态的指针（称为 ESP）</strong>，指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p>
<!--more-->

<p>​    接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，<strong>这个下移操作就是销毁 showName 函数执行上下文的过程</strong>。</p>
<p><img data-src="image-20210304112315040.png" alt="image-20210304112315040"></p>
<p>所以说，当一个函数执行结束之后，<strong>JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文</strong>。</p>
<h4 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h4><p><strong>代际假说（The Generational Hypothesis）</strong>：</p>
<ul>
<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>
<li>第二个是不死的对象，会活得更久。</li>
</ul>
<p><strong>分代收集</strong>：</p>
<p>​    在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>
<ul>
<li><strong>副垃圾回收器，主要负责新生代的垃圾回收。</strong></li>
<li><strong>主垃圾回收器，主要负责老生代的垃圾回收。</strong></li>
</ul>
<p><strong>垃圾回收器的工作流程</strong>：</p>
<p>​    不管是主垃圾回收器还是副垃圾回收器都遵循以下这套公共的执行流程：</p>
<p>​    1、<strong>标记空间中活动对象和非活动对象</strong>。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p>
<p>​    2、<strong>回收非活动对象所占据的内存</strong>。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>
<p>​    3、<strong>内存整理</strong>。频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当出现量不连续的内存碎片后，我们再想分配一个较大的连续空间就会出现内存不足的情况。</p>
<h4 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h4><p>​    副垃圾回收器主要负责新生区的垃圾回收，用<strong>Scavenge 算法</strong>来处理。其原理就是：把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，新加入的对象都会存放到对象区域，<strong>当对象区域快被写满时</strong>，就需要执行一次垃圾清理操作。</p>
<p><img data-src="image-20210304114240567.png" alt="image-20210304114240567"></p>
<p>其回收过程如下：</p>
<p>​    1、对对象区域中的垃圾做标记，活动对象和非活动会对象；</p>
<p>​    2、标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些<strong>仍然存活的对象</strong>复制到空闲区域中，<strong>同时它还会把这些对象有序地排列起来，所以这个复制过程</strong>，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>
<p>​    3、完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。</p>
<p><strong>对象晋升策略</strong>：由于为了执行效率，新生区的空间通常会被设置的比较小，所以很容易被存满，为此JavaScript引擎引入了晋升策略，即：<strong>经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</strong></p>
<h4 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h4><p>​    老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p>
<p>​    主垃圾回收器是采用<strong>标记 - 清除（Mark-Sweep）</strong>的算法进行垃圾回收的。</p>
<p>1、<strong>对垃圾数据做标记</strong>。当调用栈中的ESP指向下一个执行上下文后，上一个执行上下文中引用对象在堆中的数据就会被当做垃圾数据被<strong>标为红色</strong>，而当前正被ESP指向的指向上下文中指针指向的栈中数据会被标为<strong>活动数据</strong>。</p>
<p>2、<strong>垃圾数据的清除</strong>。使用<strong>Mark-Sweep</strong>算法清除掉被标记为红色的垃圾数据。</p>
<p><img data-src="image-20210304115832389.png" alt="image-20210304115832389.png"></p>
<p>3、<strong>内存整理</strong>。使用<strong>标记 - 整理（Mark-Compact）</strong>对内存碎片进行整理。</p>
<p><img data-src="image-20210304115856708.png" alt="image-20210304115856708"></p>
<h4 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h4><p>​    于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p>
<p>​    为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记（Incremental Marking）算法</strong>。如下图所示：</p>
<p><img data-src="image-20210304120112556.png" alt="image-20210304120112556"></p>
<p>​    使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器工作原理</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>this的指向问题</title>
    <url>/2021/04/18/this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h4 id="如何判断this的指向"><a href="#如何判断this的指向" class="headerlink" title="如何判断this的指向"></a>如何判断this的指向</h4><p>在使用 this 时，为了避坑，你要谨记以下四点：</p>
<ol>
<li>当函数作为对象的方法调用时，函数中的 this 就是该对象；</li>
<li>当函数被正常调用时，<strong>在严格模式下，this 值是 undefined</strong>，非严格模式下 this 指向的是全局对象 window；</li>
<li>嵌套函数中的 this 不会继承外层函数的 this 值。</li>
<li>我们还提了一下箭头函数，因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。</li>
<li>当this遇到return时，如果返回值是一个对象，那么this指向的是构造函数的实例但是并没有被返回，如果返回值不是一个对象，那么this还是指向构造函数创建的实例。</li>
</ol>
<p>下面从几道例题中去验证：</p>
<ol>
<li><p>直接使用的函数this指向window</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> user= <span class="string">&quot;呵呵&quot;</span>，</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.user),</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>),</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// window</span></span><br></pre></td></tr></table></figure></li>
<li><p>嵌套函数中的 this 不会继承外层函数的 this 值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> user = <span class="string">&quot;呵呵&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="built_in">this</span>.user);</span><br><span class="line">    &#125;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">o();</span><br></pre></td></tr></table></figure></li>
<li><p>当函数作为对象的方法调用时，函数中的 this 就是该对象，且永远指向最后调用它的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目一</span></span><br><span class="line"><span class="keyword">var</span> o=&#123;</span><br><span class="line">	a:<span class="number">10</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">    	a=<span class="number">12</span>,</span><br><span class="line">        fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.b.fn() <span class="comment">//12</span></span><br><span class="line"><span class="comment">//题目二</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	a:<span class="number">10</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">    	a:<span class="number">12</span></span><br><span class="line">        fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    		<span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">        	<span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j = o.b.fn;</span><br><span class="line">j(); <span class="comment">// undefined //window</span></span><br></pre></td></tr></table></figure></li>
<li><p>构造函数中的this指向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&#x27;呵呵&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Fn()</span><br><span class="line"><span class="built_in">console</span>.log(p.user) <span class="comment">// 呵呵</span></span><br></pre></td></tr></table></figure></li>
<li><p>当this遇到return时</p>
<p>如果返回值是一个对象，那么this指向的是构造函数的实例但是并没有被返回，如果返回值不是一个对象，那么this还是指向构造函数创建的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//undefined</span></span><br><span class="line">==============================</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//undefined</span></span><br><span class="line">==============================</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//呵呵</span></span><br><span class="line">==============================</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//呵呵</span></span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数中的this指向</p>
<p>箭头函数是ES6中的特性，箭头函数没有执行上下文本所以没有this，它会沿用/捕获外部环境的this。也就是说，箭头函数内部与外部的this是保持一致的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 题目一 */</span></span><br><span class="line"><span class="built_in">this</span>.a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">	a:<span class="number">40</span>,</span><br><span class="line">    init:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	<span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">        go.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> go</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = test.init()</span><br><span class="line">p()</span><br><span class="line"><span class="keyword">new</span> (test.init())()</span><br><span class="line"><span class="comment">/* 题目二 */</span></span><br><span class="line"><span class="built_in">this</span>.a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">	a:<span class="number">40</span>,</span><br><span class="line">    init:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	<span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">        go.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> go</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = test.init()</span><br><span class="line">p()</span><br><span class="line"><span class="keyword">new</span> (test.init())()</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="如何改变this的指向"><a href="#如何改变this的指向" class="headerlink" title="如何改变this的指向"></a>如何改变this的指向</h4><p><strong>1、call()和apply()</strong></p>
<p>​    **call():**第一个参数表示要把this指向的新目标，第二个之后的参数其实相当于传参，参数以逗号隔开（性能较apply略好）。</p>
<p>​    用法：a.call(b,1,2)；表示要把a函数的this指向修改为b的this指向，并运行a函数，传入参数是（1,2）</p>
<p>​    <strong>apply()：</strong>第一个参数同上，第二个参数接收一个数组，里面也是传参，只是以数组的方式，相当于arguments</p>
<p>用法：a.apply(b,[1,2])；表示要把a函数的this指向修改为b的this指向，并运行a函数，传进去的参数是(1,2);</p>
<p>*<strong>注意：即使只有一个参数的话，也要是数组的形式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//call 的传参和apply的传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">arg1,arg2</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name,arg1,arg2);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name : <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  say : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">say.call(obj,<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>);<span class="comment">//tom one two</span></span><br><span class="line">say.spply(obj,[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>]);<span class="comment">//tom one two  效果一样</span></span><br></pre></td></tr></table></figure>

<p><strong>2、bind()</strong></p>
<p>​    作用：bind()方法会创建一个新的函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入bind()方法的第一个参数作为this，传入bind()的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p>​    用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar : <span class="number">1</span>,</span><br><span class="line">    eventBind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">&#x27;.someClass&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="comment">/* Act on the event */</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.bar);      <span class="comment">//1</span></span><br><span class="line">        &#125;.bind(<span class="built_in">this</span>));<span class="comment">//这里的this是eventBind的this，即指向的是foo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</p>
<p><strong>3、new</strong></p>
<p>new的运行原理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Animal(<span class="string">&#x27;cat&#x27;</span>) = &#123;<span class="comment">//类似这样</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;<span class="comment">//先定义一个空对象</span></span><br><span class="line">    obj.__proto__ = Animal.prototype;</span><br><span class="line">    <span class="comment">//把 obj 的__proto__ 指向构造函数 Animal 的原型对象 prototype，</span></span><br><span class="line">    <span class="comment">//此时便建立了 obj 对象的原型链：</span></span><br><span class="line">    <span class="comment">//obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null</span></span><br><span class="line">    <span class="keyword">var</span> result = Animal.call(obj,<span class="string">&quot;cat&quot;</span>);<span class="comment">//改变this指向，从Animal改变到obj上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span>? result : obj; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&quot;追梦子&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn();<span class="comment">//this指向a</span></span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//追梦子</span></span><br></pre></td></tr></table></figure>

<p><strong>4、return</strong></p>
<p>​    在构造函数的时候，使用return进行返回一个Object的时候，当去new一个实例对象的时候，会将this指向改变为return的Object；</p>
<p>​     用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&#x27;追梦子&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;user&quot;</span> : <span class="string">&quot;111&quot;</span></span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//111</span></span><br></pre></td></tr></table></figure>

<h4 id="使用fn-apply-this-arr-和fn-…arr-的区别"><a href="#使用fn-apply-this-arr-和fn-…arr-的区别" class="headerlink" title="使用fn.apply(this,arr)和fn(…arr)的区别"></a>使用fn.apply(this,arr)和fn(…arr)的区别</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">当然，在这道题目中用fn(...arr)也能成功的输出</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目描述</span></span><br><span class="line"><span class="comment">	将数组 arr 中的元素作为调用函数 fn 的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">greeting, name, punctuation</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> greeting + <span class="string">&#x27;, &#x27;</span> + name + (punctuation || <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;Ellie&#x27;</span>, <span class="string">&#x27;!&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argsAsArray</span>(<span class="params">fn, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, arr);</span><br><span class="line">    <span class="comment">//return fn(...arr)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：<a href="https://segmentfault.com/q/1010000004566233">https://segmentfault.com/q/1010000004566233</a></p>
<h4 id="面试真题"><a href="#面试真题" class="headerlink" title="面试真题"></a>面试真题</h4><ol>
<li><p>this的指向（from:字节跳动技术中台一面）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">	x: <span class="number">1</span>,</span><br><span class="line">    print () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.print();  <span class="comment">//1</span></span><br><span class="line"><span class="keyword">let</span> print = a.print()</span><br><span class="line">print();  <span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//问：如何改变this的指向</span></span><br><span class="line"><span class="keyword">let</span> print = a.print.bind(a);</span><br><span class="line">print()</span><br></pre></td></tr></table></figure></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>原型与原型链</title>
    <url>/2021/04/17/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>显示原型</strong>：prototype</p>
<ul>
<li>每个class/函数都有显示原型prototype，它默认指向一个Object空对象（即称为原型对象）</li>
<li>原型对象中一个属性constructor，它指向函数对象</li>
</ul>
<p><strong>隐式原型</strong>：<strong>proto</strong></p>
<ul>
<li>每个实例都有隐式原型__proto__</li>
<li>实例的__proto__指向对应的class/函数的prototype。</li>
</ul>
<p><strong>相关概念</strong>：</p>
<ol>
<li>Function是所有函数(function)的父亲，所有函数都是它的实例。</li>
<li>Object也是一个函数，所以Object是Function的实例对象。</li>
<li>任何对象的原型链顶端最终都指向Object.prototype,Object.prototype再往上已经没有东西了，所以指向null。</li>
<li>Function比较特殊它的原型指向自己，即Function.<strong>proto</strong> === Function.prototype。</li>
<li>同时，Function是对象，由(3)可知Function必然有一个地方（即Function.prototype.__proto__）指向Object.prototype。</li>
</ol>
<p><strong>先来看一个简化版的原型链图：</strong></p>
<p><img data-src="image-20210303222509043.png" alt="image-20210303222509043"></p>
<p>再来看一个完整版的：</p>
<p><img data-src="%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型与原型链"></p>
<p><font color="red">总之，记住一句话：A是B的实例，则A.__ proto __  === B.prototype；只要A是对象，那么A.prototype.__ proto__ 就指向Object.prototype；prototype中的constructor指向的是自己；</font></p>
<h4 id="原型链与函数的继承"><a href="#原型链与函数的继承" class="headerlink" title="原型链与函数的继承"></a>原型链与函数的继承</h4><ol>
<li><p>ES5中的继承</p>
<p><strong>构造函数继承</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Parent(); <span class="comment">//new一个Parent对象用来对比</span></span><br><span class="line">p.say(); <span class="comment">//输出say</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line">c.age <span class="comment">// 12</span></span><br><span class="line">c.name <span class="comment">//&#x27;parent&#x27;</span></span><br><span class="line">c.say(); <span class="comment">//undifined</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">say是Parent原型链上的方法，Parent对象调用方法时，如果自身不存在就回去原型链上寻找，在原型链上找到了say方法，而Child对象没有继承Parent对象的原型链，所以它在向上寻找时就找不到，输出undifined。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>原型链继承：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c.name); <span class="comment">//输出parent</span></span><br><span class="line">c.say() <span class="comment">//输出say</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原型链继承是直接让Child构造函数的prototype直接指向Parent对象，这样Parent的东西Child对象可以直接从它的原型链上找到。缺点就是：当创建多个实例时，如果不同实例可能互相存在影响。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数与原型链组合继承</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>); </span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c1.arr); <span class="comment">//[1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.arr);<span class="comment">//[1,2,3,4]</span></span><br><span class="line">c1.arr.push(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c1.arr); <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.arr); <span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure></li>
<li><p>ES6中的继承</p>
<p>ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法，才可使用this关键字，否则报错。），然后再用子类的构造函数修改this实现继承。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent2.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> Child2(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c2.name); <span class="comment">//输出parent</span></span><br><span class="line">c2.say(); <span class="comment">//输出say</span></span><br><span class="line"><span class="built_in">console</span>.log(c.constructor); </span><br><span class="line"><span class="comment">//输出function Child(age) &#123;Parent.call(this);this.age = age;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Parent().constructor); </span><br><span class="line"><span class="comment">//输出Parent() &#123;this.name = &#x27;parent&#x27;;this.arr = [1,2,3,4];&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES</tag>
      </tags>
  </entry>
</search>
