<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lai Teng&#39;s Blog</title>
  
  <subtitle>数据可视化 &amp; 前端 &amp; 迁移学习</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-28T15:50:07.547Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>laiteng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web端pdf编辑工具</title>
    <link href="http://example.com/2024/02/16/web_pdf_editor/"/>
    <id>http://example.com/2024/02/16/web_pdf_editor/</id>
    <published>2024-02-16T03:39:52.000Z</published>
    <updated>2024-05-28T15:50:07.547Z</updated>
    
    <content type="html"><![CDATA[<p>对于web端pdf编辑能力，本文提供了一种相对完整且轻量的实现方式，如果你也有类似诉求，希望能对你有所帮助～。下面将从业务场景、技术实现角度对“pdf编辑工具”进行介绍。</p><span id="more"></span><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="业务介绍"><a href="#业务介绍" class="headerlink" title="业务介绍"></a>业务介绍</h4><p>版权是内容行业商业化的基础，也是网易云音乐的核心资产。合同作为版权资产的重要组成部分，需要具有高效且高质量的管理方式，云音乐版权后台把大量原本需在线下完成的纸质合同的生成与审核等过程移至线上进行。在合同生成——审核完成的过程中，会有不同身份成员需要查看合同信息以及合同原件。但由于部分成员直接查看合同原件存在一定风险，特别是对合同金额等敏感信息不方便直接露出。因此需要先对pdf格式的合同原件进行编辑处理，即发起人在上传合同原件后，需要对合同原件中的一些敏感信息进行涂改操作，以提供给其他审核人员查看。</p><p><img src="/2024/02/16/web_pdf_editor/image-20240301182106366.png" alt="合同审核流程"></p><h4 id="功能调研"><a href="#功能调研" class="headerlink" title="功能调研"></a>功能调研</h4><p>通过对已有的pdf编辑组件库或方案的调研，发现两款比较主流可对pdf进行编辑的库：<a href="https://www.npmjs.com/package/jspdf">jsPDF</a>和<a href="https://pdf-lib.js.org/">pdf-lib</a>（其它冷门库暂不考虑）。</p><p><img src="/2024/02/16/web_pdf_editor/image-20240225162010639.png" alt="pdf-lib"></p><p>其中，<a href="https://pdf-lib.js.org/">pdf-lib</a>这个组件对pdf的基本编辑能力已经十分完善，可以轻松实现对pdf的预览（包括放大/缩小、翻页、旋转等）、加水印、图片嵌入、涂改（<a href="https://codesandbox.io/p/sandbox/small-water-mhrhjn?file=/src/Components/ModifyPage.js:49,35-49,46">在线体验</a>）等功能。</p><p>其涂改功能的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PDFDocument, rgb &#125; <span class="keyword">from</span> <span class="string">&#x27;pdf-lib&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">drawSvgPaths</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> svgPath =</span><br><span class="line">    <span class="string">&#x27;M 0,20 L 100,160 Q 130,200 150,120 C 190,-40 200,200 300,150 L 400,90&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> pdfDoc = <span class="keyword">await</span> PDFDocument.create()</span><br><span class="line">  <span class="keyword">const</span> page = pdfDoc.addPage()</span><br><span class="line">  page.moveTo(<span class="number">100</span>, page.getHeight() - <span class="number">5</span>)</span><br><span class="line">  page.moveDown(<span class="number">25</span>)</span><br><span class="line">  page.drawSvgPath(svgPath)</span><br><span class="line">  page.moveDown(<span class="number">200</span>)</span><br><span class="line">  page.drawSvgPath(svgPath, &#123; <span class="attr">borderColor</span>: rgb(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="attr">borderWidth</span>: <span class="number">5</span> &#125;)</span><br><span class="line">  page.moveDown(<span class="number">200</span>)</span><br><span class="line">  page.drawSvgPath(svgPath, &#123; <span class="attr">color</span>: rgb(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) &#125;)</span><br><span class="line">  page.moveDown(<span class="number">200</span>)</span><br><span class="line">  page.drawSvgPath(svgPath, &#123; <span class="attr">scale</span>: <span class="number">0.5</span> &#125;)</span><br><span class="line">  <span class="keyword">const</span> pdfBytes = <span class="keyword">await</span> pdfDoc.save()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用pdf-lib的drawSvgPath方法，将指定颜色的线条覆盖到pdf的指定位置，如果说只是实现一个基础的涂改功能那么这个方法已经够用了，但对于定制化的功能来说还不够灵活。原因是使用drawSvgPath进行涂改，需要先将每条画线的坐标位置记录下来，擦除的时只能一条一条的回撤，不能像橡皮擦一样的任意擦除（jsPDF同样无法实现）。</p><p>由于策划希望实现一个像画板一样，可以自由灵活的对涂改过的地方进行擦除的工具，且后续会陆续按需增加定制化的新功能。市面上现有支持pdf编辑的工具（如福昕PDF编辑器、Adobe Acrobat DC、PDF-XChange Editor等）具有诸多问题：</p><ul><li>收费；</li><li>样式难以统一（如字体、表单长度、边框粗细等）；</li><li>pdf可能会被工具获取，存在内容泄漏风险；</li><li>无法满足特定业务的定制化需求；</li><li>…..</li></ul><p>因此，我们需要开发一款”有画板功能”且可灵活拓展的web端pdf编辑工具。</p><h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><p>通过前期调研发现，web端实现画板通常是使用canvas画布来实现，其自身具有很好的用于绘制的api调用方法。加上对已有web端pdf工具库的了解，考虑先将pdf处理成canvas画布，然后再对画布做一系列的编辑操作。</p><h4 id="技术可行性拆解"><a href="#技术可行性拆解" class="headerlink" title="技术可行性拆解"></a>技术可行性拆解</h4><ol><li><p>在线预览与canvas转换：</p><p>可通过pdf.js将pdf转换为图片/canvas格式，并且可调用其自带的功能实现灵活的预览。</p></li><li><p>pdf的编辑与交互：</p><p>将pdf转换为图片渲染到canvas画布后，就可以利用canvas提供的基础编辑方法实现可视化编辑能力。</p></li><li><p>合并canvas并生成新的pdf文件：</p><p>利用pdf-lib的PDFDocument方法，将绘制好的canvas画布转换为pdf文件。</p></li></ol><h4 id="架构概览"><a href="#架构概览" class="headerlink" title="架构概览"></a>架构概览</h4><p><img src="/2024/02/16/web_pdf_editor/image-20240303104001472.png" alt="架构概览"></p><h3 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h3><h4 id="pdf加载与转换"><a href="#pdf加载与转换" class="headerlink" title="pdf加载与转换"></a>pdf加载与转换</h4><p>使用pdf.js库中的pdf.worker.js方法将pdf文件处理成一个base64格式的图片数组，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> pdf <span class="keyword">from</span> <span class="string">&#x27;pdfjs-dist&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> PdfWorker <span class="keyword">from</span> <span class="string">&#x27;pdfjs-dist/build/pdf.worker.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.pdfjsWorker = PdfWorker;</span><br><span class="line">pdf.GlobalWorkerOptions.workerSrc = PdfWorker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> usePDFData = <span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> previewUrls = useRef([]);</span><br><span class="line">    <span class="keyword">const</span> urls = useRef([]);</span><br><span class="line">    <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        urls.current = [];</span><br><span class="line">        setLoading(<span class="literal">true</span>);</span><br><span class="line">        (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> pdfDocument = <span class="keyword">await</span> pdf.getDocument(options.src).promise;</span><br><span class="line">            <span class="keyword">const</span> task = <span class="keyword">new</span> <span class="built_in">Array</span>(pdfDocument.numPages).fill(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">await</span> <span class="built_in">Promise</span>.all(task.map(<span class="keyword">async</span> (_, i) =&gt; &#123;</span><br><span class="line">                <span class="keyword">const</span> page = <span class="keyword">await</span> pdfDocument.getPage(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">const</span> viewport = page.getViewport(&#123; <span class="attr">scale</span>: options.scale || <span class="number">2</span> &#125;);</span><br><span class="line">                <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                canvas.width = viewport.width;</span><br><span class="line">                canvas.height = viewport.height;</span><br><span class="line">                <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">                <span class="keyword">const</span> renderTask = page.render(&#123;</span><br><span class="line">                    canvasContext: ctx,</span><br><span class="line">                    viewport,</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">await</span> renderTask.promise;</span><br><span class="line">                urls.current[i] = canvas.toDataURL(<span class="string">&#x27;image/jpeg&#x27;</span>, <span class="number">1.0</span>);</span><br><span class="line">                previewUrls.current[i] = canvas.toDataURL(<span class="string">&#x27;image/jpeg&#x27;</span>, <span class="number">1.0</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">            setLoading(<span class="literal">false</span>);</span><br><span class="line">        &#125;)();</span><br><span class="line">    &#125;, [options.src]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        loading,</span><br><span class="line">        urls: urls.current,</span><br><span class="line">        previewUrls: previewUrls.current,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，使用上述方法引入pdfjs-dist库的时候可能会出现由于版本原因导致的webpack报错或pdf文字展示不全的问题。此时，可使用CDN静态链接的方式来引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.src = src;</span><br><span class="line">        script.onload = resolve;</span><br><span class="line">        script.onerror = reject;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> pdfJsSrc = <span class="string">&#x27;https://d2.music.126.net/dmusic/obj/w5zCg8OAw6HDjzjDgMK_/32306762218/0edf/8c16/2c06/4555824a5322d689b942fae7f969fe1d.js&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> pdfWorkerSrc = <span class="string">&#x27;https://d1.music.126.net/dmusic/obj/w5zCg8OAw6HDjzjDgMK_/32306765016/e6dd/7e38/f0e7/a1419bdedd44e403179bee0c8c1132df.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">window</span>?.pdfjsLib) &#123;</span><br><span class="line">            loadScript(pdfJsSrc)</span><br><span class="line">                .then(<span class="function">() =&gt;</span> loadScript(pdfWorkerSrc))</span><br><span class="line">                .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    producePic(pdfWorkerSrc);</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            producePic(pdfWorkerSrc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [options.src]);</span><br></pre></td></tr></table></figure><h4 id="canvas绘画"><a href="#canvas绘画" class="headerlink" title="canvas绘画"></a>canvas绘画</h4><p>将pdf的每一页处理成图片以后，就可以直接渲染到canvas画布上进行后续的一系列操作了。</p><ol><li><p>绘图与擦除功能构建</p><p>采用两层相同大小的canvas画布重叠的方式。上层画布主要用于绘制新内容，下层画布用于展示原始pdf内容，当需要一次还原某页内容时，只需要将上层canvas内容清除即可。选择操作方式（绘图/擦除）后，按下鼠标开始绘制/擦除，抬起鼠标停止绘制/擦除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useState, useRef, useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> OPERATE_ENUM = &#123;</span><br><span class="line">    MOSAIC: <span class="number">1</span>,  <span class="comment">// 绘图</span></span><br><span class="line">    ERASER: <span class="number">2</span>,  <span class="comment">// 擦除</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> DrawingBoard = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/*鼠标按压事件*/</span></span><br><span class="line">  <span class="keyword">const</span> onMouseDown = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        <span class="comment">/* 鼠标按下事件，记录鼠标位置，并绘制，解锁lock，打开mousemove事件 */</span></span><br><span class="line">        <span class="keyword">if</span> (status === OPERATE_ENUM.ERASER) &#123;</span><br><span class="line">            <span class="comment">// 橡皮模式</span></span><br><span class="line">          <span class="comment">// 设置擦除初始数据</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === OPERATE_ENUM.MOSAIC) &#123;</span><br><span class="line">            <span class="comment">// 绘画模式</span></span><br><span class="line">            <span class="comment">// 设置绘画初始数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="comment">/*鼠标移动事件监听*/</span></span><br><span class="line">  <span class="keyword">const</span> onMouseMove = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> canvas = canvasRef.current;</span><br><span class="line">        <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> _x = (e.clientX - canvas.offsetLeft - containerLeftRef.current) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> _y = (e.clientY - canvas.offsetTop - containerTopRef.current) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (status === OPERATE_ENUM.ERASER &amp;&amp; startEraser.current) &#123;</span><br><span class="line">            <span class="comment">/*橡皮擦擦除函数*/</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === OPERATE_ENUM.MOSAIC &amp;&amp; startDraw.current) &#123;</span><br><span class="line">            <span class="comment">/*绘制线条函数*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*鼠标抬起事件监听*/</span></span><br><span class="line">  <span class="keyword">const</span> onMouseUp = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/* 重置数据 */</span></span><br><span class="line">        <span class="comment">/* 保存当前绘图 */</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">    &lt;canvas</span><br><span class="line">        ref=&#123;canvasImgRef&#125;</span><br><span class="line">        id=<span class="string">&quot;canvasImg&quot;</span>&gt;</span><br><span class="line">        您的浏览器不支持 canvas 标签</span><br><span class="line">    &lt;/canvas&gt;</span><br><span class="line">    &lt;canvas</span><br><span class="line">        ref=&#123;canvasRef&#125;</span><br><span class="line">        onMouseDown=&#123;onMouseDown&#125;</span><br><span class="line">        onMouseMove=&#123;onMouseMove&#125;</span><br><span class="line">        onMouseUp=&#123;onMouseUp&#125;</span><br><span class="line">        id=<span class="string">&quot;canvas&quot;</span>&gt;</span><br><span class="line">        您的浏览器不支持 canvas 标签</span><br><span class="line">    &lt;/canvas&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> DrawingBoard</span><br></pre></td></tr></table></figure></li><li><p>翻页时加载之前绘制的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在返回页面时，使用之前保存的数据重新渲染 canvas</span></span><br><span class="line">    <span class="keyword">if</span> (canvasList[currentPage]) &#123;</span><br><span class="line">      <span class="keyword">const</span> canvas = canvasRef.current;</span><br><span class="line">      <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">      <span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">      img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, widthE, heightE);</span><br><span class="line">      &#125;;</span><br><span class="line">      img.src = canvasList[currentPage];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [currentPage, canvasList, widthE, heightE]);</span><br></pre></td></tr></table></figure></li><li><p>当放大时，容器会出现滚动条，此时需要监听滚动位置，以确定绘制/擦除时的下笔位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听滚动条，确定画笔的位置</span></span><br><span class="line"><span class="keyword">const</span> handleScroll = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.target) &#123;</span><br><span class="line">        containerLeft = e.target.offsetLeft - e.target.scrollLeft;</span><br><span class="line">        containerTop = e.target.offsetTop - e.target.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> drawPaint = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;drawPaint&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (canvas) &#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">if</span> (drawPaint) &#123;</span><br><span class="line">            drawPaint.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, handleScroll);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (drawPaint) &#123;</span><br><span class="line">            drawPaint.removeEventListener(<span class="string">&#x27;scroll&#x27;</span>, handleScroll);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [status, canvasList]);</span><br></pre></td></tr></table></figure></li></ol><h4 id="保存下载"><a href="#保存下载" class="headerlink" title="保存下载"></a>保存下载</h4><ol><li><p>合并图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载图片</span></span><br><span class="line">    <span class="keyword">const</span> loadImage = <span class="function">(<span class="params">src</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">            img.onload = <span class="function">() =&gt;</span> resolve(img);</span><br><span class="line">            img.onerror = reject;</span><br><span class="line">            img.src = src;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两张图片合并</span></span><br><span class="line"><span class="keyword">const</span> mergeImage = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!urls.length) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">await</span> urls?.map(<span class="function">(<span class="params">image1,index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> image2 = canvasList[index];</span><br><span class="line">        <span class="keyword">if</span> (image2) &#123;</span><br><span class="line">            <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">            <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">            canvas.width = <span class="number">550</span> * <span class="number">4</span></span><br><span class="line">            canvas.height = <span class="number">779</span> * <span class="number">4</span></span><br><span class="line">            <span class="comment">// 确保两张图片都加载完成后绘制</span></span><br><span class="line">            <span class="built_in">Promise</span>.all([</span><br><span class="line">                loadImage(image1),</span><br><span class="line">                loadImage(image2)</span><br><span class="line">            ])</span><br><span class="line">            .then(<span class="function">(<span class="params">[loadedImg1, loadedImg2]</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="comment">// 绘制第一张图片</span></span><br><span class="line">              ctx.drawImage(loadedImg1, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height); </span><br><span class="line">              ctx.globalAlpha = <span class="number">1.0</span>; <span class="comment">// 设置合并透明度</span></span><br><span class="line">              <span class="comment">// 绘制第二张图片</span></span><br><span class="line">              ctx.drawImage(loadedImg2, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height); </span><br><span class="line">              <span class="comment">// 获取合并后的图片的数据 URL</span></span><br><span class="line">              <span class="keyword">const</span> mergedImage = canvas.toDataURL(<span class="string">&#x27;image/jpeg&#x27;</span>);</span><br><span class="line">              result[index] = mergedImage;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[index] = image1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免pdf在转换和生成的过程中失真，本文通过手动设置canvas大小的方法解决。由于一般的pdf文件都是A4纸大小，转换为px为单位就是：2480 px * 3508 px。为了方便展示在初始化预览时将canvas的大小设置为：2480/4 *  3508/4 的宽高，在合并时将宽高*4还原为之前的大小，这样做可以解决由于转化过程中引起的画面失真问题。</p></li><li><p>使用pdf-lib将合并好的图片转化为pdf，以方便下载或者上传</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PDFDocument &#125; <span class="keyword">from</span> <span class="string">&#x27;pdf-lib&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> image <span class="keyword">of</span> images) &#123;</span><br><span class="line">    <span class="keyword">const</span> imageBytes = <span class="keyword">await</span> fetch(image).then(<span class="function"><span class="params">res</span> =&gt;</span> res.arrayBuffer());</span><br><span class="line">    <span class="keyword">const</span> img = <span class="keyword">await</span> pdfDoc.embedJpg(imageBytes);</span><br><span class="line">    <span class="keyword">const</span> page = pdfDoc.addPage();</span><br><span class="line">    <span class="keyword">const</span> &#123; width, height &#125; = page.getSize();</span><br><span class="line">    page.drawImage(img, &#123;</span><br><span class="line">        x: <span class="number">0</span>,</span><br><span class="line">        y: <span class="number">0</span>,</span><br><span class="line">        width: width,</span><br><span class="line">        height: height,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pdfBytes = <span class="keyword">await</span> pdfDoc.save();</span><br><span class="line"><span class="comment">// 下载 PDF 文件</span></span><br><span class="line"><span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([pdfBytes], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/pdf&#x27;</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">link.href = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">link.download = <span class="string">&#x27;combined_images.pdf&#x27;</span>;</span><br><span class="line">link.click();</span><br><span class="line">setUploading(<span class="literal">false</span>);</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li></ol><h3 id="功能展示"><a href="#功能展示" class="headerlink" title="功能展示"></a>功能展示</h3><ol><li><p>预览</p><p><img src="/2024/02/16/web_pdf_editor/image-20240303105330033.png" alt="预览"></p></li><li><p>涂改</p><p><img src="/2024/02/16/web_pdf_editor/image-20240303105538645.png" alt="涂改"></p></li><li><p>橡皮擦擦除</p><p><img src="/2024/02/16/web_pdf_editor/image-20240303105719922.png" alt="橡皮擦擦除"></p></li><li><p>翻页/旋转/放大/缩小</p><p><img src="/2024/02/16/web_pdf_editor/image-20240303110213300.png" alt="翻页/旋转/放大/缩小"></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了在web端实现对pdf的编辑能力，本文的主要实现方式是：</p><ol><li>使用pdf.js将pdf文件转换为canvas格式，以便预览和后续放大/缩小、翻页、涂鸦等；</li><li>构建canvas画板能力，通过调用canvas本身api方法实现所需编辑功能；</li><li>完成绘制后，先将canvas画布转换为图片，再调用pdf-lib的PDFDocument方法将图片转换为pdf文件。</li></ol><p>仓库地址：<a href="https://github.com/Laighten/pdf-paint">https://github.com/Laighten/pdf-paint</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于web端pdf编辑能力，本文提供了一种相对完整且轻量的实现方式，如果你也有类似诉求，希望能对你有所帮助～。下面将从业务场景、技术实现角度对“pdf编辑工具”进行介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>可视化相关会议整理</title>
    <link href="http://example.com/2023/08/25/visual_meeting_collection/"/>
    <id>http://example.com/2023/08/25/visual_meeting_collection/</id>
    <published>2023-08-25T05:52:38.000Z</published>
    <updated>2024-05-28T15:50:14.066Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://link.zhihu.com/?target=https://divis.cn/archives/2590">https://divis.cn/archives/2590</a></p><span id="more"></span><h3 id="会议介绍（按deadline时间排序）"><a href="#会议介绍（按deadline时间排序）" class="headerlink" title="会议介绍（按deadline时间排序）"></a>会议介绍（按deadline时间排序）</h3><p><strong>1.EuroVis</strong></p><ul><li>评价：欧洲地区可视化会议</li><li>CCF等级：B</li><li>deadline:每年一月底左右，例如2023年1月28日</li><li>相关刊物：</li><li>网站：<a href="https://conferences.eg.org/eurovis2023/">https://conferences.eg.org/eurovis2023/</a></li><li>年/投稿量/录用量/录用比：2021/173/44/25％</li></ul><p><strong>2.IEEE VIS</strong></p><ul><li>评价：可视化顶会。分为三个板块InfoVIS, SciVis, VAST</li><li>CCF等级：A</li><li>deadline: 每年的4月1日</li><li>相关刊物：IEEE Transactions on Visualization and Computer Graphics（TVCG）</li><li>网站：<a href="https://ieeevis.org/">https://ieeevis.org</a></li><li>年/投稿量/录用量/录用比：<ul><li>InfoVis/2018/185/47/25.13%</li><li>SciVis/2018/128/32/25%</li><li>VAST/2018/164/48/29.3%</li><li>合计/2018/477/127/26.6%</li><li>目前总体录用比在25%左右</li></ul></li></ul><p><strong>3.UIST</strong></p><ul><li>评价：用户界面软件和技术研讨会，也收可视化论文， 因为时间和IEEE VIS撞车并且CCF等级不高，所以投的人不是很多</li><li>CCF等级：B</li><li>deadline:每年的4月初，例如2023年4月5日</li><li>相关刊物：</li><li>网站：<a href="https://uist.acm.org/2023/">https://uist.acm.org/2023/</a></li><li>年/投稿量/录用量/录用比：<ul><li>2019/381/93/24%</li></ul></li></ul><p><strong>4.CCF CAD/Graphics2023国际会议</strong></p><ul><li>评价：中国计算机辅助设计与计算机图形学领域的会议，包含可视化板块。<strong>只接受中文投稿。</strong></li><li>CCF等级：X</li><li>deadline:每年5月初，例如2023年5月10日</li><li>相关刊物：论文会被推荐到如下期刊《中国科学:信息科学》《计算机学报》《计算机辅助设计与图形学学报》《上海交通大学学报》（EI源刊）《图学学报》（中文核心期刊）《浙江大学学报（理学版）》（中文核心期刊）等</li><li>网站：<a href="https://dmcv.sjtu.edu.cn/cadgraphics2023">https://dmcv.sjtu.edu.cn/cadgraphics2023</a></li><li>年投稿量/录用量：</li></ul><p><strong>5.chinaVIS</strong></p><ul><li>评价：国内的可视化会议。同时接受中英文投稿。</li><li>CCF等级：</li><li>deadline: 每年5月中旬，例如<strong>2023年5月15日</strong></li><li>相关刊物：英文稿件:《Journal of Visualization》或《Visual Informatics》期刊，中文稿件:《计算机辅助设计与图形学学报》等期刊</li><li>网站：<a href="https://chinavis.org/2022/challenge.html">https://chinavis.org/2022/</a></li><li>年/投稿量/录用量/录用比：<ul><li>2022/142/37/26％</li><li>总之目前录用比低于30%</li></ul></li></ul><p><strong>6.VizSec</strong></p><ul><li>评价：网络安全可视化学术研讨会。2012年以后就与IEEE VIS一起举行，规模很小。<a href="https://vizsec.dbvis.de/">https://vizsec.dbvis.de/</a></li><li>CCF等级：C</li><li>deadline:2023年6月30日</li><li>相关刊物：计算机图形学（TVCG）期刊特刊</li><li>网站：<a href="https://vizsec.org/">https://vizsec.org/ </a></li><li>年/投稿量/录用量/录用比：<ul><li>2022/13/5/38%</li><li>2021/21/10/47%</li><li>2020/12/6/50%</li></ul></li></ul><p><strong>7.计算机图形学及虚拟现实领域学术会议CGI</strong></p><ul><li>评价：图形学领域的国际学术会议，包含可视化及虚拟现实板块</li><li>CCF等级：X</li><li>deadline:竞赛/workshop提案：2月25日；第一轮论文投稿：3月10日；第二轮论文投稿：6月12日</li><li>相关刊物：第一轮投稿：CCF推荐的SCI期刊The Visual Computer上<ul><li>第二轮投稿:</li><li>(1) CCF推荐的SCI期刊CAVW</li><li>(2）EI索引期刊Virtual Reality and Intelligent Hardware</li><li>(3）其余录取论文全部发表在LNCS(Springer，EI检索)</li></ul></li><li>网站：<a href="http://www.cgs-network.org/cgi23/">http://www.cgs-network.org/cgi23/</a></li><li>年/投稿量/录用量/录用比：2008/220/79/35.9％</li></ul><p><strong>8.CHI</strong></p><ul><li>评价：人机交互顶会，带可视化子版块</li><li>CCF等级：A</li><li>deadline:每年的9月15日</li><li>相关刊物：ACM期刊</li><li>网站：<a href="https://dl.acm.org/conference/chi">https://dl.acm.org/conference/chi</a></li><li>年/投稿量/录用量/录用比：<ul><li>2021/2845/747/26.3%</li><li>2020/3126/760/24.31%</li></ul></li></ul><p><strong>9.PacificVis</strong></p><ul><li>评价：环太平洋地区可视化学术会议（主要是东亚、大洋洲、美洲）</li><li>CCF等级：C</li><li>deadline:这个会每年论文是10月10日左右截止，但开会日期通常是次年的4月中下旬（例如2023年4月18-21日）</li><li>相关刊物：入选论文将直接发表在 IEEE Transactions on Visualization and Computer Graphics (TVCG)上 。</li><li>网站：<a href="https://pvis2023.github.io/pvis2023/">https://pvis2023.github.io/pvis2023/</a></li><li>年/投稿量/录用量/录用比：<ul><li>2021/173/44/25％</li></ul></li></ul><h3 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h3><ul><li><a href="https://github.com/steveharoz/Vis-Acceptance-Rates/blob/master/acceptance%20rates.csv">部分数据来源</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;转载自：&lt;a href=&quot;https://link.zhihu.com/?target=https://divis.cn/archives/2590&quot;&gt;https://divis.cn/archives/2590&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="可视化" scheme="http://example.com/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
    <category term="可视化" scheme="http://example.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="论文" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>微前端技术调研</title>
    <link href="http://example.com/2023/02/07/micro_front-end_research/"/>
    <id>http://example.com/2023/02/07/micro_front-end_research/</id>
    <published>2023-02-07T09:14:09.000Z</published>
    <updated>2024-05-02T05:11:58.108Z</updated>
    
    <content type="html"><![CDATA[<p>​    本文针对微前端技术进行调研，主要从微前端背景、主流框架及原理以及当前行业中的一些实践方案三个方面进行介绍，最后给出了一些自己的思考和总结。</p><span id="more"></span><h3 id="微前端背景介绍"><a href="#微前端背景介绍" class="headerlink" title="微前端背景介绍"></a>微前端背景介绍</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p>​    <a href="https://micro-frontends.org/">Mirco-frontends</a>官网对微前端定义是：构建一个现代Web应用所需的技术、策略和方法，它具有多个团队独立开发、部署的特性。通俗来讲，微前端就是一种类似于微服务的架构理念，可以将一个复杂的前端应用拆分为更小、更简单的子应用，使得这些子应用可以由不同的团队进行独立的开发和部署。同时它也可以将不同框架（如React、Vue、Angular等）开发的、运行已久的应用进行合并，以达到降低复用成本、减少项目之间的耦合、提升项目扩展性等目的。一个微前端应用通常由一个基座应用（主应用）和多个子应用构成，通过基座应用来管理子应用的加载和卸载。</p><p><img src="/2023/02/07/micro_front-end_research/image-20240207171854987.png" alt="image-20240207171854987">微前端具有以下几个核心价值（引用自<a href="https://qiankun.umijs.org/zh/guide">qiankun官网</a>)：</p><ul><li><p>技术栈无关：</p><p>主框架不限制接入应用的技术栈，微应用具备完全的自主权</p></li><li><p>独立开发、独立部署：</p><p>微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</p></li><li><p>增量升级：</p><p>在面对各种复杂场景时，我们通常很难对一个已存在的系统做全量的技术升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略</p></li><li><p>独立运行时：</p><p>每个微应用之间状态隔离，运行时状态不共享</p></li></ul><h4 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h4><p>​    项目中为什么要引入微前端方案？在上述核心价值中已有所体现。现代的前端应用发展趋势正在变得越来越富功能化、富交互化，已有被维护的项目会随着时间的推进变得越来越庞大、越来越难以维护。开发人员往往会面临以下几个问题：</p><ul><li>不同的团队间需要使用不同的技术栈开发同一个应用；</li><li>每个团队都希望独立开发、独立部署，并且独立部署的应用有更新时如何同步更新其它模块；</li><li>新项目中还需要老项目中的代码，如何才能在无侵入的情况下复用老项目中的代码；</li></ul><p>​    此时，开发人员可以使用微前端架构理念，将一个应用划分成若干个子应用。当路径切换时加载不同的子应用，这样来实现每个子应用的独立，同时也不用受技术栈的限制，解决期待前端团队协同开发的问题。</p><h4 id="何时用？"><a href="#何时用？" class="headerlink" title="何时用？"></a>何时用？</h4><p>​    是否需要使用微前端需要根据具体的业务场景来定，但通常情况下在包括但不限于以下的几种场景下使用微前端能得到一个长久的收益：</p><ul><li><p>零散的活动页面</p><p>​    在很多活动场景中，运营需要配置一些重复性的业务，页面间存在雷同性、相似性或由不同的组件拼凑而成的。使用一个配置系统将这些组件进行灵活的管理将大大提高开发的效率，而此时配置系统很适合使用微前端理念来解决。</p></li><li><p>中台项目</p><p>​    面向于公司内部提供一些服务类的产品，会随着功能的丰富和配置系统的增加变得愈发庞大和复杂，使用微前端构建可以得到长久的收益。</p></li><li><p>大型产品项目</p><p>​    便于多个团队协作开发独立部署，减少开发周期。    </p></li></ul><h3 id="微前端主流框架"><a href="#微前端主流框架" class="headerlink" title="微前端主流框架"></a>微前端主流框架</h3><p>​    几乎所有的微前端框架都需要解决两大共性问题：一是应用的加载与切换。包括路由的处理、应用加载的处理和应用入口的选择。二是应用的隔离与通信。包括JS的隔离（副作用隔离）、样式的隔离以及父子应用与子子应用之间的通信问题。围绕着这两大问题出现了如下几种常用的微前端框架/方案：</p><h4 id="从single-spa到qiankun"><a href="#从single-spa到qiankun" class="headerlink" title="从single-spa到qiankun"></a>从single-spa到qiankun</h4><p>​    single-spa是一个很好的微前端框架，而qiankun框架就是基于single-spa来实现的，在single-spa的基础上做了一层封装，同时也解决了single-spa的一些缺陷。</p><h5 id="Single-spa"><a href="#Single-spa" class="headerlink" title="Single-spa"></a>Single-spa</h5><p>​    使用single-spa首先需要在基座应用中注册所有APP的路由，single-spa会保存各子应用的路由映射关系，并充当微前端控制器Controler。当URL响应时，匹配子应用路由并加载渲染子应用，如下图所示：</p><p><img src="/2023/02/07/micro_front-end_research/image-20240207173851674.png" alt="image-20240207173851674"></p><p>使用single-spa以Vue脚手架搭建的应用为基座构建微前端项目，实现步骤及关键代码如下：</p><ul><li><p>在main.js中完成基座配置，其核心是通过<strong>registerApplication</strong>注册子应用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/ main.js</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; registerApplication, start &#125; <span class="keyword">from</span> <span class="string">&#x27;single-spa&#x27;</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> mountApp = <span class="function">(<span class="params">url</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.src = url;</span><br><span class="line">        script.onload = resolve;</span><br><span class="line">        script.onerror = reject;</span><br><span class="line">        <span class="comment">// 通过script标签的方式挂在应用</span></span><br><span class="line">        <span class="keyword">const</span> firstScript = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;script&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 挂载子应用</span></span><br><span class="line">        firstScript.parentNode.insertBefore(script, firstScript);    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> loadApp = <span class="function">(<span class="params">appRouter,appName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 远程加载子应用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">        <span class="comment">// 手动挂在子应用</span></span><br><span class="line">        <span class="keyword">await</span> mountApp(appRouter + <span class="string">&#x27;/js/chunk-venders.js/&#x27;</span>);</span><br><span class="line">        <span class="keyword">await</span> mountApp(appRouter + <span class="string">&#x27;/js/app.js&#x27;</span>);</span><br><span class="line">        <span class="comment">// 获取子应用生命周期</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">window</span>[appName]    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子应用列表</span></span><br><span class="line"><span class="keyword">const</span> appList = [</span><br><span class="line">    &#123;</span><br><span class="line">        name:<span class="string">&#x27;app1&#x27;</span>, <span class="comment">// 子应用名称</span></span><br><span class="line">        app:loadApp(<span class="string">&#x27;http://localhost:8083&#x27;</span>,<span class="string">&#x27;app1&#x27;</span>), <span class="comment">// 挂在子应用</span></span><br><span class="line">        activeWhen:<span class="function"><span class="params">location</span> =&gt;</span> location.pathname.startsWith(<span class="string">&#x27;/app1&#x27;</span>)<span class="comment">// 匹配该子路由的条件</span></span><br><span class="line">        customProps:&#123;&#125; <span class="comment">// 传递给子应用的对象</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name:<span class="string">&#x27;app2&#x27;</span>,</span><br><span class="line">        app:loadApp(<span class="string">&#x27;http://localhost:8082&#x27;</span>,<span class="string">&#x27;app2&#x27;</span>),</span><br><span class="line">        activeWhen:<span class="function"><span class="params">location</span> =&gt;</span> location.pathname.startWith(<span class="string">&#x27;/app2&#x27;</span>),</span><br><span class="line">        customProps:&#123;&#125;    </span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 注册子应用</span></span><br><span class="line">appList.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    registerApplication(item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注册路由并启动基座</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        start()    </span><br><span class="line">    &#125;,</span><br><span class="line">    render:<span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>在子应用中配置生命周期挂在与导出方式。配置的核心是使用single-spa-vue生成字路由配置，并抛出其生命周期函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> singleSpaValue <span class="keyword">from</span> <span class="string">&#x27;single-spa-vue&#x27;</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> appOptions = &#123;</span><br><span class="line">    el:<span class="string">&#x27;#microApp&#x27;</span>,</span><br><span class="line">    router,</span><br><span class="line">    render:<span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不是微应用环境，则启动自身挂在的方式</span></span><br><span class="line"><span class="keyword">if</span>(!process.env.isMicro) &#123;</span><br><span class="line">    <span class="keyword">delete</span> appOption.el</span><br><span class="line">    <span class="keyword">new</span> Vue(appOptions).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基于基座应用，导出生命周期</span></span><br><span class="line"><span class="keyword">const</span> appLifecycle = singleSpaVue(&#123;</span><br><span class="line">    Vue,</span><br><span class="line">    appOptions</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 抛出子应用生命周期</span></span><br><span class="line"><span class="comment">// 启动生命周期函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bootstrap = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> appLifecycle.bootstrap(<span class="function">()=&gt;</span>&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 挂载生命周期函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mount = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> appLifecycle.mount(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卸载生命周期函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> unmount = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> appLifecycle.unmount(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置子应用为umd打包方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">const</span> package = <span class="built_in">require</span>(<span class="string">&#x27;./package.json&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    <span class="comment">// 告诉子应用在这个地址加载静态资源，否则会去基座应用的域名下加载</span></span><br><span class="line">    publicPath:<span class="string">&#x27;//localhost:8082&#x27;</span>,</span><br><span class="line">    <span class="comment">// 开发服务器</span></span><br><span class="line">    devServer:&#123;</span><br><span class="line">        port: <span class="number">8082</span></span><br><span class="line">    &#125;,</span><br><span class="line">    configureWebpack:&#123;</span><br><span class="line">        <span class="comment">// 导出umd格式的包，在全局对象上挂载属性package.name,基座应用需要通过这个全局对象获取一些信息</span></span><br><span class="line">        <span class="comment">// 比如子应用到出的生命周期函数</span></span><br><span class="line">        output:&#123;</span><br><span class="line">            <span class="comment">// library的值在所有子应用中需要唯一</span></span><br><span class="line">            library:package.name,</span><br><span class="line">            libraryTarget:<span class="string">&#x27;umd&#x27;</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置子应用环境变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .env.micro</span></span><br><span class="line">NODE_ENV = development</span><br><span class="line">VUE_APP_BASE_URL = /app2</span><br><span class="line">isMicro = <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><p>​    Single-SPA通过路由劫持和导出生命周期钩子函数的方式很好的解决了路由的加载切换和应用接入的问题，但在应用入口的选择、应用隔离（JS隔离和样式隔离）等方面仍有不足。例如，使用JS Entry的方式需要更改打包配置，将整个微应用打包成一个JS发布到静态资源服务器，然后在主应用中配置文件地址告诉single-spa去哪加载微应用，这将导致打包产物体积膨胀、无法并行加载等问题，且该方式侵入性较强。除此之外，Single-SPA并未提供应用之间的通信方案，它仅在注册应用时给微应用注入一些状态信息，后续通讯需要用户自己去实现。</p><h5 id="qiankun"><a href="#qiankun" class="headerlink" title="qiankun"></a>qiankun</h5><p>为了解决Single-SPA的一些不足，qiankun在Single-SPA的基础上进行了进一步的扩展，并且保留了Single-SPA中的优秀理念。其主要的扩展如下：</p><ul><li><p>HTML Entry：JS Entry的方式是把子应用打包成一个entry script，其中css、图片等资源必须都打包到js bundle中导致bundle体积庞大，并且资源无法并行加载。HTML Entry的方式是主应用fetch子应用的html入口文件，去掉html/head/body后，把子节点插入主应用容器中，具有灵活、低成本接入的优点。</p></li><li><p>JS沙箱：JS 沙箱为每个微应用生成单独的 window proxy 对象，配合 HTML Entry 提供的 JS 脚本执行器 (execScripts) 来实现 JS 隔离，确保微应用之间全局变量/事件不冲突。</p></li><li><p>CSS样式隔离：提供了两种样式隔离的方案：严格的样式隔离和改变选择器名的方式。严格的样式隔离模式，为每个微应用的容器包裹上一个 shadow dom 节点，从而确保微应用的样式不会对全局造成影响。改变样式名的方式利用css预处理器在编译时生成不冲突的选择器名。</p></li><li><p>应用间通信：提供了两种通信方法，一种是挂载一个事件总线，在总线上注册监听事件，通过发布订阅模型来实现应用之间的相互通信。另一种基于props，将state 和 onGlobalStateChange通过props传递给子应用，从而实现应用间的通信。</p></li></ul><p>使用qiankun以Vue脚手架搭建主应用、React搭建子应用，实现关键代码如下：</p><ul><li><p>在主应用中注册微应用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> apps = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;ReactMicroApp&quot;</span>, <span class="comment">// 微应用名称 - 具有唯一性</span></span><br><span class="line">    entry: <span class="string">&quot;//localhost:10100&quot;</span>, <span class="comment">// 微应用入口 - 通过该地址加载微应用</span></span><br><span class="line">    container: <span class="string">&quot;#frame&quot;</span>, <span class="comment">// 微应用挂载节点 - 微应用加载完成后将挂载在该节点上</span></span><br><span class="line">    activeRule: <span class="string">&quot;/react&quot;</span>, <span class="comment">// 微应用触发的路由规则 - 触发路由规则后将加载该微应用</span></span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> apps;</span><br></pre></td></tr></table></figure></li><li><p>配置主应用菜单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  menus = [</span><br><span class="line">    &#123;</span><br><span class="line">      key: <span class="string">&quot;Home&quot;</span>, <span class="comment">// 唯一 Key 值</span></span><br><span class="line">      title: <span class="string">&quot;主页&quot;</span>, <span class="comment">// 菜单标题</span></span><br><span class="line">      path: <span class="string">&quot;/&quot;</span>,  <span class="comment">// 菜单对应的路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      key: <span class="string">&quot;ReactMicroApp&quot;</span>,</span><br><span class="line">      title: <span class="string">&quot;React 主页&quot;</span>,</span><br><span class="line">      path: <span class="string">&quot;/react&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      key: <span class="string">&quot;ReactMicroAppList&quot;</span>,</span><br><span class="line">      title: <span class="string">&quot;React 列表页&quot;</span>,</span><br><span class="line">      path: <span class="string">&quot;/react/list&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置微应用，导出qiankun所需的三个生命周期钩子函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  <span class="comment">// 动态设置 webpack publicPath，防止资源加载出错</span></span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-undef</span></span><br><span class="line">  __webpack_public_path__ = <span class="built_in">window</span>.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;antd/dist/antd.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./public-path&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.jsx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 渲染函数</span></span><br><span class="line"><span class="comment"> * 两种情况：主应用生命周期钩子中运行 / 微应用单独启动时运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 独立运行时，直接挂载应用</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  render();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。</span></span><br><span class="line"><span class="comment"> * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ReactMicroApp bootstraped&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  render(props);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.unmountComponentAtNode(<span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置路由命名空间，确保主应用能正常加载子应用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// micro-app-react/src/App.jsx</span></span><br><span class="line"><span class="keyword">const</span> BASE_NAME = <span class="built_in">window</span>.__POWERED_BY_QIANKUN__ ? <span class="string">&quot;/react&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 设置路由命名空间</span></span><br><span class="line">    &lt;Router basename=&#123;BASE_NAME&#125;&gt;&#123;<span class="comment">/* ... */</span>&#125;&lt;/Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>修改webpack配置，使生命周期钩子函数能被qiankun识别。由于React脚手架对webpack配置做了隐藏，因此我们可以借助react-app-rewired来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 config-overrides.js 文件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  webpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 微应用的包名，这里与主应用中注册的微应用名称一致</span></span><br><span class="line">    config.output.library = <span class="string">`ReactMicroApp`</span>;</span><br><span class="line">    <span class="comment">// 将你的 library 暴露为所有的模块定义下都可运行的方式</span></span><br><span class="line">    config.output.libraryTarget = <span class="string">&quot;umd&quot;</span>;</span><br><span class="line">    <span class="comment">// 按需加载相关，设置为 webpackJsonp_VueMicroApp 即可</span></span><br><span class="line">    config.output.jsonpFunction = <span class="string">`webpackJsonp_ReactMicroApp`</span>;</span><br><span class="line">    config.resolve.alias = &#123;</span><br><span class="line">      ...config.resolve.alias,</span><br><span class="line">      <span class="string">&quot;@&quot;</span>: path.resolve(__dirname, <span class="string">&quot;src&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  devServer: <span class="function"><span class="keyword">function</span> (<span class="params">configFunction</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">proxy, allowedHost</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> config = configFunction(proxy, allowedHost);</span><br><span class="line">      <span class="comment">// 关闭主机检查，使微应用可以被 fetch</span></span><br><span class="line">      config.disableHostCheck = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 配置跨域请求头，解决开发环境的跨域问题</span></span><br><span class="line">      config.headers = &#123;</span><br><span class="line">        <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 配置 history 模式</span></span><br><span class="line">      config.historyApiFallback = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="基于WebComponent的micro-app"><a href="#基于WebComponent的micro-app" class="headerlink" title="基于WebComponent的micro-app"></a>基于WebComponent的micro-app</h4><p>与qiankun不同，micro-app并没有沿袭single-spa的思路而是借鉴了WebComponent的思想，通过CustomElement结合自定义的ShadowDom，将微前端封装成一个类WebComponent组件，从而实现微前端的组件化渲染。并且由于自定义ShadowDom的隔离特性，micro-app不需要像single-spa和qiankun一样要求子应用修改渲染逻辑并暴露出方法，也不需要修改webpack配置，是目前接入微前端成本最低的方案。</p><h5 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h5><p>​    Web Components 是一套不同的技术，允许你创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 web 应用中使用它们。其主要由三个部分组成Custom elements（自定义元素）、Shadow DOM（影子 DOM）和HTML templates（HTML 模板），通过一起使用来创建封装功能的定制元素，且不用担心代码冲突（<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components#%E4%BE%8B%E5%AD%90">引用自MDN官网</a>）。详细定义可移步至MDN官网阅读。</p><p><img src="/2023/02/07/micro_front-end_research/image-20240207175123787.png" alt="image-20240207175123787"></p><ul><li>使用方便：</li></ul><p>​    可以将所有功能都封装到一个类WebComponent组件中，从而实现在基座应用中嵌入一行代码即可渲染一个微前端应用。同时还提供了js沙箱、样式隔离、元素隔离、预加载、数据通信、静态资源补全等一系列完善的功能。</p><ul><li>零依赖：</li></ul><p>​    micro-app没有任何依赖，这赋予它小巧的体积和更高的扩展性。</p><ul><li>兼容所有框架：</li></ul><p>​    为了保证各个业务之间的独立开发、独立部署的能力，micro-app做了许多兼容，在任何技术框架中都可以正常运行。</p><h5 id="微应用配置"><a href="#微应用配置" class="headerlink" title="微应用配置"></a>微应用配置</h5><ul><li><p>基座配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> microApp <span class="keyword">from</span> <span class="string">&#x27;@micro-zoe/micro-app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appName = <span class="string">&#x27;my-app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预加载</span></span><br><span class="line">microApp.preFetch([</span><br><span class="line">  &#123; <span class="attr">name</span>: appName, <span class="attr">url</span>: <span class="string">&#x27;xxx&#x27;</span> &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基座向子应用数据通信</span></span><br><span class="line">microApp.setData(appName, &#123; <span class="attr">type</span>: <span class="string">&#x27;新的数据&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// 获取指定子应用数据</span></span><br><span class="line"><span class="keyword">const</span> childData = microApp.getData(appName)</span><br><span class="line"></span><br><span class="line">microApp.start(&#123;</span><br><span class="line">  <span class="comment">// 公共文件共享</span></span><br><span class="line">  globalAssets: &#123;</span><br><span class="line">    js: [<span class="string">&#x27;js地址1&#x27;</span>, <span class="string">&#x27;js地址2&#x27;</span>, ...], <span class="comment">// js地址</span></span><br><span class="line">    css: [<span class="string">&#x27;css地址1&#x27;</span>, <span class="string">&#x27;css地址2&#x27;</span>, ...], <span class="comment">// css地址</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>子应用配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> microApp <span class="keyword">from</span> <span class="string">&#x27;@micro-zoe/micro-app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appName = <span class="string">&#x27;my-app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子应用运行时，切换静态资源访问路径</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__MICRO_APP_ENVIRONMENT__) &#123;</span><br><span class="line">  __webpack_public_path__ = <span class="built_in">window</span>.__MICRO_APP_PUBLIC_PATH__</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子应用向基座发送数据</span></span><br><span class="line"><span class="comment">// dispatch只接受对象作为参数</span></span><br><span class="line"><span class="built_in">window</span>.microApp.dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;子应用发送的数据&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// 获取基座数据</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="built_in">window</span>.microApp.getData() <span class="comment">// 返回基座下发的data数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能优化，umd模式</span></span><br><span class="line"><span class="comment">// 如果子应用渲染和卸载不频繁，那么使用默认模式即可，如果子应用渲染和卸载非常频繁建议使用umd模式</span></span><br><span class="line"><span class="comment">// 将渲染操作放入 mount 函数 -- 必填</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将卸载操作放入 unmount 函数 -- 必填</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.unmountComponentAtNode(<span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微前端环境下，注册mount和unmount方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__MICRO_APP_ENVIRONMENT__) &#123;</span><br><span class="line">  <span class="built_in">window</span>[<span class="string">`micro-app-<span class="subst">$&#123;<span class="built_in">window</span>.__MICRO_APP_NAME__&#125;</span>`</span>] = &#123; mount, unmount &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 非微前端环境直接渲染</span></span><br><span class="line">  mount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>路由配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Switch, Route &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">AppRoute</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 设置基础路由，子应用可以通过window.__MICRO_APP_BASE_ROUTE__获取基座下发的baseroute，</span></span><br><span class="line">    <span class="comment">// 如果没有设置baseroute属性，则此值默认为空字符串</span></span><br><span class="line">    &lt;BrowserRouter basename=&#123;<span class="built_in">window</span>.__MICRO_APP_BASE_ROUTE__ || <span class="string">&#x27;/&#x27;</span>&#125;&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/BrowserRouter&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​    综上所述，Web Components是有能力以组件加载的方式将微应用整合在一起作为微前端的一种手段，但不幸的是，Web Components是浏览器的新特性，所以它的兼容性不是很好，如果有兼容性要求的项目还是无法使用，具体请查看<a href="https://caniuse.com/?search=WebComponents">can i use</a>。</p><h4 id="基于Webpack5的ModuleFederation"><a href="#基于Webpack5的ModuleFederation" class="headerlink" title="基于Webpack5的ModuleFederation"></a>基于Webpack5的ModuleFederation</h4><h5 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h5><p>​    Module Federation是webpack5提出的概念，用于解决多个应用之间的代码共享的问题，让使用者更加优雅的实现跨应用的代码共享。其解决问题的中心思想与微前端的思想类似，即把一个应用拆分成多个应用，每个应用可独立开发，独立部署，一个应用可动态的加载并运行另一个应用的代码，并实现应用之间的依赖共享。</p><p>为了实现这些功能，Module Federation在设计上提出了以下几个概念：</p><ul><li><p>Container：被ModuleFederationPlugin打包出来的模块被称为Container。通俗来讲就是，如果项目中一个应用适用了ModuleFederationPlugin构建，那么它就一个Container模块，它可以加载其他的Container，也可以被其他的Container所加载。</p></li><li><p>Host&amp;Remote：</p><ul><li>以消费者和生产者的角度看，Container又可被称作Host和Remote。</li><li>Host：消费方，它可以动态的加载并运行其他的Container的代码。</li><li>Remote：提供方，用于暴露属性（如组件、方法等）供Host使用。</li></ul></li></ul><p>​    对于一个container来说，Host和Remote是相对的，一个Container既可以作为Host，又可以作为Remote使用。</p><ul><li>Shared：一个 Container 可以 与其他 Container 可以共享的第三方依赖，使你的代码中不用重复加载同一份依赖，也就是共享依赖。</li></ul><h5 id="微应用配置-1"><a href="#微应用配置-1" class="headerlink" title="微应用配置"></a>微应用配置</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ModuleFederationPlugin = <span class="built_in">require</span>(<span class="string">&quot;webpack/lib/container/ModuleFederationPlugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 其他webpack配置...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ModuleFederationPlugin(&#123;</span><br><span class="line">        name: <span class="string">&#x27;empBase&#x27;</span>,</span><br><span class="line">        library: &#123; <span class="attr">type</span>: <span class="string">&#x27;var&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;empBase&#x27;</span> &#125;,</span><br><span class="line">        filename: <span class="string">&#x27;emp.js&#x27;</span>, <span class="comment">// 入口文件名称</span></span><br><span class="line">        remotes: &#123; <span class="comment">// 如果把这一模块当作基座模块的话，这里应该配置其他子应用模块的入口文件</span></span><br><span class="line">          app_two: <span class="string">&quot;app_two_remote&quot;</span>,</span><br><span class="line">          app_three: <span class="string">&quot;app_three_remote&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        exposes: &#123;   <span class="comment">//暴露可访问的组件</span></span><br><span class="line">          <span class="string">&#x27;./Component1&#x27;</span>: <span class="string">&#x27;src/components/Component1&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;./Component2&#x27;</span>: <span class="string">&#x27;src/components/Component2&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//共享依赖，其他模块不需要再次下载，便可使用</span></span><br><span class="line">        shared: [<span class="string">&quot;react&quot;</span>, <span class="string">&quot;react-dom&quot;</span>,<span class="string">&quot;react-router-dom&quot;</span>]</span><br><span class="line">      &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其构建过程如下：</p><ul><li>首先，Module Federation会让webpack以filename作为文件名生成文件。</li><li>其次，文件中以var的形式暴露了一个名为name的全局变量，其中包含了expose以及shared中配置的内容。</li><li>最后，作为host时，先通过remote的init方法将自身shared写入remote中，再通过get获取remote中expose的组件，而作为remote时，判断host中是否有可用的共享依赖，若有，则加载host的这部分依赖，若无，则加载自身依赖。</li></ul><h3 id="当前行业中的实践方案"><a href="#当前行业中的实践方案" class="headerlink" title="当前行业中的实践方案"></a>当前行业中的实践方案</h3><h4 id="X音乐PaaS微前端方案"><a href="#X音乐PaaS微前端方案" class="headerlink" title="X音乐PaaS微前端方案"></a>X音乐PaaS微前端方案</h4><p><img src="/2023/02/07/micro_front-end_research/image-20240207175435482.png" alt="image-20240207175435482"></p><p>​    云音乐微前端平台针对于云音乐的CMS场景，提出了可配置式的微前端平台化设计，包括用于管理主子应用的 <a href="https://p.fn.netease.com/">PaaS 管理平台</a>，可对主子应用的引用关系以及主子应用的路由、权限等配置进行管理。以及基于 qiankun 实现的根据下发配置渲染微应用与菜单的外框架（主应用）与微应用（子应用）。</p><p>​    在云音乐 CMS 中，对微前端做了以下约定：</p><ul><li>以页面为粒度拆分子应用，主应用是多个子应用部分页面的组合；</li><li>主应用对页面路由、权限进行管理；</li></ul><p>​    云音乐CMS的主要场景是需要对现有存量的基于umi 2、umi 3以及regluar搭建的前端应用进行接入管理，其核心价值在于可管理微应用与编排菜单的 PaaS 平台。因此，运行时的微前端实现方案主要以umi为构建框架，在基于umi官方提供的qiankun插件基础上，编写并封装适配于云音乐CMS场景的umi3和regular插件，其插件主要解决了如下几个问题：</p><ul><li>扩展插件功能。为应用默认导出在runtime.js中qiankun需要的方法，并将主应用传递给子应用的参数写入子应用的全局变量中，便于需要时调用。此外，在构建完成后生成菜单并上报平台的功能。</li><li>处理base路由问题。在微前端场景下，多个子应用之间可能存在路由重合的场景。因此，需要对子应用路由的 base path进行改写，并拼接上主子应用的 base path。</li><li>解决路由反复横跳问题。将初始化路由监听由bootstrap 阶段调整到mount 阶段，并在 history 的 push() 方法上做拦截。</li></ul><p>使用方法：X音乐CMS文档：<a href="https://p.fn.netease.com/#/use">https://p.fn.netease.com/#/use</a></p><h4 id="欢聚时代EMP微前端方案"><a href="#欢聚时代EMP微前端方案" class="headerlink" title="欢聚时代EMP微前端方案"></a>欢聚时代EMP微前端方案</h4><p><img src="/2023/02/07/micro_front-end_research/image-20240207175542935.png" alt="image-20240207175542935"></p><p>​    在中台开发过程中，有许多的配置系统需要去开发和维护， 这些配置系统之间有很多公用模块需要公用的。对于这些公用的模块，为了节约第二次开发和第三次开发的人力资源，需要考虑去把这些共享组件抽取出来作为公共的资源。解决该问题的常用方法是将业务子模块抽取为npm包，但对于该种方式来说，其具有以下痛点：</p><ul><li>更新流程繁琐。 当公用模块迭代的业务系统较多时，每次更新npm包版本后都需要更新多个应用的npm包的版本。</li><li>构建速度慢。 一个应用系统中可能应用到了多个以npm包形式引入的业务子模块， 随着npm包越来越多的情况下， 同步构建的体积会越来越大、构建时间变长甚至发布的流程也会越来越慢。</li><li>应用迭代麻烦。例如，对于中台业务场景通常需要自定义一个统一UI风格的骨架，在实际项目中引用并填充业务内容。但当模版更新某些功能后，已有的项目无法自动的更新模版需要手动更新，并且可能需要做一些冲突处理。</li></ul><p>​    由于该业务场景主要是希望对业务中的共享模块做到独立开发、独立部署、一键更新等特性，对于qiankun和single-spa来说，同一个技术栈具有状态不共享、部分模块可能需要改造才能调用，这些会增加部署、维护、改造的成本，因此采用模块联邦的方式实现微前端更贴近其业务。</p><h5 id="基本方案"><a href="#基本方案" class="headerlink" title="基本方案"></a>基本方案</h5><p><img src="/2023/02/07/micro_front-end_research/image-20240207175636517.png" alt="image-20240207175636517"></p><p>EMP是采用Webpack5的Module Federation实现的微前端方案，其生态总体框架吧如上所示。</p><ul><li>基于webpack 5、Module Federation、TypeScript搭建EMP脚手架，仓库地址：<a href="https://github.com/efoxTeam/emp%E3%80%82">https://github.com/efoxTeam/emp。</a></li><li>使用脚手架搭建项目，实现构建、打包、webpack配置、Medule Federation配置等一系列配置。</li><li>搭建一个基站base（可以理解成一个主应用项目）， 用于放置公用组件如ui组件、业务组件等。</li><li>搭建具体的业务应用，如App1、App2等，这些业务应用就可以共享base中的公用业务组件，同时App1和App2之间也可以相互共享业务组件，并且当组件更新后会同步到相应的应用。</li></ul><p>使用方法：</p><p>​    emp-cli接入文档：<a href="https://github.com/efoxTeam/emp/blob/main/packages/emp-cli/README-zh_CN.md">https://github.com/efoxTeam/emp/blob/main/packages/emp-cli/README-zh_CN.md</a></p><h4 id="XX金服ALPHA微前端方案"><a href="#XX金服ALPHA微前端方案" class="headerlink" title="XX金服ALPHA微前端方案"></a>XX金服ALPHA微前端方案</h4><h5 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h5><p>为了满足大型中台项目的开发，要解决如下问题：</p><ul><li>将不同的业务子系统集中到一个大平台上统一对外开放；</li><li>给不同的用户赋予不同的权限让其能够访问平台的特定业务模块，同时禁止其访问物权限的业务模块；</li><li>快速接入新的子系统，并对子系统进行版本管理，保证功能同步；</li><li>针对于老系统如何实现从Backbone技术栈到React技术栈或Vue技术栈的平滑升级；</li></ul><p>​    使用微前端方案可以很好的解决以上问题，但对于qiankun和Single-Spa框架存在以下问题：</p><ul><li>single-spa中所有的子项目都必须存在与同一域下的仓库中；</li><li>对于single-spa和qiankun来说，他们存在的一个共同的问题是都有一套自己的路由机制，因此如果旧项目中使用的是react-router就必须对旧的项目中的router进行重构；</li></ul><p>​    因此，ALPHA系统基于single-spa的思想，重构了一套微前端方案，使得子系统发布不受约束、独立部署、同步更新的同时，非侵入式的整合使用React、Angular、Vue等前端框架搭建的中后台项目。</p><p><img src="/2023/02/07/micro_front-end_research/image-20240207175743647.png" alt="image-20240207175743647"></p><p>针对于以上需求，APLHA前端方案通过如下过程实现：</p><ul><li>封装了一套自己的脚手架，在脚手架中设定适合自身的打包配置；</li><li>使用UC系统管理应用的权限，创建项目前需要在UC中创建对应的项目并设置权限；</li><li>以js文件为子应用入口文件，将子应用打包生成 <strong>${sourceKey}.js</strong> 文件与**${sourceKey}.css<strong>文件，并同时使用 <strong>webpack</strong> 的 <strong>ManifestPlugin</strong>生成自述</strong>mapping.json**文件；</li><li>在APLHA系统中加入项目的相关配置，当子应用被加载时，通过http请求的方式获取mapping.json自述文件，通过layout中的方法组合并进行模版渲染；</li><li>使用消息订阅与发布的方式实现layout与子系统之间的通信；</li></ul><p><img src="/2023/02/07/micro_front-end_research/image-20240207175831323.png" alt="image-20240207175831323"></p><p>通过该方法，ALPLHA具有较高的可配置性，可以实现三种不同场景需求：</p><ul><li>不使用ALPHA提供的layout和vendor，完全独立渲染；</li><li>使用ALPHA提供的layout和vendor，子项目仅渲染内容区；</li><li>使用ALPHA提供的layout，子项目有自己的vendor.js；</li></ul><h3 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h3><p>综上所述，现有的几种微前端实现方法与框架可总结如下：</p><ul><li>iframe</li><li>Single-Spa</li><li>qiankun</li><li>mirco-app（Web Components）</li><li>EMP（Module Federation）</li></ul><p>其中，这些解决方案各有利弊：</p><ul><li>iframe：可以直接加载其他应用，但无法做到单页导致许多功能无法正常在主应用中展示。</li><li>Single-Spa：很好的解决了路由的加载切换和应用接入的问题，但在应用入口的选择、应用隔离（JS隔离和样式隔离）等方面仍有不足。并且框架没有提供应用之间的通信方案，需要用户手动实现。</li><li>qiankun：结合了Single-Spa的优点并弥补了其缺陷。基本上可以称为单页版的iframe，具有沙箱隔离及资源预加载的特点，几乎无可挑剔。</li><li>mirco-app（Web Components）：Web Components是浏览器提供给开发者的能力，能在单页中实现微前端，但是考虑到时浏览器的新特性，故存在兼容性问题，微前端方面的探索也不成熟，只能作为面向未来的微前端手段。</li><li>EMP（Module Federation）：在实现微前端的基础上，扩充了跨应用状态共享、跨框架组件调用、远程拉取ts声明文件、动态更新微应用等能力。同时，第三方依赖的共享，使代码尽可能地重复利用，减少加载的内容。但不足之处在于目前无法覆盖所有前端框架。</li></ul><p>​    对比三个实践场景，我的感受是：没有最好的微前端框架，只有最适用的业务场景。云音乐CMS微前端方案直接利用现成的qiankun插件进行改造，既满足了对存量应用的接入、新应用的独立开发部署等需求，又极大的节约了改造成本。相比于欢聚时代EMP方案，他们的需求是希望在能够独立开发部署的同时，降低共享组件的维护成本及构建、更新效率，因此选择Module Federation无疑更加贴近需求。而对于贝壳金服的APLHA方案，需求主要关注于老应用的平滑升级及非侵入式的路由接入，因此重构了一套适用于自己的微前端方案。所以，针对于主要业务场景选择最合适的微前端方案最为重要，对于后续的细微不足可以慢慢的弥补。例如，云音乐CMS在后续的改造过程中，对于页面初始化加载速度慢的问题，通过提供sdk接入主应用的形式得到了解决，而对于共享组件复用的问题可以以构建subtree的形式得到解决。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://micro-frontends.org/">Micro Frontends 官网</a></li><li><a href="https://zh-hans.single-spa.js.org/docs/getting-started-overview">single-spa官网</a></li><li><a href="https://qiankun.umijs.org/zh/guide">Qiankun官网</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components#%E4%BE%8B%E5%AD%90">WebComponents-MDN官网</a></li><li><a href="http://cangdu.org/micro-app/docs.html#/">micro-app官网</a></li><li><a href="https://github.com/efoxTeam/emp/wiki/%E3%80%8Amodule-Federation%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E3%80%8B">module-Federation原理学习</a></li><li><a href="https://p.fn.netease.com/#/use">云音乐中后台PaaS</a></li><li><a href="https://juejin.cn/post/6891532248269783054">EMP微前端方案</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    本文针对微前端技术进行调研，主要从微前端背景、主流框架及原理以及当前行业中的一些实践方案三个方面进行介绍，最后给出了一些自己的思考和总结。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="中后台" scheme="http://example.com/tags/%E4%B8%AD%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>分层和合成机制</title>
    <link href="http://example.com/2021/09/06/division_and_synthesis_mechanism/"/>
    <id>http://example.com/2021/09/06/division_and_synthesis_mechanism/</id>
    <published>2021-09-06T02:23:37.000Z</published>
    <updated>2024-05-02T05:33:26.652Z</updated>
    
    <content type="html"><![CDATA[<p>​    每个显示器都有固定的刷新频率，通常是60HZ（即每秒刷新60次），更新的图片都来自于显卡中<strong>前缓冲区</strong>。显卡会合成新的图像，并将其保存到<strong>后缓冲区</strong>，一旦新合成的图像写到后缓冲区，系统就会让<strong>后缓冲区</strong>和<strong>前缓冲区</strong>交换，以此保证显示器读取到新合成的图像。在浏览器中，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。由于大多数屏幕的更新频率都是60次/秒，这就意味着<strong>渲染引擎</strong>每秒需要更新60张图片到显卡的后缓存区，一旦渲染引擎生成某些帧（一张图片就是一帧）的时间过久，用户就会感到卡顿。Chrome浏览器引入了<strong>分层</strong>和<strong>合成</strong>机制，以此来解决卡顿或每帧生成时间过久的问题。</p><span id="more"></span><h3 id="如何生成一帧图像"><a href="#如何生成一帧图像" class="headerlink" title="如何生成一帧图像"></a>如何生成一帧图像</h3><p>浏览器渲染流水线中任意一帧生成的方式有：<strong>重排</strong>、<strong>重绘</strong>和<strong>合成</strong>三种。三种方式生成一帧图像的路径是不同的，但通常路径越长，生成图像说花费的时间就越多。</p><p><strong>重排</strong>：需要重新根据CSSOM和DOM来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍。</p><p><strong>重绘</strong>：需要重新计算绘制信息，并触发绘制操作之后的一系列操作。</p><p><strong>合成</strong>：不需要触发布局和绘制两个阶段，如果采用了GPU，那么合成效率更高。</p><p>所以，渲染引擎生成一帧图像的几种方式按照效率会优先使用合成，若不能满足需求，那么再使用重排或者重绘；</p><h3 id="分层与合成"><a href="#分层与合成" class="headerlink" title="分层与合成"></a>分层与合成</h3><p>​    通常页面的组成是非常复杂的，如果没有采用分层机制，从布局树直接生成目标图片的话一旦页面有很小的变化都会触发重排或者重绘，这种绘制策略会严重影响页面的渲染效率。为了提升每帧的渲染效率，我们可以将一张网页想象成多个图片叠加在一起的，每张图片对应一个图层，比如透明度、边框影阴、是否可旋转等，最后将这些图层叠加在一起后呈现最终的图片。将素材分解为多个图层的操作就称为<strong>分层</strong>，最后将这些图层合并到一起的操作就称为<strong>合成</strong>。</p><p>​    假设一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者 Alpha 渐变，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。</p><h4 id="分层与合成-1"><a href="#分层与合成-1" class="headerlink" title="分层与合成"></a>分层与合成</h4><p>​    在Chrome的渲染流水线中，分层体现在生成<strong>布局树</strong>之后，渲染引擎会根据布局树的特点将其转换为<strong>层树</strong>（Layer Tree）。层树的每一个节点都对应着一个图层，下一步的绘制就依赖于层树中的节点。绘制阶段其实并不是真正地绘出图片，而是将<strong>绘制指令</strong>组合成一个列表。有了绘制列表之后，光栅化就是按照绘制列表中的指令生成图片，每一个图层对应一张图片，<strong>合成线程</strong>有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。<strong>合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的</strong>。</p><h4 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h4><p>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。</p><p>​    通常情况下，页面的内容要比屏幕大的多，如果想要显示一个页面要等所有的图层都生成完了再进行合成的话会产生一些不必要的开销或者图片合成的时间变得更久。因此，<strong>合成线程</strong>会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，但是有时候即使优先绘制优先级高的图块也会因为<strong>纹理上传</strong>的原因耗费不少时间。</p><p>​    为此，Chrome 又采取了一个策略：<strong>在首次合成图块的时候使用一个低分辨率的图片</strong>。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。</p><h3 id="使用分层技术优化代码"><a href="#使用分层技术优化代码" class="headerlink" title="使用分层技术优化代码"></a>使用分层技术优化代码</h3><p>​    使用will-change来告诉渲染引擎对该元素做一些特效变换。当我们需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">will-change: transform, opacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。<strong>这也是 CSS 动画比 JavaScript 动画高效的原因</strong>。</p><p><strong>参考文献</strong>：《浏览器工作原理与实践》-李兵</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    每个显示器都有固定的刷新频率，通常是60HZ（即每秒刷新60次），更新的图片都来自于显卡中&lt;strong&gt;前缓冲区&lt;/strong&gt;。显卡会合成新的图像，并将其保存到&lt;strong&gt;后缓冲区&lt;/strong&gt;，一旦新合成的图像写到后缓冲区，系统就会让&lt;strong&gt;后缓冲区&lt;/strong&gt;和&lt;strong&gt;前缓冲区&lt;/strong&gt;交换，以此保证显示器读取到新合成的图像。在浏览器中，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。由于大多数屏幕的更新频率都是60次/秒，这就意味着&lt;strong&gt;渲染引擎&lt;/strong&gt;每秒需要更新60张图片到显卡的后缓存区，一旦渲染引擎生成某些帧（一张图片就是一帧）的时间过久，用户就会感到卡顿。Chrome浏览器引入了&lt;strong&gt;分层&lt;/strong&gt;和&lt;strong&gt;合成&lt;/strong&gt;机制，以此来解决卡顿或每帧生成时间过久的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>搞定前端手写题</title>
    <link href="http://example.com/2021/08/26/front-end_algorithm_questions/"/>
    <id>http://example.com/2021/08/26/front-end_algorithm_questions/</id>
    <published>2021-08-26T14:02:24.000Z</published>
    <updated>2024-05-28T15:50:02.666Z</updated>
    
    <content type="html"><![CDATA[<p>​    本篇文章用于总结自己在前端面试的过程中所遇到的手撕题和前端常考的算法题，其主要包括题目与Javascript实现的解法。一部分题目的代码由自己编写实现，还有一部分题目的代码来源互联网，所有代码都经过自己的运行验证，请放心食用。后续还会持续更新。。。</p><span id="more"></span><h3 id="场景手写题"><a href="#场景手写题" class="headerlink" title="场景手写题"></a>场景手写题</h3><h4 id="手写debounce"><a href="#手写debounce" class="headerlink" title="手写debounce"></a>手写debounce</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,delay=<span class="number">100</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">input.addEventListener(<span class="string">&#x27;keyup&#x27;</span>,debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(input.value);</span><br><span class="line">&#125;,<span class="number">100</span>))</span><br></pre></td></tr></table></figure><h4 id="手写throttle"><a href="#手写throttle" class="headerlink" title="手写throttle"></a>手写throttle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay = <span class="number">100</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">div.addEventListener(<span class="string">&#x27;drag&#x27;</span>,throttle(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.offsetX,e.offsetY);</span><br><span class="line">&#125;,<span class="number">100</span>))</span><br></pre></td></tr></table></figure><h4 id="手写flat"><a href="#手写flat" class="headerlink" title="手写flat"></a>手写flat</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*手写flat*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatDeep</span>(<span class="params">arr,deep = <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr[i]))&#123;</span><br><span class="line">         deep&gt;<span class="number">0</span>?(result = result.concat(flatDeep(arr[i],deep-<span class="number">1</span>))):(result.push(arr[i]))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手写深拷贝--初级版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj = &#123;&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj != <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">            result[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手写深拷贝升级版，克服对象循环引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj = &#123;&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj != <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(key)&amp;&amp;obj[key]!=obj)&#123;</span><br><span class="line">            result[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj[key]===obj)&#123;</span><br><span class="line">result[key] = result;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手写call"><a href="#手写call" class="headerlink" title="手写call"></a>手写call</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    context =(context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) ? <span class="built_in">window</span> : context</span><br><span class="line">    <span class="comment">//其实就等价于 obj.fn = function say()&#123;&#125; 当指向 context.fn 时，say里面的this 指向obj</span></span><br><span class="line">    context.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//obj 此时变成 var obj = &#123;name:&#x27;innerName&#x27;,fn:function say()&#123;console.log(this.name)&#125;&#125;</span></span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>) <span class="comment">//截取第二个开始的所有参数</span></span><br><span class="line">    <span class="keyword">let</span> result= context.fn(...args)<span class="comment">//把执行的结果赋予result变量</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn <span class="comment">//删除执行上下文上的属性 （还原）由var obj = &#123;name:&#x27;innerName&#x27;,fn:function say()&#123;console.log(this.name)&#125;&#125;删除fn</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    context =(context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) ? <span class="built_in">window</span> : context;</span><br><span class="line">    context.fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">arguments</span>[<span class="number">1</span>] ? context.fn(...arguments[<span class="number">1</span>]) : context.fn()</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    context =(context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) ? <span class="built_in">window</span> : context</span><br><span class="line">    <span class="keyword">let</span> o = <span class="built_in">Object</span>.create(context)</span><br><span class="line">    o.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> result= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">        o.fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手写promise-all"><a href="#手写promise-all" class="headerlink" title="手写promise.all"></a>手写promise.all</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  Promise函数对象的all方法</span></span><br><span class="line"><span class="comment">  返回一个promise, 只有当所有proimse都成功时才成功, 否则只要有一个失败的就失败</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用来保存所有成功value的数组</span></span><br><span class="line">    <span class="keyword">const</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(arr.length) </span><br><span class="line">    <span class="comment">// 用来保存成功promise的数量</span></span><br><span class="line">    <span class="keyword">let</span> resolvedCount = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 返回一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 遍历promises获取每个promise的结果</span></span><br><span class="line">      arr.forEach(<span class="function">(<span class="params">p, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">          value =&gt; &#123;</span><br><span class="line">            resolvedCount++ <span class="comment">// 成功的数量加1</span></span><br><span class="line">            <span class="comment">// p成功, 将成功的vlaue保存vlaues</span></span><br><span class="line">            <span class="comment">// values.push(value)</span></span><br><span class="line">            values[index] = value</span><br><span class="line">            <span class="comment">// 如果全部成功了, 将return的promise改变成功</span></span><br><span class="line">            <span class="keyword">if</span> (resolvedCount===promises.length) &#123;</span><br><span class="line">              resolve(values)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          reason =&gt; &#123; <span class="comment">// 只要一个失败了, return的promise就失败</span></span><br><span class="line">            reject(reason)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="手写promise-race"><a href="#手写promise-race" class="headerlink" title="手写promise.race"></a>手写promise.race</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Promise.race()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     Promise函数对象的race方法</span></span><br><span class="line"><span class="comment">     返回一个promise对象，状态由第一个完成的promise决定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Promise</span>.myRace = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        arr.forEach(<span class="function">(<span class="params">p,index</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">            value=&gt;&#123;</span><br><span class="line">                    resolve(value)</span><br><span class="line">                &#125;,</span><br><span class="line">                reason=&gt;&#123;</span><br><span class="line">                    reject(reason);</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;ok1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;resolve(<span class="string">&#x27;ok2&#x27;</span>)&#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;ok3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.myRace([p2,p1,p3]).then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="手写promise-resolveDelay"><a href="#手写promise-resolveDelay" class="headerlink" title="手写promise.resolveDelay"></a>手写promise.resolveDelay</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolveDelay = <span class="function"><span class="keyword">function</span> (<span class="params">value, time</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123; </span><br><span class="line">              <span class="comment">// 如果 value 是一个 promise, 取这个 promise 的结果值作为返回的 promise 的结果值 </span></span><br><span class="line">                value.then(resolve, reject) </span><br><span class="line">                <span class="comment">// 如果 value 成功, 调用 resolve(val), 如果 value 失败了, 调用reject(reason) </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                resolve(value) </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;, time); </span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手写Promise-rejectDelay"><a href="#手写Promise-rejectDelay" class="headerlink" title="手写Promise.rejectDelay"></a>手写Promise.rejectDelay</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.rejectDelay = <span class="function"><span class="keyword">function</span> (<span class="params">reason, time</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">            reject(reason);</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手写LazyMan函数"><a href="#手写LazyMan函数" class="headerlink" title="手写LazyMan函数"></a>手写LazyMan函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现：lazyman(&quot;hack&quot;).sleep(10).eat(&quot;food&quot;);</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Hi，你好Hack</span></span><br><span class="line"><span class="comment">wait(10)...</span></span><br><span class="line"><span class="comment">eat food;</span></span><br><span class="line"><span class="comment">注释：其中eat()和sleep()没有顺序关系，可以且可以多次调用</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">const</span> lazyman = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">`Hi,你好<span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     executeChain: <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">     eat,</span><br><span class="line">     sleep</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.executeChain = <span class="built_in">this</span>.executeChain.then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`eat <span class="subst">$&#123;food&#125;</span>`</span>);</span><br><span class="line">     resolve();</span><br><span class="line">   &#125;))</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> sleep = <span class="function"><span class="keyword">function</span> (<span class="params">time</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.executeChain = <span class="built_in">this</span>.executeChain.then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       resolve();</span><br><span class="line">     &#125;, time)</span><br><span class="line">   &#125;))</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="Promise超时控制"><a href="#Promise超时控制" class="headerlink" title="Promise超时控制"></a>Promise超时控制</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原理其实很简单，就是利用Promise.race，我们先创建一个Promise，里面用setTimeout进行处理，然后将新创建的Promise与我们之前使用的Promise&quot;比赛&quot;一下。</span></span><br><span class="line"><span class="keyword">let</span> rest=<span class="function"><span class="keyword">function</span>(<span class="params">_data=<span class="number">1000</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.race([</span><br><span class="line">upload(),</span><br><span class="line">uploadTimeout(_data)</span><br><span class="line">]).then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;请求进行中...&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">let</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&quot;https://www.baidu.com&quot;</span>);</span><br><span class="line">xhr.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.readyState==<span class="number">4</span> &amp;&amp; (xhr.status&gt;=<span class="number">200</span> &amp;&amp; xhr.status&lt;<span class="number">300</span>))&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">resolve(<span class="string">&quot;请求成功！&quot;</span>)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">reject(xhr.status)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.onerror=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">reject(<span class="string">&#x27;请求失败了...&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadTimeout</span>(<span class="params">times</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">reject(<span class="string">&#x27;请求超时，请重试&#x27;</span>);</span><br><span class="line">&#125;,times)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise取消重复请求"><a href="#Promise取消重复请求" class="headerlink" title="Promise取消重复请求"></a>Promise取消重复请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CancelablePromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.pendingPromise = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包装一个请求并取消重复请求</span></span><br><span class="line">CancelablePromise.prototype.request = <span class="function"><span class="keyword">function</span> (<span class="params">requestFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.pendingPromise) &#123;</span><br><span class="line">    <span class="built_in">this</span>.cancel(<span class="string">&quot;取消重复请求&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> _promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> (<span class="built_in">this</span>.reject = reject));</span><br><span class="line">  <span class="built_in">this</span>.pendingPromise = <span class="built_in">Promise</span>.race([requestFn(), _promise]);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.pendingPromise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消当前请求</span></span><br><span class="line">CancelablePromise.prototype.cancel = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(reason));</span><br><span class="line">  <span class="built_in">this</span>.pendingPromise = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------下面是测试用例------------</span></span><br><span class="line"><span class="comment">// 模拟一个异步请求函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRequest</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cancelPromise = <span class="keyword">new</span> CancelablePromise();</span><br><span class="line"><span class="comment">// 前四个请求将被自动取消</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  cancelPromise</span><br><span class="line">    .request(createRequest(<span class="number">1000</span>))</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// 最后一个 done</span></span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.error(err)); <span class="comment">// 前四个 error: 取消重复请求</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置一个定时器等3s，让前面的请求都处理完再继续测试</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 手动取消最后一个请求</span></span><br><span class="line">  cancelPromise</span><br><span class="line">    .request(createRequest(<span class="number">1000</span>))</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.error(err)); <span class="comment">// error:手动取消</span></span><br><span class="line">  cancelPromise.cancel(<span class="string">&quot;手动取消&quot;</span>);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个定时器等4s，让前面的请求都处理完再继续测试</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  cancelPromise</span><br><span class="line">    .request(createRequest(<span class="number">1000</span>))</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// done</span></span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.error(err));</span><br><span class="line">&#125;, <span class="number">4000</span>);</span><br></pre></td></tr></table></figure><h4 id="Promise并发控制"><a href="#Promise并发控制" class="headerlink" title="Promise并发控制"></a>Promise并发控制</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发请求限制并发数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;()=&gt;Promise&lt;any&gt; []&#125;</span> </span>requestFns 并发请求函数数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;numer&#125;</span> </span>limit 限制最大并发数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concurrentRequest</span>(<span class="params">requestFns, limit</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recursion</span>(<span class="params">requestFn</span>) </span>&#123;</span><br><span class="line">    requestFn().finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (_requestFns.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        recursion(_requestFns.pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> _requestFns = [...requestFns];</span><br><span class="line">  <span class="comment">// 限制最大并发量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; limit &amp;&amp; _requestFns.length &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">    recursion(_requestFns.pop());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------下面是测试用例------------</span></span><br><span class="line"><span class="comment">// 模拟一个异步请求函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRequest</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> requestFns = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  requestFns.push(createRequest(<span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line">concurrentRequest(requestFns, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="Promise全局loading态"><a href="#Promise全局loading态" class="headerlink" title="Promise全局loading态"></a>Promise全局loading态</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseManager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.pendingPromise = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="built_in">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给每个pending态的promise生成一个身份标志</span></span><br><span class="line">PromiseManager.prototype.generateKey = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()&#125;</span>-<span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">1000</span>)&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line">PromiseManager.prototype.push = <span class="function"><span class="keyword">function</span> (<span class="params">...requestFns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> requestFn <span class="keyword">of</span> requestFns) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="built_in">this</span>.generateKey();</span><br><span class="line">    <span class="built_in">this</span>.pendingPromise.add(key);</span><br><span class="line">    requestFn().finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.pendingPromise.delete(key);</span><br><span class="line">      <span class="built_in">this</span>.loading = <span class="built_in">this</span>.pendingPromise.size !== <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ----------下面是测试用例------------</span></span><br><span class="line"><span class="comment">// 模拟一个异步请求函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRequest</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> manager = <span class="keyword">new</span> PromiseManager();</span><br><span class="line"><span class="comment">// 增加多个请求</span></span><br><span class="line">manager.push(createRequest(<span class="number">1000</span>));</span><br><span class="line">manager.push(createRequest(<span class="number">4500</span>));</span><br><span class="line"><span class="comment">// 每秒轮询loading态，直到loading为false</span></span><br><span class="line"><span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(manager.loading);</span><br><span class="line">  <span class="keyword">if</span> (!manager.loading) <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h4 id="手写柯里化"><a href="#手写柯里化" class="headerlink" title="手写柯里化"></a>手写柯里化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Curry</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            arr = arr.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="literal">null</span>,arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = Curry(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total,item</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total+item;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> s= fn(<span class="number">1</span>)(<span class="number">2</span>)()</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br></pre></td></tr></table></figure><h4 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：左侧float:left;右侧margin-left;</span></span><br><span class="line"><span class="comment">//因为块级元素有流体特性，即默认会填充满外部容器，所以只需要设置margin，不需要设置width就可以让content填满剩余的部分。</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;left&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;right&lt;/div&gt;</span><br><span class="line">body,div&#123;</span><br><span class="line">    padding: <span class="number">0</span>;</span><br><span class="line">    margin:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.left,.right&#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background-color:skyblue;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    margin-left: 200px;</span><br><span class="line">    background-color: greenyellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：左侧float:left; 右侧overflow:hidden；</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;left&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;right&lt;/div&gt;</span><br><span class="line">body,div&#123;</span><br><span class="line">    padding: <span class="number">0</span>;</span><br><span class="line">    margin:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.left,.right&#123;</span><br><span class="line">    height:200px;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    float:left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background-color:skyblue;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">    background-color: greenyellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式三</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;wrap&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;left&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;right&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">body,div&#123;</span><br><span class="line">    padding: <span class="number">0</span>;</span><br><span class="line">    margin:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.wrap&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.left,.right&#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background-color:skyblue;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    flex: <span class="number">1</span>; </span><br><span class="line">    background-color: greenyellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//flex:1</span></span><br><span class="line">flex-grow : <span class="number">1</span>; <span class="comment">// 这意味着div将以与窗口大小相同的比例增长</span></span><br><span class="line">flex-shrink : <span class="number">1</span>; <span class="comment">// 这意味着div将以与窗口大小相同的比例缩小</span></span><br><span class="line">flex-basis : <span class="number">0</span>; <span class="comment">// 给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小。等于0就是均分的意思；</span></span><br></pre></td></tr></table></figure><h4 id="双飞翼布局（三栏布局）"><a href="#双飞翼布局（三栏布局）" class="headerlink" title="双飞翼布局（三栏布局）"></a>双飞翼布局（三栏布局）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="comment">/*给内部div添加margin，把内容放到中间栏，其实整个背景还是100%*/</span></span><br><span class="line">#inside &#123;</span><br><span class="line">    margin: <span class="number">0</span> 200px <span class="number">0</span> 180px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">#center &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: <span class="number">100</span>%;</span><br><span class="line">    <span class="comment">/*左栏上去到第一行*/</span></span><br><span class="line">    height: 100px;</span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br><span class="line">#left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 180px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-left: -<span class="number">100</span>%;</span><br><span class="line">    background: #0c9;</span><br><span class="line">&#125;</span><br><span class="line">#right &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-left: -200px;</span><br><span class="line">    background: #0c9;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;inside&quot;</span>&gt;middle&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;left&quot;</span>&gt;left&lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;right&quot;</span>&gt;right&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="圣杯布局（三栏布局）"><a href="#圣杯布局（三栏布局）" class="headerlink" title="圣杯布局（三栏布局）"></a>圣杯布局（三栏布局）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">#bd&#123;</span><br><span class="line">    padding: <span class="number">0</span> 200px <span class="number">0</span> 180px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">#middle&#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: <span class="number">100</span>%;</span><br><span class="line">    height: 500px;</span><br><span class="line">    background:blue;</span><br><span class="line">&#125;</span><br><span class="line">#left&#123;</span><br><span class="line">    float:left;</span><br><span class="line">    width:180px;</span><br><span class="line">    height:500px;</span><br><span class="line">    margin-left:-<span class="number">100</span>%;</span><br><span class="line">    background: #0c9;</span><br><span class="line">    position: relative;</span><br><span class="line">    left: -180px;</span><br><span class="line">&#125;</span><br><span class="line">#right&#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 500px;</span><br><span class="line">    margin-left: -200px;</span><br><span class="line">    background: #0c9;</span><br><span class="line">    position: relative;</span><br><span class="line">    right: -200px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;bd&quot;</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;middle&quot;</span>&gt;middle&lt;/div&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;left&quot;</span>&gt;left&lt;/div&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;right&quot;</span>&gt;right&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="排序及查找算法"><a href="#排序及查找算法" class="headerlink" title="排序及查找算法"></a>排序及查找算法</h3><h4 id="快速排序O-nlogn"><a href="#快速排序O-nlogn" class="headerlink" title="快速排序O(nlogn)"></a>快速排序O(nlogn)</h4><p>不稳定的排序</p><p>思想：划定两个区域，-1位置表示小于num的区域，数组长度+1的位置表示大于num的区域，然后cur指针从0位置开始遍历。如果小于num，把<strong>小于区域的下一个位置</strong>和cur位置交换，交换完之后小于等于区域扩大一个位置cur也++。如果等于num，cur直接+1其他不变。如果大于num,把大于区域的前一个位置和cur交换，more前移动一个位置，cur不变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr,L=<span class="number">0</span>,R=arr.length-<span class="number">1</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&lt;R)&#123;</span><br><span class="line"><span class="keyword">let</span> p = partition(arr,L,R);</span><br><span class="line">quickSort(arr,L,p[<span class="number">0</span>]);</span><br><span class="line">quickSort(arr,p[<span class="number">1</span>],R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr,L,R</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> less = L-<span class="number">1</span>,more = R+<span class="number">1</span>,cur = L;</span><br><span class="line"><span class="keyword">let</span> num = arr[R];</span><br><span class="line"><span class="keyword">while</span>(cur&lt;more)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[cur]&lt;num)&#123;</span><br><span class="line">swap(arr,++less,cur++);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[cur]&gt;num)&#123;</span><br><span class="line">swap(arr,cur,--more);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cur++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> [less,more];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr,i,j</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序O-nlogn"><a href="#归并排序O-nlogn" class="headerlink" title="归并排序O(nlogn)"></a>归并排序O(nlogn)</h4><p>可以实现稳定的排序</p><p>思想：使用递归先对数组进行无限分割，然后再对分割出来的两块进行合并；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr,l,r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((l+r)/<span class="number">2</span>);</span><br><span class="line">    mergeSort(arr,l,mid);</span><br><span class="line">    mergeSort(arr,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">let</span> temp=[];</span><br><span class="line">    <span class="keyword">let</span> i = l;</span><br><span class="line">    <span class="keyword">let</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;=arr[j])&#123;</span><br><span class="line">            temp.push(arr[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp.push(arr[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        temp.push(arr[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)&#123;</span><br><span class="line">        temp.push(arr[j]);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++)&#123;</span><br><span class="line">        arr[i] = temp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆排序O-nlogn"><a href="#堆排序O-nlogn" class="headerlink" title="堆排序O(nlogn)"></a>堆排序O(nlogn)</h4><p>不稳定的排序</p><p>思想：</p><ol><li>建立大根堆：对于每个小二叉树，通过其子节点的(n-1)/2找到其父节点的位置，当父节点小于子节点时交换位置，依次循环。</li><li>然后将堆顶元素和树的最后一个叶子节点进行交换，此时最后一个叶子节点上的值为当前树中的最大值，然后将除开此叶子节点的树重复1-2的过程。</li></ol><h4 id="冒泡排序O-n-2"><a href="#冒泡排序O-n-2" class="headerlink" title="冒泡排序O(n^2)"></a>冒泡排序O(n^2)</h4><p>可以实现稳定的排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length === <span class="number">0</span> ) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=arr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">let</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入排序O-n-2"><a href="#插入排序O-n-2" class="headerlink" title="插入排序O(n^2)"></a>插入排序O(n^2)</h4><p>可以实现稳定的排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length===<span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">let</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择排序O-n-2"><a href="#选择排序O-n-2" class="headerlink" title="选择排序O(n^2)"></a>选择排序O(n^2)</h4><p>不稳定的排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length===<span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">let</span> min,temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        min=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;arr.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[min]&gt;arr[j])&#123;</span><br><span class="line">              min =j;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[min];</span><br><span class="line">        arr[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">arr,data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = arr.length-<span class="number">1</span>, <span class="comment">//最大值</span></span><br><span class="line">        min = <span class="number">0</span>;  <span class="comment">//最小值</span></span><br><span class="line">    <span class="keyword">while</span>(min&lt;=max)&#123;</span><br><span class="line">        <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor((max+min)/<span class="number">2</span>); <span class="comment">//中间值</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;data)&#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&gt;data)&#123;</span><br><span class="line">            max = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//没找到返回false</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h3><h4 id="先序遍历（递归）"><a href="#先序遍历（递归）" class="headerlink" title="先序遍历（递归）"></a>先序遍历（递归）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        res.push(root.val);</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="先序遍历（非递归）"><a href="#先序遍历（非递归）" class="headerlink" title="先序遍历（非递归）"></a>先序遍历（非递归）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">while</span>(root || stack.length!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            res.push(root.val);</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="中序遍历（递归）"><a href="#中序遍历（递归）" class="headerlink" title="中序遍历（递归）"></a>中序遍历（递归）</h4><p>按先序类推</p><h4 id="中序遍历（非递归）"><a href="#中序遍历（非递归）" class="headerlink" title="中序遍历（非递归）"></a>中序遍历（非递归）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">while</span>(root || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        res.push(root.val);</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后续遍历（递归）"><a href="#后续遍历（递归）" class="headerlink" title="后续遍历（递归）"></a>后续遍历（递归）</h4><p>按先序类推</p><h4 id="后续遍历（非递归）"><a href="#后续遍历（非递归）" class="headerlink" title="后续遍历（非递归）"></a>后续遍历（非递归）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">while</span>(root || stack.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            res.unshift(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res = [],stack=[root];</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> len = stack.length;</span><br><span class="line">        res[i] = [];</span><br><span class="line">        <span class="keyword">while</span>(len)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur = stack.shift();</span><br><span class="line">            res[i].push(cur.val)</span><br><span class="line">            <span class="keyword">if</span>(cur.left) stack.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right) stack.push(cur.right);</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="js实现大数相加"><a href="#js实现大数相加" class="headerlink" title="js实现大数相加"></a>js实现大数相加</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如：3473243899994324123+142325235</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addString</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.length&lt;b.length)&#123;</span><br><span class="line">        a = a.padStart(b.length,<span class="string">&quot;0&quot;</span>)  <span class="comment">//padStart从头开始补全，padEnd从尾部开始补全</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.length&gt;b.length)&#123;</span><br><span class="line">        b = b.padStart(a.length,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> addOne = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=a.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="built_in">Number</span>(a[i])+<span class="built_in">Number</span>(b[i])+addOne;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;<span class="number">9</span>)&#123;</span><br><span class="line">            res.unshift(sum-<span class="number">10</span>);</span><br><span class="line">            addOne = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.unshift(sum);</span><br><span class="line">            addOne = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(addOne)&#123;</span><br><span class="line">        res.unshift(addOne);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断表达式是否闭合"><a href="#判断表达式是否闭合" class="headerlink" title="判断表达式是否闭合"></a>判断表达式是否闭合</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如：</span></span><br><span class="line"><span class="comment">输入：&#123;[]&#125;&#123;</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">    如：</span></span><br><span class="line"><span class="comment">    输入：&#123;[]&#125;</span></span><br><span class="line"><span class="comment">    输出：true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">while</span>(arr.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = arr.shift();</span><br><span class="line">        <span class="keyword">if</span>(c === <span class="string">&quot;(&quot;</span> || c===<span class="string">&quot;[&quot;</span> || c=== <span class="string">&quot;&#123;&quot;</span>)&#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c===<span class="string">&quot;)&quot;</span> || c===<span class="string">&quot;]&quot;</span> || c=== <span class="string">&quot;&#125;&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(test(stack.pop()) != c)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(str === <span class="string">&quot;(&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(str === <span class="string">&quot;[&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(str === <span class="string">&quot;&#123;&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack.length ===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    本篇文章用于总结自己在前端面试的过程中所遇到的手撕题和前端常考的算法题，其主要包括题目与Javascript实现的解法。一部分题目的代码由自己编写实现，还有一部分题目的代码来源互联网，所有代码都经过自己的运行验证，请放心食用。后续还会持续更新。。。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>可视化学术期刊汇总</title>
    <link href="http://example.com/2021/05/04/visual_journal_summary/"/>
    <id>http://example.com/2021/05/04/visual_journal_summary/</id>
    <published>2021-05-04T03:58:48.000Z</published>
    <updated>2024-05-02T05:11:43.491Z</updated>
    
    <content type="html"><![CDATA[<p>​    整理一些自己知道的可视化学术期刊，信息主要来源于《中国计算机学会推荐国际学术会议和期刊目录(2019 年)》，从分类中摘取出本人所知的可视化期刊。后续将继续完善。</p><span id="more"></span><h4 id="A类期刊"><a href="#A类期刊" class="headerlink" title="A类期刊"></a>A类期刊</h4><table><thead><tr><th align="center">序号</th><th align="center">刊物简称</th><th align="center">刊物名称</th><th align="center">出版社</th><th align="center">网址</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">TVCG</td><td align="center">IEEE Transactions on Visualization and Computer Graphics</td><td align="center">IEEE</td><td align="center"><a href="http://dblp.uni-trier.de/db/journals/tvcg/">http://dblp.uni-trier.de/db/journals/tvcg/</a></td></tr><tr><td align="center">2</td><td align="center">SIGGRAPH</td><td align="center">ACM SIGGRAPH Annual Conference</td><td align="center">ACM</td><td align="center"><a href="http://dblp.uni-trier.de/db/conf/siggraph/index.html">http://dblp.uni-trier.de/db/conf/siggraph/index.html</a></td></tr><tr><td align="center">3</td><td align="center">IEEE VIS</td><td align="center">IEEE Visualization Conference</td><td align="center">IEEE</td><td align="center"><a href="http://dblp.uni-trier.de/db/conf/visualization/index.html">http://dblp.uni-trier.de/db/conf/visualization/index.html</a></td></tr><tr><td align="center">4</td><td align="center">TOCHI</td><td align="center">ACM Transactions on Computer-Human Interaction</td><td align="center">ACM</td><td align="center"><a href="http://dblp.uni-trier.de/db/journals/tochi/">http://dblp.uni-trier.de/db/journals/tochi/</a></td></tr><tr><td align="center">5</td><td align="center">HCI</td><td align="center">Human Computer Interaction</td><td align="center">Taylor &amp; Francis</td><td align="center"><a href="http://dblp.uni-trier.de/db/journals/hhci/">http://dblp.uni-trier.de/db/journals/hhci/</a></td></tr><tr><td align="center">6</td><td align="center">CHI</td><td align="center">ACM Conference on Human Factors in Computing Systems</td><td align="center">ACM</td><td align="center"><a href="http://dblp.uni-trier.de/db/conf/chi">http://dblp.uni-trier.de/db/conf/chi</a></td></tr></tbody></table><h4 id="B类期刊"><a href="#B类期刊" class="headerlink" title="B类期刊"></a>B类期刊</h4><table><thead><tr><th align="center">序号</th><th align="center">刊物简称</th><th align="center">刊物名称</th><th align="center">出版社</th><th align="center">网址</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">EuroVis</td><td align="center">Eurographics Conference on Visualization</td><td align="center">ACM</td><td align="center"><a href="http://dblp.uni-trier.de/db/conf/vissym/">http://dblp.uni-trier.de/db/conf/vissym/</a></td></tr></tbody></table><h4 id="C类期刊"><a href="#C类期刊" class="headerlink" title="C类期刊"></a>C类期刊</h4><table><thead><tr><th align="center">序号</th><th align="center">刊物简称</th><th align="center">刊物名称</th><th align="center">出版社</th><th align="center">网址</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">JVCIR</td><td align="center">Journal of Visual Communication and Image Representation</td><td align="center">Elsevier</td><td align="center"><a href="http://dblp.uni-trier.de/db/journals/jvcir/">http://dblp.uni-trier.de/db/journals/jvcir/</a></td></tr><tr><td align="center">2</td><td align="center">PacificVis</td><td align="center">IEEE Pacific Visualization Symposium</td><td align="center">IEEE</td><td align="center"><a href="http://dblp.uni-trier.de/db/conf/apvis/">http://dblp.uni-trier.de/db/conf/apvis/</a></td></tr></tbody></table><h4 id="其他期刊"><a href="#其他期刊" class="headerlink" title="其他期刊"></a>其他期刊</h4><ul><li>ChinaVIS<ul><li>中文《计算机辅助设计与图形学学报》</li><li>英文《Journal of Visualization》</li></ul></li></ul><p><strong>参考文献</strong>：中国计算机学会推荐国际学术会议和期刊目录(2019 年)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    整理一些自己知道的可视化学术期刊，信息主要来源于《中国计算机学会推荐国际学术会议和期刊目录(2019 年)》，从分类中摘取出本人所知的可视化期刊。后续将继续完善。&lt;/p&gt;</summary>
    
    
    
    <category term="可视化" scheme="http://example.com/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
    <category term="可视化" scheme="http://example.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="论文" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>论文概览</title>
    <link href="http://example.com/2021/05/04/overview_of_paper/"/>
    <id>http://example.com/2021/05/04/overview_of_paper/</id>
    <published>2021-05-04T03:56:53.000Z</published>
    <updated>2024-05-02T05:11:46.087Z</updated>
    
    <content type="html"><![CDATA[<p>​    在阅读论文时记录的一些论文信息和对该论文的简单介绍，记录这些可方便我在需要时快速查找和定位。以下主要记录的是可视化相关论文和迁移学习相关论文的简介。后续将继续完善。</p><span id="more"></span><h3 id="可视化相关"><a href="#可视化相关" class="headerlink" title="可视化相关"></a>可视化相关</h3><ul><li>2021 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=167n0gf0y90y0610033y0ce0aw359840&site=xueshu_se&hitarticle=1">TrammelGraph: visual graph abstraction for comparison</a> 【Journal of Visualization】<ul><li>整理中…..</li></ul></li><li>2020.11.25  <a href="http://www.shixialiu.com/publications/survey-cvm/paper.pdf">A Survey of Visual Analytics Techniques for Machine Learning</a><ul><li>该综述归纳整理了2010-2020年的可视化相关论文及2010年以前的少数可视化相关论文，共259篇；</li><li>论文范围包括：InfoVis，VAST，Vis（后来的SciVis）,EuroVis，PacificVis，IEEE TVCG，CGF和CG&A;</li></ul></li><li>2020.09.15  <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=16670240bn0c0xe0wy6f04r08j753432&site=xueshu_se&hitarticle=1">A Visual Analytics Framework for Explaining and Diagnosing Transfer Learning</a> 【TVCG】<ul><li>整理中…</li></ul></li><li>2019.08.01 <a href="https://ieeexplore.ieee.org/document/8827593">Ablate, Variate, and Contemplate: Visual Analytics for Discovering Neural Architectures.</a> 【TVCG】<ul><li>提出了快速探索模型结构和参数，或重新映射的一个可视化的分析工具，使模型建设者能够发现一个深入的学习模型，通过ablations, variations, or handcrafted templates创建新模型。</li></ul></li><li>2018.12.05 <a href="https://ieeexplore.ieee.org/document/8611178">Exploring the Sensitivity of Choropleths under Attribute Uncertainty</a> 【TVCG】<ul><li>提出了一个可视化分析系统，提高了我们对属性不确定性对数据可视化和统计分析的影响的理解。</li><li>通过系统设计的三种可视化视图及案列，来说明地理分析中属性不确定性的影响。</li></ul></li><li>2018.04.01 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=5c50030c63a9a4718e4923d4aa552d7e&site=xueshu_se&hitarticle=1">Visualizing Deep Neural Networks for Text Analytics</a> 【IEEE】<ul><li>整理中…</li></ul></li><li>2017 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=4740f0caa77d0d2302eef4020fe2d3de&site=xueshu_se">Towards Better Analysis of Deep Convolutional Neural Networks</a> 【TVCG】<ul><li>整理中…</li></ul></li><li>2015.10.25 <a href="https://ieeexplore.ieee.org/document/7194832">Task-Driven Comparison of Topic Models</a> 【TVCG】<ul><li>主题建模是一种从大量文本中统计提取主题内容的方法，用于文本分析中的各种任务。</li><li>本文探讨了以任务为中心的主题模型比较。主要分为理解主题、理解相似性和理解变化，并提供了一些可视化的技术来促进这些任务，如（buddy plots）。它结合了颜色和位置编码，允许分析人员随时查看文档相似性的变化。</li></ul></li><li>2014.11.09 <a href="https://ieeexplore.ieee.org/document/6876047/references#references">INFUSE: Interactive Feature Selection for Predictive Modeling of High Dimensional Data</a> 【TVCG】<ul><li>许多特征选择算法决定使用哪一个时，算法输出通常不适合用户解释。</li><li>旨在帮助分析人员<strong>了解</strong>预测特征在特征选择算法、交叉验证折叠和分类器中的排名。</li></ul></li><li>2011.10.14 <a href="https://ieeexplore.ieee.org/document/6065026/">DICON: Interactive Visual Analysis of Multidimensional Clusters</a> 【TVCG】<ul><li>DICON是一种基于动态图标的可视化技术，可以帮助用户理解、评估和调整复杂的多维聚类。它提供了描述簇的质量及其多个属性的视觉线索，并且可以嵌入到多种可视化中，如地图、散点图和图形。</li><li>用于复杂的多维聚类分析。</li></ul></li></ul><h3 id="迁移学习相关"><a href="#迁移学习相关" class="headerlink" title="迁移学习相关"></a>迁移学习相关</h3><ul><li>2020.08 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=1b320cs0q47c08u04y1m0m408x148126&site=xueshu_se&hitarticle=1">LEEP: A New Measure to Evaluate Transferability of Learned Representations</a> 【ICML】<ul><li>一种用于评估可迁移性的新方法；</li><li>该方法可以预测迁移学习方法的性能和收敛速度;</li><li>是第一个开发元迁移学习的可迁移性测量的工作；</li><li>对于小数据或不平衡数据也同样适用；</li></ul></li><li>2019.01 ICIP <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=1r6y0ty0bf4p0jy0np2e0cp058458877&site=xueshu_se&hitarticle=1">An information-theoretic approach to transferability in task transfer learning</a> 【IEEE】<ul><li>一种用于评估机器模型可迁移性的方法；</li><li>提出一种基于统计和信息理论的特征迁移能力度量标准——H-score；</li><li>使用该方法可以直接通过预训练模型和目标任务训练数据进行计算，无须在目标任务上训练模型；</li><li>适用于迁移学习中预训练模型选择问题；</li></ul></li><li>2018.08 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=a41fa8702b71de237b12337fec157b8d&site=xueshu_se&hitarticle=1">A Survey on Deep Transfer Learning</a> 【ICANN】<ul><li>给出了深度迁移学习的定义</li><li>通过收集整理近几年相关文献，将深度迁移学习分为四类，并具体对每一类进展进行了描述</li><li>适用于对深度迁移学习进一步了解</li></ul></li><li>2014.11 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=16510470du540gn0n15q0820xw060270&site=xueshu_se&hitarticle=1">How transferable are features in deep neural networks?</a> 【NIPS】<ul><li>论文深度神经网络中奇怪现象入手————前面几层都学习到的是通用的特征（general feature），随着网络的加深，后面的网络更偏重于学习特定的特征（specific feature），通篇以实验为主，提出并解决了在深度神经网络特征迁移中一些问题</li><li>深度神经网络特征迁移的程度如何受到高层特定化特征(specialization of higher layer features)和层之间的相互适应性(co-adapted layers)的影响</li><li>说明特征可转移性与任务间相关性正相关</li><li>指出通过可转移特征初始化网络能有效提高泛化性能并且由于随机权重</li><li>此篇论文对理解神经网络以及深度迁移学习都有着非常重要的意义，推荐阅读</li></ul></li></ul><h3 id="前端-浏览器相关"><a href="#前端-浏览器相关" class="headerlink" title="前端/浏览器相关"></a>前端/浏览器相关</h3><ul><li>2018 <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=72090e5c4bd4bdb81083c1a8ccf196f4&site=xueshu_se&hitarticle=1">ECharts: A declarative framework for rapid construction of web-based visualization</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    在阅读论文时记录的一些论文信息和对该论文的简单介绍，记录这些可方便我在需要时快速查找和定位。以下主要记录的是可视化相关论文和迁移学习相关论文的简介。后续将继续完善。&lt;/p&gt;</summary>
    
    
    
    <category term="论文概览" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87%E6%A6%82%E8%A7%88/"/>
    
    
    <category term="可视化" scheme="http://example.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="论文" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="迁移学习" scheme="http://example.com/tags/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>高维数据可视化</title>
    <link href="http://example.com/2021/05/03/high_dimensional_data_visualization/"/>
    <id>http://example.com/2021/05/03/high_dimensional_data_visualization/</id>
    <published>2021-05-03T14:46:19.000Z</published>
    <updated>2024-05-02T05:11:33.429Z</updated>
    
    <content type="html"><![CDATA[<p>​    高维数据可视化记录了学习《2020浙大可视化暑期班》的相关笔记。主要内容包括对数据维度的介绍、高维数据可视化的方法等。</p><span id="more"></span><h3 id="数据维度-Data-Dimension"><a href="#数据维度-Data-Dimension" class="headerlink" title="数据维度(Data Dimension)"></a>数据维度(Data Dimension)</h3><h4 id="一维-1-D"><a href="#一维-1-D" class="headerlink" title="一维(1-D)"></a>一维(1-D)</h4><p><img src="/2021/05/03/high_dimensional_data_visualization/1620053725112.png" alt="1620053725112"></p><h4 id="二维-2-D"><a href="#二维-2-D" class="headerlink" title="二维(2-D)"></a>二维(2-D)</h4><p><img src="/2021/05/03/high_dimensional_data_visualization/1620053817171.png" alt="1620053817171"></p><h4 id="三维-3-D"><a href="#三维-3-D" class="headerlink" title="三维(3-D)"></a>三维(3-D)</h4><p><img src="/2021/05/03/high_dimensional_data_visualization/1620053851999.png" alt="1620053851999"></p><p>对于这种可视化的方法，它并不是一种非常好或者非常妥当的一种方法，作为可视化的专业人员会非常反对使用这种三维的数据可视化。在实际的使用或应用中，会极少的使用这种三维的散点图。因为它让我们用户去认识、感知和读出它的数据的效率是极低的。它会给人们带来非常大的偏差甚至误导， 主要有两点原因：</p><ol><li>由于它是一个三维的空间，所以我们从不同的视角上看过去，能够观察到这种数据的分布或模式是非常的不同的，这就给做数据分析带了极大的不可预测性和不确定性。</li><li>由于在三维的空间，所以不可避免的有数据的遮挡的问题。</li></ol><p>所以，如无必要尽量避免使用这种三维的可视化，除非数据本身是具有这种三维属性的。如飞机的起降数据、基于流场的可视化数据等。</p><h4 id="高维-High-Dimension"><a href="#高维-High-Dimension" class="headerlink" title="高维(High Dimension)"></a>高维(High Dimension)</h4><ul><li><p>对于高维数据如何实现可视化？</p><ol><li><p>通过增加视觉通道，如样式、颜色、大小等，以表达更多的属性信息</p><p><img src="/2021/05/03/high_dimensional_data_visualization/1620053883695.png" alt="1620053883695"></p></li><li><p>多视图协调关联的方法(Multiple coordinated view:present some attributes of objects in a view)</p><p>​    这种方法主要是通过在每一个视图上，分别展现相同数据集的某几个数据的维度，我们可以通过增加视图的方法来支持呈现更多的属性的可视化。下图是一个多视图协调关联的例子：</p></li></ol><p><img src="/2021/05/03/high_dimensional_data_visualization/1620053909829.png" alt="1620053909829"></p><p>   存在的问题：有关研究/心里学表明：太多的视图很容易会造成视觉的混淆，降低分析的效率。所以在进行多视图关联时，我们在视图之间关联的选择上也是要经过慎重的考虑的。因为不同的视图之间有可能会产生相互的干扰，设置不和谐不同意。</p><p>以上两种方法是最常见的两种处理高维数据可视化的方法，在接下来的一小节中进行重点介绍。</p></li></ul><h3 id="高维数据可视化-High-Dimensional-Data-Visualization"><a href="#高维数据可视化-High-Dimensional-Data-Visualization" class="headerlink" title="高维数据可视化(High-Dimensional Data Visualization)"></a>高维数据可视化(High-Dimensional Data Visualization)</h3><p>下面介绍的是几类比较经典的高维数据可视化的方法，以下高维数据可视化的方法可简单分为三大类型：数据的变换、数据的呈现、数据的交互。</p><h4 id="数据的变换"><a href="#数据的变换" class="headerlink" title="数据的变换"></a>数据的变换</h4><ul><li><p>降维(Dimensionality Reduction)</p><p>使用各种线性的或者非线性的变换，把高维的数据通过降维或者投影的方式，从高维的空间变换到低维的空间，从而降低数据的复杂度。原因是由于高维的数据中很有可能会存在大量的冗余，这种大量的冗余很有可能隐藏了重要关系的相关性，隐藏了重要的数据规律。所以通过降维不仅仅可以消除数据的冗余，减少被处理数据的数量，而且可以方便的在低维空间上将数据呈现。因此，该方法广泛的应用于数据可视化、数据挖掘和模式识别等领域。</p><p><img src="/2021/05/03/high_dimensional_data_visualization/1620053940127.png" alt="1620053940127"></p><ol><li><p>线性的方法</p><ul><li><p>Principal Comonent Analysis (PCA)</p><p><img src="/2021/05/03/high_dimensional_data_visualization/1620053965131.png" alt="1620053965131"></p><ol><li><p>如上图所示，对于具有两个属性的数据（一行代表一个属性），首先将每个数据减去它的一个均值。</p></li><li><p>将变化后的数据放到一个坐标系上。</p></li><li><p>在二维的平面当中去选择一个方向，将这五个点都投影到这个方向所在的直线上，用投影后的值来表示原始的记录。</p><p>如何去选择这个方向？我们希望降维后的值要尽可能的分散，而不是聚在一起</p><p><img src="/2021/05/03/high_dimensional_data_visualization/1620053994363.png" alt="1620053994363"></p><p>选择一个方向，这个方向使得投影后的方差值最大。但是当维度多了之后就会出现维度的相关性，所以我们通过两个字段的协方差来表示相关性。</p><p><img src="/2021/05/03/high_dimensional_data_visualization/1620054023121.png" alt="1620054023121"></p></li></ol></li><li><p>Multidimensional Scaling (MDS) 多尺度投影</p><p>通过输入一个原始数据集的矩阵，这个数据集是两两数据之间的相似程度。</p></li></ul></li><li><p>非线性的方法</p><ul><li>ISOMAP</li><li>Local Linear Embedding(LLE)</li></ul></li></ol></li></ul><h4 id="数据的呈现"><a href="#数据的呈现" class="headerlink" title="数据的呈现"></a>数据的呈现</h4><p>通过一些巧妙的数据可视化的布局方法，忠实、直观、生动的展现高维数据。</p><ul><li><p>散点图矩阵(Scatter-plot Matrix)</p><p><img src="/2021/05/03/high_dimensional_data_visualization/1620054048474.png" alt="1620054048474"></p><p>存在的问题：当我们有很多的维度的时候，仅仅用肉眼去发现其中的规律或者模式往往比较困难，为了解决这种问题，有人就使用了一些智能的算法去自动的发现在散点图里面，哪一些散点图是更有意义的。</p><p><img src="/2021/05/03/high_dimensional_data_visualization/1620054081364.png" alt="1620054081364"></p></li><li><p>平行坐标轴(Parallel Coordinates)</p><p><img src="/2021/05/03/high_dimensional_data_visualization/1620054111193.png" alt="1620054111193"></p><p>存在的问题：当我们的数据很多时，往往会形成以下图案，我们从中发现不了它里面有什么关联（如左图），我们可以给每一个折线加一个透明度（如右图）。</p><p><img src="/2021/05/03/high_dimensional_data_visualization/1620054137614.png" alt="1620054137614"></p></li><li><p>基于图标的方式(Glyph-based Methods)</p><ol><li><p>Star Plots(雷达图) </p><blockquote><p>可看做平行坐标轴的一个变种</p></blockquote></li><li><p>Chernoff Faces(脸谱图）</p><p><img src="/2021/05/03/high_dimensional_data_visualization/1620054163274.png" alt="1620054163274"></p></li><li><p>Text+Glyph(将图标嵌入文本之中)</p><p><img src="/2021/05/03/high_dimensional_data_visualization/1620054188553.png" alt="1620054188553"></p></li></ol></li><li><p>Small Multiples(小图标法)</p><p>用一系列的排列非常整齐的图表来做多维数据的可视化，从而方便我们进行对比，其案例主要如下：</p><p><img src="/2021/05/03/high_dimensional_data_visualization/1620054214467.png" alt="1620054214467"></p><p><img src="/2021/05/03/high_dimensional_data_visualization/1620054242206.png" alt="1620054242206"></p></li></ul><h4 id="数据的交互"><a href="#数据的交互" class="headerlink" title="数据的交互"></a>数据的交互</h4><p>通过有效的人机交互的技术，帮助人们交互式的探索和分析高维的数据。</p><ul><li>Iteraction:”Dust &amp; Magnet”<ul><li>使用一个个类似于灰尘的点来代表数据点（Dust-Data points）</li><li>用磁铁来代表数据属性的过滤器（Magnet-Attribute Filters）</li><li>通过不断的抖动磁铁，就会把与这个磁铁相关的属性的灰尘往该磁铁的方向吸引</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    高维数据可视化记录了学习《2020浙大可视化暑期班》的相关笔记。主要内容包括对数据维度的介绍、高维数据可视化的方法等。&lt;/p&gt;</summary>
    
    
    
    <category term="可视化" scheme="http://example.com/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
    <category term="可视化" scheme="http://example.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="浙大可视化暑期班2020" scheme="http://example.com/tags/%E6%B5%99%E5%A4%A7%E5%8F%AF%E8%A7%86%E5%8C%96%E6%9A%91%E6%9C%9F%E7%8F%AD2020/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-2021-04-23</title>
    <link href="http://example.com/2021/04/23/paper_read_2021-04-23/"/>
    <id>http://example.com/2021/04/23/paper_read_2021-04-23/</id>
    <published>2021-04-23T07:48:04.000Z</published>
    <updated>2024-05-02T05:11:51.176Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LEEP: A New Measure to Evaluate Transferability of Learned Representations</p></blockquote><p>​    良好的可迁移性估计有助于理解任务之间的关系，从而选择可迁移性强的任务进行训练，或者为给定的目标任务选择良好的源模型。迁移学习何时有效，何时无效？要进行迁移学习，应该用什么样的任务进行预训练？这些问题对了解和改善迁移学习十分重要。LEEP是一种用于评价学习表征可迁移性的新方法，可帮助我们解决以上遇到的问题。</p><span id="more"></span><h4 id="论文及作者"><a href="#论文及作者" class="headerlink" title="论文及作者"></a>论文及作者</h4><ul><li>该论文于2020年8月发表在37 th ICML会议(ICML是国际人工智能A类会议) </li><li>作者<ul><li>Cuong V. Nguyen（Amazon Web Services）</li><li>Tal Hassner（Facebook AI ）</li></ul></li></ul><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol><li><p>迁移学习何时有效，何时无效？如果你要进行迁移学习，你应该用什么样的任务进行预训练？</p></li><li><p>迁移学习三要素</p><ol><li><p>可迁移性</p><p>本文主要针对可迁移性的评估方法</p></li><li><p>迁移策略</p></li><li><p>迁移方法</p></li></ol></li><li><p>什么是可迁移性的评估？</p><p>是定量估计将一个分类任务中学习到的知识迁移到另一个分类任务有多容易的问题。</p><p>通俗的来讲就是：<br>​    给定一个源任务（由标记数据集或预先训练的模型表示）和一个目标任务（由标记数据集表示），可迁移性估计的目的是开发一个度量（或分数），该度量可以告诉我们，理想情况下，不需要对目标任务进行训练，迁移学习算法如何有效地从从源任务向目标任务中转移知识的。</p></li><li><p>为什么需要可迁移性的评估？</p><p>因为良好的可迁移性估计有助于理解任务之间的关系，从而选择可迁移性强的任务进行训练，或者为给定的目标任务选择良好的源模型。</p></li><li><p>早期的一些可迁移性评估的方法存在哪些问题？</p><ol><li><p>有助于理论分析，但由于不易计算</p></li><li><p>具有对称性，不适合于实际测量可迁移性</p></li><li><p>应用条件过于严格，不适用于一般性</p></li><li><p>度量很难解释</p><p>如：基于H分数的可转移性度量，它涉及到解决Hirschfeld-Gebelein-R’enyi最大相关问题</p></li><li><p>不能用于评估元迁移学习</p></li></ol></li><li><p>迁移学习、元学习和元迁移学习（Meta-transfer learning）</p><p><strong>迁移学习：</strong>利用已经训练好的开源网络模型和其已经在其他大型数据集上训练好的权重参数，将自己的任务数据集在这些迁移过来的网络上进行训练或者微调。</p><p><strong>元学习：</strong>利用以往的知识经验来指导新任务的学习，具有学会学习的能力。</p><p><strong>元迁移学习：</strong>学习从源任务迁移到目标任务的框架</p></li></ol><h4 id="本文工作"><a href="#本文工作" class="headerlink" title="本文工作"></a>本文工作</h4><ol><li><p>本文贡献</p><ul><li>提出了一种新的迁移学习评估方法-数学期望经验预测（LEEP），该方法可以预测迁移学习方法的性能和收敛速度。该方法与其他评价方法相比的优点在于：<ul><li>LEEP评分不需要对目标任务进行训练，从而避免了昂贵的参数优化步骤。</li><li>不仅适用于大目标数据集，而且适用于难以再训练的小型或不平衡的目标数据集。</li><li>可以在一般情况下广泛的应用于现代深层网络。</li></ul></li><li>不仅可以用于评估常规迁移学习机制，还可以用于评估元迁移学习。且是第一个开发元迁移学习的可迁移性测量的工作</li><li>对于小数据或不平衡数据也同样适用</li></ul></li><li><p>方法步骤</p><ol><li><p>计算目标数据集D中的虚拟标签分布θ(xi)</p><p>​    使用源域模型θ去对目标数据集D上的每个xi进行预测，得到源任务的标签集Z的预测分布。把这个分布定义为 θ(xi)，称为：Z上的范畴分布。注意：这个θ(xi)是源域任务标签上的虚拟分布，因为这些标签可能是没有意义的对于用例xi。</p></li><li><p>计算在给定源标签z下的目标标签y的经验条件分布</p><p><img src="/2021/04/23/paper_read_2021-04-23/image-20210423160144643.png" alt="image-20210423160144643"></p><ol><li><p>首先计算所有标签对(y, z) ∈ Y × Z的经验联合分布</p><p><img src="/2021/04/23/paper_read_2021-04-23/image-20210423160251645.png" alt="image-20210423160251645"></p></li><li><p>计算经验边际分布</p><p><img src="/2021/04/23/paper_read_2021-04-23/image-20210423160322501.png" alt="image-20210423160322501"></p></li><li><p>计算经验条件分布</p><p><img src="/2021/04/23/paper_read_2021-04-23/image-20210423160359291.png" alt="image-20210423160359291"></p></li></ol></li><li><p>LEEP度量总是负值，较大的值（即，较小的绝对值）表示更好的可转移性。当目标任务包含更多的类时，LEEP分数往往较小。由于度量的计算瓶颈（上面的步骤1）只需要一次通过目标数据集D的前向传递，因此该度量的计算效率也很高。</p></li></ol></li></ol><h4 id="案列分析"><a href="#案列分析" class="headerlink" title="案列分析"></a>案列分析</h4><ol><li><p>实验1</p><p>使用ResNet18在ImageNet上进行了预训练，使用ResNet20在CIFAR10上进行了预训练，目标任务的训练集和测试集来自CIFAR100数据集中的100类数据的子集。总共构造了200个不同的目标任务。采用两种常用的迁移学习方法进行实验。</p><p><img src="/2021/04/23/paper_read_2021-04-23/image-20210423160709198.png" alt="image-20210423160709198"></p></li><li><p>实验2</p><p>使用FashionMNIST数据集构建目标数据集，目标数据集是从中从中抽取的四个随机类，每个类包含30个随<br>机示例。为了在评估小目标数据集上的LEEP分数时排除噪声，考虑将分数范围划分为五个相等的单元，并平均每个单元中任务的测试精度。</p><p><img src="/2021/04/23/paper_read_2021-04-23/image-20210423160809846.png" alt="image-20210423160809846"></p><p>LEEP分数可以很好的评估可迁移性，即使在小数据也表现良好</p></li><li><p>实验3</p><p><img src="/2021/04/23/paper_read_2021-04-23/image-20210423160853357.png" alt="image-20210423160853357"></p><p>LEEP分数可以很好的评估可迁移性即使对于不平衡的目标数据集也表现良好。</p></li><li><p>实验4</p><ul><li><p>使用ImageNet预训练ResNet18,并使用元数据集训练自适应网络。</p></li><li><p>目标数据集来自CIFAR100，每个目标数据集包含5个随机标签、每个类有50个样例。</p><p><img src="/2021/04/23/paper_read_2021-04-23/image-20210423161002157.png" alt="image-20210423161002157"></p></li><li><p>从LEEP分数预测CNAPs在五个可迁移水平上的平均测试准确率。</p></li><li><p>证明LEEP也可以预测CNAPs（一种元迁移学习的方法）的测试精度。</p></li></ul></li><li><p>实验5</p><ul><li><p>为每个目标任务训练一个参考模型</p><p><img src="/2021/04/23/paper_read_2021-04-23/image-20210423161532916.png" alt="image-20210423161532916"></p></li><li><p>证明了LEEP分数可以预测fine-tune的收敛</p></li></ul></li><li><p>实验6</p><ul><li>将LEEP度量与Tran等人（2019）提出的NCE度量以及Bao等人（2019）提出的H得分进行了比较。</li><li>实验设置：使用实验1、2、3、4中同样的数据集，进行训练。然后分别计算他们的NCE分数和H得分。</li><li>LEEP与另外两种可迁移性评估方法的对比（NCE、H scores）</li></ul></li><li><p>实验7</p><p>LEEP如何指导源模型的选择</p></li></ol><p><img src="/2021/04/23/paper_read_2021-04-23/image-20210423161228179.png" alt="image-20210423161228179"></p><h4 id="文中提到的其他相关方法-可做后续阅读"><a href="#文中提到的其他相关方法-可做后续阅读" class="headerlink" title="文中提到的其他相关方法(可做后续阅读)"></a>文中提到的其他相关方法(可做后续阅读)</h4><ol><li>Tran等人（2019）提出的NCE度量</li><li>Bao等人（2019）提出的H得分</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p>LEEP的作用</p><ol><li>可以用来选择迁移学习的源模型</li><li>可以帮助选择一组具有高度可迁移性的任务进行多任务学习</li><li>可以用于超参数的传递和优化，有助于最大限度地提高对特定数据的训练效果。</li></ol></li><li><p>论文思考</p><p>由于LEEP可以预测迁移学习微调方法的收敛速度，可作为迁移学习可视化方案中的可迁移性评估的理论支持</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;LEEP: A New Measure to Evaluate Transferability of Learned Representations&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​    良好的可迁移性估计有助于理解任务之间的关系，从而选择可迁移性强的任务进行训练，或者为给定的目标任务选择良好的源模型。迁移学习何时有效，何时无效？要进行迁移学习，应该用什么样的任务进行预训练？这些问题对了解和改善迁移学习十分重要。LEEP是一种用于评价学习表征可迁移性的新方法，可帮助我们解决以上遇到的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="论文" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="迁移学习" scheme="http://example.com/tags/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>可视化使用工具总结</title>
    <link href="http://example.com/2021/04/22/visualization_related_tools/"/>
    <id>http://example.com/2021/04/22/visualization_related_tools/</id>
    <published>2021-04-22T13:54:30.000Z</published>
    <updated>2024-05-02T05:11:38.489Z</updated>
    
    <content type="html"><![CDATA[<p>​    可视化使用工具根据其使用的可拓展性（即灵活性）可分为三类：交互式可视化工具、配置式可视化工具、编程式可视化工具。其中他们的可拓展性依次递增，编程式可视化工具可拓展性最好，但同时由于：交互式可视化工具可能仅需要用户掌握软件使用方法；配置式可视化工具需要使用人员具有一定基础编程能力；编程式可视化工具更是需要使用者熟练掌握相应的编程语言。故这三类可视化工具的使用难度也依次递增。其详细信息如下：</p><span id="more"></span><p><img src="/2021/04/22/visualization_related_tools/image-20210406100636328.png" alt="image-20210406100636328"></p><h4 id="交互式可视化工具"><a href="#交互式可视化工具" class="headerlink" title="交互式可视化工具"></a>交互式可视化工具</h4><p>以Power BI &amp; Tableau为例，一般为商业性软件，可方便的绘制图表</p><p><img src="/2021/04/22/visualization_related_tools/image-20210406100808525.png" alt="image-20210406100808525"></p><p>  tableau:商业智能软件，适用于商业报表、数据分析等场景。可以提供简单的图表的创建。</p><p>  将分析和构建可视化图表的过程分为了以下五步:</p><p>  连接数据源——&gt;构建可视化视图———&gt;创建工作表——–&gt;构建仪表盘——–&gt;数据故事</p><p>   一般交互式可视化工具它适用于如用户缺少编程基础、数据是简单的数据、任务需求比较简单和直接，只需要对数据集进行一个简单的了解这类应用场景，以下是一些适用于不同场景的交互式可视化工具：</p><p><img src="/2021/04/22/visualization_related_tools/image-20210406101035688.png" alt="image-20210406101035688"></p><h4 id="配置式可视化工具"><a href="#配置式可视化工具" class="headerlink" title="配置式可视化工具"></a>配置式可视化工具</h4><p>​      例如：Vega Lite、Echarts、Plotly,一般是通过用户传入特定的配置选项来完成既定的可视化形式。其中配置式一般是指用json对象来完成可视化的配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Vega-Lite：在2016年的Infovis上，华盛顿大学的交互实验室在发表的一篇文章中定义了一种交互式的可视化语法Vega Lite。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;data&quot;</span>:&#123;<span class="string">&quot;url&quot;</span>:<span class="string">&quot;data/cars.json&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&quot;mark&quot;</span>:<span class="string">&quot;circle&quot;</span>,</span><br><span class="line">    <span class="string">&quot;select&quot;</span>：&#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;point&quot;</span>,<span class="string">&quot;on&quot;</span>:<span class="string">&quot;mouseover&quot;</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;encoding&quot;</span>:&#123;</span><br><span class="line">         <span class="string">&quot;x&quot;</span>:&#123;<span class="string">&quot;field&quot;</span>:<span class="string">&quot;horsepower&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;quantitative&quot;</span>&#125;,</span><br><span class="line">         <span class="string">&quot;y&quot;</span>:&#123;<span class="string">&quot;field&quot;</span>:<span class="string">&quot;Miles_per_Gallon&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;quantitative&quot;</span>&#125;,</span><br><span class="line">         <span class="string">&quot;color&quot;</span>:[</span><br><span class="line">                &#123;<span class="string">&quot;if&quot;</span>:<span class="string">&quot;id&quot;</span>,<span class="string">&quot;value&quot;</span>:<span class="string">&quot;orange&quot;</span>&#125;</span><br><span class="line">                &#123;<span class="string">&quot;value&quot;</span>:<span class="string">&quot;steeblue&quot;</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>​    到目前为止，Vega-Lite已支持条形图、散点图、河流图、折线图、地图等多种图形，网址：<a href="https://vega.github.io/vega-lite/">https://vega.github.io/vega-lite/</a>.</p><p>echarts :由百度开发的基于js的图表库，可解决一些简单的可是分析需求。（详情请查询echarts官网配置项手册）</p><p>与Vega-Lite的不同之处在于，除了一般的二维平面可视化，他还提供了三维的可视化版本称为Echarts GL。</p><p>总结：相比于交互式可视化工具，配置式可视化工具适用于稍加复杂的场景，一般要求：</p><ol><li>用户：对编程有所了解。</li><li>数据：简单。 </li><li>任务/需求：中等复杂度，交互任务较多。往往可结合编程可视化工具来完成更加复杂的任务。</li></ol><p>除上述配置式可视化工具，现有的配置式可视化工具还有：由蚂蚁金服推出的国产可视化工具ANTV；由Uber官方推出的DECK.GL主要是面向城市数据、地理空间数据、三维可视化；PLOT.LY类似于echarts也是利用配置项来配制出具有交互的可视化图表，主要提供了面向python和R语言的可视化相关组件库，所以受众十分广；P4专门用于高性能可视化的一款工具，利用GPU的硬件进行加速，所以他能进行大规模的数据可视化，可以适用不同复杂的可视化场景。</p><h4 id="编程式可视化工具"><a href="#编程式可视化工具" class="headerlink" title="编程式可视化工具"></a>编程式可视化工具</h4><p>Processing：特性：</p><ol><li>基于Java和JVM，跨平台。</li><li>语言简单易上手，配套开发工具。</li><li>集成了OpenGL,利用硬件加速。</li><li>用户社区的卓越贡献。2001年诞生于麻省理工的媒体实验室，诞生之初的主要目的是通过激励性的可视化反馈来帮助非程序员的入门编程的学习。在其社区的推动下逐渐演变成了一个媒体媒体表达的一个语言 。</li></ol><p>D3：在2011年斯坦福大学发表的论文中提出的Data-Driven Documents，是目前使用率较高的编程式可视化工具。相对于Processing，D3更贴近于可视化的编程，在D3他们的工作里面提出了一种数据驱动的文档的理念。它把数据和可视化元素绑定起来。当有新的元素进入的时候/有旧的元素退出的时候可视化元素就会进行相应的更新来保持数据和展现的一致。</p><p> 编程式可视化工具总结:适用于更加复杂的可视化场景，其要求：</p><ol><li>用户：编程能力强。</li><li>任务/需求：难度高，复杂。</li><li>数据：复杂。其他适用于不同场景编程式可视化工具：p5*JS、VTK基于OpenGL、PixiJS、Tulip。</li></ol><h4 id="参考资料：浙江大学2020年暑期可视化课程"><a href="#参考资料：浙江大学2020年暑期可视化课程" class="headerlink" title="参考资料：浙江大学2020年暑期可视化课程"></a><strong>参考资料：</strong>浙江大学2020年暑期可视化课程</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    可视化使用工具根据其使用的可拓展性（即灵活性）可分为三类：交互式可视化工具、配置式可视化工具、编程式可视化工具。其中他们的可拓展性依次递增，编程式可视化工具可拓展性最好，但同时由于：交互式可视化工具可能仅需要用户掌握软件使用方法；配置式可视化工具需要使用人员具有一定基础编程能力；编程式可视化工具更是需要使用者熟练掌握相应的编程语言。故这三类可视化工具的使用难度也依次递增。其详细信息如下：&lt;/p&gt;</summary>
    
    
    
    <category term="可视化" scheme="http://example.com/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
    <category term="可视化" scheme="http://example.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="浙大可视化暑期班2020" scheme="http://example.com/tags/%E6%B5%99%E5%A4%A7%E5%8F%AF%E8%A7%86%E5%8C%96%E6%9A%91%E6%9C%9F%E7%8F%AD2020/"/>
    
  </entry>
  
  <entry>
    <title>Vue常用知识点总结</title>
    <link href="http://example.com/2021/04/22/vue_summary/"/>
    <id>http://example.com/2021/04/22/vue_summary/</id>
    <published>2021-04-22T13:04:32.000Z</published>
    <updated>2024-05-02T05:12:18.282Z</updated>
    
    <content type="html"><![CDATA[<p>​    Vue在面试中的常考知识点总结。</p><span id="more"></span><h4 id="Vue的响应式系统（即双向绑定）"><a href="#Vue的响应式系统（即双向绑定）" class="headerlink" title="Vue的响应式系统（即双向绑定）"></a>Vue的响应式系统（即双向绑定）</h4><p>​    通过数据劫持监听加发布者-订阅者模式实现。我们在Observer中使用Object.defineProperty（或者proxy）函数来实现对数据的追踪。在该函数中有一个get方法和set方法，当外界通过Watcher读取数据时会触发get，进而将每个数据对应的依赖watcher添加到Dep数组中，当外界数据发生改变时，就会触发set函数，找到Dep中的依赖从而通知订阅者更新相应的页面。</p><p>​    Vue为MVVM框架，当数据模型data变化时，页面视图会得到响应更新，其原理对data的getter/setter方法进行拦截（Object.defineProperty或者Proxy），利用发布订阅的设计模式，在getter方法中进行订阅，在setter方法中发布通知，让所有订阅者完成响应。</p><p>​    在响应式系统中，Vue会为数据模型data的每一个属性新建一个订阅中心作为发布者，而监听器watch、计算属性computed、视图渲染template/render三个角色同时作为订阅者，对于监听器watch，会直接订阅观察监听的属性，对于计算属性computed和视图渲染template/render，如果内部执行获取了data的某个属性，就会执行该属性的getter方法，然后自动完成。</p><h4 id="Vue中几个基础的命令及含义"><a href="#Vue中几个基础的命令及含义" class="headerlink" title="Vue中几个基础的命令及含义"></a>Vue中几个基础的命令及含义</h4><ol><li>v-bind强制绑定，简写冒号，作用：把HTML元素转换为js元素</li><li>v-on简写@，绑定事件监听，@click=”test()”</li><li>v-if，条件渲染指令</li><li>v-show,条件渲染指令</li><li>v-for,循环指令</li></ol><h4 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h4><p>​    1、初始化显示</p><p>​        beforeCreate()：是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。</p><blockquote><p>beforeCreate()：是new Vue()之后触发的第一个勾子函数，当前阶段数据和方法都不能被访问</p></blockquote><p>​        Created()：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。</p><blockquote><p>Created()：在实例创建完成后发生，当前阶段已经完成了数据的观测，可以使用数据，更改数据且不会触发updated函数，但是当前阶段无法与DOM交互</p></blockquote><p>​        beforeMount()：发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。、</p><blockquote><p>发生在挂载之前，template模板已经被编译成了render函数，且虚拟DOM已经创建完成，即将开始渲染，此时更改数据，不会触发updated</p></blockquote><p>​        mounted()：在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。</p><blockquote><p>真实DOM已经挂载完毕，数据完成双向绑定，可以访问到DOM节点</p></blockquote><p>​    2、更新显示</p><p>​        beforeUpdate()：发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</p><blockquote><p>在响应式数据发生更新、虚拟DOM重新渲染之前被触发</p></blockquote><p>​        updated()：发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p><blockquote><p>发生在更新完成之后，当前阶段组件的DOM已经完成更新，需要避免在此期间更改数据</p></blockquote><p>​    3、销毁Vue实例</p><p>​        beforeDestroy()：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p><p>​        destroyed()：发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p><h4 id="computed与watch的区别"><a href="#computed与watch的区别" class="headerlink" title="computed与watch的区别"></a>computed与watch的区别</h4><p>​    计算属性computed和监听器watch都可以观察属性的变化从而做出响应，不同的是：</p><p>​    计算属性computed更多是作为<strong>缓存功能</strong>的观察者，它可以将一个或者多个data的属性进行复杂的计算生成一个新的值，提供给渲染函数使用，当依赖的属性变化时，computed不会立即重新计算生成新的值，而是先标记为脏数据，当下次computed被获取时候，才会进行重新计算并返回。</p><p>​    而监听器watch并<strong>不具备缓存性</strong>，监听器watch提供一个监听函数，当监听的属性发生变化时，会立即执行该函数。</p><h4 id="为什么组件的data必须是一个函数"><a href="#为什么组件的data必须是一个函数" class="headerlink" title="为什么组件的data必须是一个函数"></a>为什么组件的data必须是一个函数</h4><p>​    一个组件可能在很多地方使用，也就是会创建很多个实例，如果data是一个对象的话，对象是引用类型，一个实例修改了data会影响到其他实例，所以data必须使用函数，为每一个实例创建一个属于自己的data，<strong>使其同一个组件的不同实例互不影响。</strong></p><h4 id="组件之间通信的方式"><a href="#组件之间通信的方式" class="headerlink" title="组件之间通信的方式"></a>组件之间通信的方式</h4><ol><li>props，此方法只能用于父组件向子组件传递数据</li><li>Vue的自定义事件：<ul><li>通过v-on绑定</li><li>通过$on绑定</li><li>此方法仅适用于子组件向父组件传递消息</li></ul></li><li>PubSubJS库（使用消息的订阅预发布），该方式可实现任意关系组件间的通信（数据）</li><li>插槽：该方法用于父组件向子组件传递‘标签数据’</li><li>eventBus：每一个Vue实例都是一个Event Bus，都支持$on/$emit，可以为需要通信组件的实例之间new一个Vue实例，作为Event Bus进行通信。</li><li>Vuex：将状态和方法提取到Vuex，完成共享</li></ol><h4 id="Vue事件绑定原理"><a href="#Vue事件绑定原理" class="headerlink" title="Vue事件绑定原理"></a>Vue事件绑定原理</h4><p>​    vue中的事件绑定是有两种，一种是原生的事件绑定，另一种是组件的事件绑定。原生的事件绑定在普通元素上是通过@click进行绑定，在组件上是通过@click.native进行绑定，组件中的nativeOn是等价于on的。组件的事件绑定的@click是vue 中自定义的 $on 方法来实现的，必须有$emit才可以触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> compiler = <span class="built_in">require</span>(<span class="string">&#x27;vue-template-compiler&#x27;</span>); <span class="comment">// vue loader中的包</span></span><br><span class="line"><span class="keyword">let</span> r1 = compiler.compile(<span class="string">&#x27;&lt;div @click=&quot;fn()&quot;&gt;&lt;/div&gt;&#x27;</span>); <span class="comment">// 给普通标签绑定click事件</span></span><br><span class="line"><span class="comment">// 给组件绑定一个事件，有两种绑定方法</span></span><br><span class="line"><span class="comment">// 一种@click.native，这个绑定的就是原生事件</span></span><br><span class="line"><span class="comment">// 另一种@click，这个绑定的就是组件自定义事件</span></span><br><span class="line"><span class="keyword">let</span> r2 = compiler.compile(<span class="string">&#x27;&lt;my-component @click.native=&quot;fn&quot; @click=&quot;fn1&quot;&gt;&lt;/mycomponent&gt;&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r1.render); <span class="comment">// &#123;on:&#123;click&#125;&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(r2.render); <span class="comment">// &#123;nativeOn:&#123;click&#125;,on:&#123;click&#125;&#125;</span></span><br><span class="line"><span class="comment">// 为什么组件要加native？因为组件最终会把nativeOn属性放到on的属性中去，这个on会单独处理</span></span><br><span class="line"><span class="comment">// 组件中的nativeOn 等价于 普通元素on，组件on会单独处理</span></span><br></pre></td></tr></table></figure><p>1.原生的事件绑定，原生 dom 事件的绑定,采用的是 addEventListener 实现。</p><p>2.组件的事件绑定，组件绑定事件采用的是 $on 方法 。        </p><p>​    <strong>原生事件的绑定是通过addEventLister绑定给真实的元素的；组件事件绑定是通过vue自定义的$on实现的。</strong>如果要在组件上使用原生事件，需要加.native修饰符，这样就相当于在父组件中把子组件当做普通html标签，然后加上原生事件。</p><p>​    $on、$emit是基于订阅观察者模式的，维护一个事件中心，on的时候将事件按名称存在事件中心里，称之为订阅者，然后emit将对应的事件进行发布，去执行事件中心里的对应的监听器。</p><p>​    每一个Vue实例都是一个Event Bus，当子组件被创建的时候，父组件将事件传递给子组件，子组件初始化的时候是有$on方法将事件注册到内部，在需要的时候使用$emit触发函数，而对于原生native事件，使用addEventListener绑定到真实的DOM元素上。</p><h4 id="slot插槽及原理"><a href="#slot插槽及原理" class="headerlink" title="slot插槽及原理"></a>slot插槽及原理</h4><p>​    <strong>插槽（Slot）是Vue提出来的一个概念，插槽用于将所携带的内容插入到之指定的位置，从而使模板分块具有模块化的特质和作用。插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制</strong></p><p>slot又分三类，默认插槽，具名插槽和作用域插槽。</p><ul><li>默认插槽：又名匿名插槽（或单个插槽），当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li><li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li><li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以<strong>将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</strong></li></ul><p><strong>实现原理</strong>：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p><h4 id="Vue模板渲染的原理"><a href="#Vue模板渲染的原理" class="headerlink" title="Vue模板渲染的原理"></a>Vue模板渲染的原理</h4><p>​    vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要<strong>将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。</strong></p><p>模板编译又分三个阶段，解析（parse），优化（optimize），生成（generate），最终生成可执行函数render。</p><ul><li>parse阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li><li>optimize阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li><li>generate阶段：将最终的AST转化为render函数字符串。</li></ul><h4 id="template预编译"><a href="#template预编译" class="headerlink" title="template预编译"></a>template预编译</h4><p>​    <strong>对于 Vue 组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后在也不会进行编译。</strong>因此，编译对组件的 runtime 是一种性能损耗。</p><p>​    而模板编译的目的仅仅是将template转化为<code>render function</code>，这个过程，正好可以在项目构建的过程中完成，这样可以让实际组件在 runtime 时直接跳过模板渲染，进而提升性能，这个在项目构建的编译template的过程，就是预编译。</p><blockquote><p>对于Vue组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后就不会进行编译。而模板编译的目的仅仅是将template转换为render函数，而这个过程正好可以在项目构建的过程中完成，在项目构建的过程中完成编译template编译就叫做预编译。</p><p>​    比如webpack的vue-loader依赖了vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数，在 runtime 可直接跳过模板编译过程。</p></blockquote><h4 id="template和JSX有的区别"><a href="#template和JSX有的区别" class="headerlink" title="template和JSX有的区别"></a>template和JSX有的区别</h4><p>​    对于 runtime 来说，只需要保证组件存在 render 函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。</p><p>​    在 webpack 中，我们使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。</p><p>​    与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。</p><p>​    所以，template和jsx的都是render的一种表现形式，不同的是：</p><p>​    JSX相对于template而言，具有<strong>更高的灵活性</strong>，<strong>在复杂的组件中，更具有优势</strong>，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p><blockquote><p>总结，区别就是：</p><ul><li>JSX相对于template而言具有更高的灵活性，在复杂的组件中，更具优势。</li><li>template相对于JSX而言，在代码结构上更符合视图逻辑，更加简洁易维护。  </li></ul></blockquote><h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><p>​    Virtual DOM 是 DOM 节点在 JavaScript 中的一种抽象数据结构，之所以需要虚拟DOM，是因为浏览器中操作DOM的代价比较昂贵，频繁操作DOM会产生性能问题。虚拟DOM的作用是在每一次响应式数据发生变化引起页面重渲染时，Vue对比更新前后的虚拟DOM，匹配找出尽可能少的需要更新的真实DOM，从而达到提升性能的目的。</p><h4 id="Vue中的diff算法"><a href="#Vue中的diff算法" class="headerlink" title="Vue中的diff算法"></a>Vue中的diff算法</h4><p>在新老虚拟DOM对比时</p><ul><li>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换</li><li>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li><li>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。</li><li>匹配时，找到相同的子节点，递归比较子节点</li></ul><p><strong>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从<code>O(n^3)</code>降低值<code>O(n)</code>，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</strong></p><h4 id="key属性的作用"><a href="#key属性的作用" class="headerlink" title="key属性的作用"></a>key属性的作用</h4><p>​    在对节点进行diff的过程中，判断是否为相同节点的一个很重要的条件是key是否相等，如果是相同节点，则会尽可能的复用原有的DOM节点。所以key属性是提供给框架在diff的时候使用的，而非开发者。</p><h4 id="Vue2-0和Vue3-0的区别"><a href="#Vue2-0和Vue3-0的区别" class="headerlink" title="Vue2.0和Vue3.0的区别"></a>Vue2.0和Vue3.0的区别</h4><ol><li><p>重构响应式系统，使用Proxy替换Object.defineProperty，使用Proxy优势：</p><ul><li><p>可直接监听数组类型的数据变化</p></li><li><p>监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升</p></li><li><p>可拦截apply、ownKeys、has等13种方法，而Object.defineProperty不行</p></li><li><p>直接实现对象属性的新增/删除</p></li></ul></li><li><p>新增Composition API，更好的逻辑复用和代码组织</p></li><li><p>重构 Virtual DOM</p><ul><li><p>模板编译时的优化，将一些静态节点编译成常量</p></li><li><p>slot优化，将slot编译为lazy函数，将slot的渲染的决定权交给子组件</p></li><li><p>模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）</p></li></ul></li><li><p>代码结构调整，更便于Tree shaking，使得体积更小</p></li><li><p>使用Typescript替换Flow</p></li></ol><h4 id="Composition-API简介"><a href="#Composition-API简介" class="headerlink" title="Composition API简介"></a>Composition API简介</h4><p>​    Vue2.0中，随着功能的增加，组件变得越来越复杂，越来越难维护，而难以维护的根本原因是Vue的API设计迫使开发者使用watch，computed，methods选项组织代码，而不是实际的业务逻辑。</p><p>​    另外Vue2.0缺少一种较为简洁的低成本的机制来完成逻辑复用，虽然可以minxis完成逻辑复用，但是当mixin变多的时候，会使得难以找到对应的data、computed或者method来源于哪个mixin，使得类型推断难以进行。</p><p>​    所以Composition API的出现，主要是也是为了解决Option API带来的问题，第一个是代码组织问题，Compostion API<strong>可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性</strong>，也就是说当下一个开发者接触这一段不是他自己写的代码时，他可以更好的利用代码的组织反推出实际的业务逻辑，或者根据业务逻辑更好的理解代码。</p><p>​    <strong>第二个是实现代码的逻辑提取与复用</strong>，当然mixin也可以实现逻辑提取与复用，但是像前面所说的，多个mixin作用在同一个组件时，很难看出property是来源于哪个mixin，来源不清楚，另外，多个mixin的property存在变量命名冲突的风险。而Composition API刚好解决了这两个问题。</p><blockquote><p>1、可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性。</p><p>2、可以实现代码的逻辑复用。</p></blockquote><h4 id="Composition-API与React-Hook的区别"><a href="#Composition-API与React-Hook的区别" class="headerlink" title="Composition API与React Hook的区别"></a>Composition API与React Hook的区别</h4><p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</p><ul><li>不能在循环、条件、嵌套函数中调用Hook</li><li>必须确保总是在你的React函数的顶层调用Hook</li><li>useEffect、useMemo等函数必须手动确定依赖关系</li></ul><p>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</p><ul><li>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢</li><li>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用</li><li>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</li></ul><p>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</p><h4 id="SSR服务器端渲染原理"><a href="#SSR服务器端渲染原理" class="headerlink" title="SSR服务器端渲染原理"></a>SSR服务器端渲染原理</h4><p>​    在客户端请求服务器的时候，服务器到数据库中获取到相关的数据，并且在服务器内部将Vue组件渲染成HTML，并且将数据、HTML一并返回给客户端，这个在服务器将数据和组件转化为HTML的过程，<strong>叫做服务端渲染SSR</strong>。</p><p>而当客户端拿到服务器渲染的HTML和数据之后，由于数据已经有了，客户端不需要再一次请求数据，而只需要将数据同步到组件或者Vuex内部即可。除了数据以外，HTML也结构已经有了，客户端在渲染组件的时候，也只需要将HTML的DOM节点映射到Virtual DOM即可，不需要重新创建DOM节点，这个将数据和HTML同步的过程，又叫做客户端激活。</p><p>使用SSR的好处：</p><ul><li>有利于SEO：其实就是有利于爬虫来爬你的页面，因为部分页面爬虫是不支持执行JavaScript的，这种不支持执行JavaScript的爬虫抓取到的非SSR的页面会是一个空的HTML页面，而有了SSR以后，这些爬虫就可以获取到完整的HTML结构的数据，进而收录到搜索引擎中。</li><li><strong>白屏时间更短</strong>：相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。而客户端渲染，需要先得到一个空的HTML页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。</li></ul><p>更多详情查看<a href="https://github.com/yacan8/blog/issues/30">彻底理解服务端渲染 - SSR原理</a></p><h4 id="v-show和v-if的区别"><a href="#v-show和v-if的区别" class="headerlink" title="v-show和v-if的区别"></a>v-show和v-if的区别</h4><ul><li>v-if：是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</li><li><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</li><li><code>v-show</code> 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</li><li>如果需要频繁切换 v-show 较好</li></ul><h4 id="Vue渲染到视图的流程"><a href="#Vue渲染到视图的流程" class="headerlink" title="Vue渲染到视图的流程"></a>Vue渲染到视图的流程</h4><ol><li><p>把模板编译为render函数（在beforeMount之前，Created之后）</p></li><li><p>实例进行挂载, 根据根节点render函数的调用，递归的生成虚拟dom（beforeMount阶段）</p></li><li><p>对比虚拟dom，渲染到真实dom（Mounted之前）</p></li><li><p>组件内部data发生变化，组件和子组件引用data作为props重新调用render函数，生成虚拟dom, 返回到步骤3。（Mounted阶段）</p><p><img src="/2021/04/22/vue_summary/Snipaste_2021-04-22_21-43-20.png" alt="Snipaste_2021-04-22_21-43-20"></p><p><img src="/2021/04/22/vue_summary/Snipaste_2021-04-22_21-44-17.png" alt="Snipaste_2021-04-22_21-44-17"></p><p><img src="/2021/04/22/vue_summary/Snipaste_2021-04-22_21-45-00.png" alt="Snipaste_2021-04-22_21-45-00"></p></li></ol><h4 id="vue中请求数据的方式"><a href="#vue中请求数据的方式" class="headerlink" title="vue中请求数据的方式"></a>vue中请求数据的方式</h4><ol><li>vue-resource 官方提供的 vue的一个插件</li><li>ajax</li><li>axios</li><li>fetch-jsonp</li></ol><p><a href="https://www.jb51.net/article/181876.htm">https://www.jb51.net/article/181876.htm</a></p><h4 id="Vue路由的两种实现方式"><a href="#Vue路由的两种实现方式" class="headerlink" title="Vue路由的两种实现方式"></a>Vue路由的两种实现方式</h4><p>​    前端不同页面的状态管理器，可以不向后台发送请求而直接通过前端技术实现多个页面的切换。</p><ol><li><p>hash模式</p><p>通过锚点定位原理进行无刷新跳转，触发后会在url后面多加一个#号</p></li><li><p>history模式</p><p>使用HTML5中的historyAPI实现客户端路由模式，触发后url中没有#</p></li></ol><h4 id="Vue中的this-nextTick"><a href="#Vue中的this-nextTick" class="headerlink" title="Vue中的this.$nextTick"></a>Vue中的this.$nextTick</h4><p>​    <strong>Vue.nextTick( <a href="https://cn.vuejs.org/v2/api/#Vue-nextTick">callback, context] )</a></strong></p><ul><li><p><strong>参数</strong>：</p><ul><li><code>&#123;Function&#125; [callback]</code></li><li><code>&#123;Object&#125; [context]</code></li></ul></li><li><p><strong>用法</strong>：</p><p><strong>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">vm.msg = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="comment">// DOM 还没有更新</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span></span><br><span class="line">Vue.nextTick()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM 更新了</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="Vue中的keep-alive"><a href="#Vue中的keep-alive" class="headerlink" title="Vue中的keep-alive"></a>Vue中的keep-alive</h4><p><keep-alive> 是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。<keep-alive>包裹动态组件时，会<strong>缓存不活动的组件实例</strong>，而不是销毁它们。</keep-alive></keep-alive></p><p><keep-alive> 与 <transition>相似，只是一个抽象组件，它不会在DOM树中渲染(真实或者虚拟都不会)，也不在父组件链中存在，比如：你永远在this.$parent 中找不到 keep-alive 。</transition></keep-alive></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    Vue在面试中的常考知识点总结。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>V8引擎编译器和解析器</title>
    <link href="http://example.com/2021/04/22/parsers_and_editors_v8/"/>
    <id>http://example.com/2021/04/22/parsers_and_editors_v8/</id>
    <published>2021-04-22T12:11:09.000Z</published>
    <updated>2024-05-02T05:12:15.958Z</updated>
    
    <content type="html"><![CDATA[<p>​    通过阅读李兵老师的《浏览器的原理与实践》感觉对自己学习和理解前端知识大有启发，结合自己的理解对V8引擎的编译器和解释器做了以下归纳和总结。已备自己忘记时查看。</p><span id="more"></span><h4 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h4><p>​    <strong>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。</strong>比如 C/C++、GO 等都是编译型语言。</p><p>​    <strong>解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行</strong>。比如 Python、JavaScript 等都属于解释型语言。</p><p><img src="/2021/04/22/parsers_and_editors_v8/image-20210306105157354.png" alt="image-20210306105157354"></p><p><strong>（1）编译型语言的执行流程：</strong>编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</p><p><strong>（2）解释型语言的执行流程：</strong>解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</p><h4 id="V8-是如何执行一段-JavaScript-代码的"><a href="#V8-是如何执行一段-JavaScript-代码的" class="headerlink" title="V8 是如何执行一段 JavaScript 代码的"></a>V8 是如何执行一段 JavaScript 代码的</h4><p>​    V8 在执行过程中既有<strong>解释器 Ignition</strong>，又有<strong>编译器 TurboFan</strong>。其全局执行流程如下所示：</p><p><img src="/2021/04/22/parsers_and_editors_v8/image-20210306105718810.png" alt="image-20210306105718810"></p><h5 id="生成抽象语法树（AST）和执行上下文"><a href="#生成抽象语法树（AST）和执行上下文" class="headerlink" title="生成抽象语法树（AST）和执行上下文"></a>生成抽象语法树（AST）和执行上下文</h5><p>​    首先，将源代码转换成<strong>抽象语法树（AST）</strong>和<strong>执行上下文</strong>。高级语言是开发者可以理解的语言，而对于编译器和解释器来说他们可以理解的就是抽象语法树（AST）。这和渲染引擎将HTML格式的文件转换为自己可以理解的DOM树类似。</p><p>​    AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。<strong>Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</strong></p><p>​    除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p><p><strong>生成AST的两个阶段：</strong></p><p><strong>第一阶段是分词（tokenize），又称为词法分析</strong>，其作用是将一行行的源码拆解成一个个 token。所谓<strong>token</strong>，指的是语法上不可能再分的、最小的单个字符或字符串。</p><p><img src="/2021/04/22/parsers_and_editors_v8/image-20210306111037818.png" alt="image-20210306111037818"></p><p>​    从图中可以看出，通过<code>var myName = “极客时间”</code>简单地定义了一个变量，其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。</p><p><strong>第二阶段是解析（parse），又称为语法分析</strong>，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p><p><strong>有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。</strong></p><h5 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h5><p>​    有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。</p><p><strong>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</strong></p><p><img src="/2021/04/22/parsers_and_editors_v8/image-20210306111747379.png" alt="image-20210306111747379"></p><p>​    从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。</p><h5 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h5><p>​    通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码(HotSpot)，比如一段代码被重复执行多次，这种就称为<strong>热点代码</strong>，那么后台的编译器(TurboFan) 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p><p>​    其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为<strong>即时编译（JIT）</strong>。</p><h4 id="JavaScript的性能优化"><a href="#JavaScript的性能优化" class="headerlink" title="JavaScript的性能优化"></a>JavaScript的性能优化</h4><p>主要关注以下三点：</p><ol><li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li><li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li><li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    （1）解释器和编译器在执行代码时都会先将代码通过词法分析、语法分析生成抽象语法树（AST），不同的是解释型语言会通过解释器将AST转换为字节码并直接逐条执行；而编译器会在AST的基础上先优化代码然后生成机器码进而编译生成二进制文件，执行时直接执行这个二进制文件。</p><p>​    （2）JavaScript的编译流程是：先通过词法分析和语法分析生成AST和可执行上下文，然后通过解释器将AST转换为字节码，并逐条执行。在生成AST时主要分为两步：第一步先通过词法分析生成token，第二步通过语法分析将token转换为AST。</p><p>​    （3）V8在代码的编译过程中采用的JIT（即时编译）技术来实现的。就是在生成字节码后，先使用解释器逐条解释并执行代码，如果遇到热点代码（被多次重复执行的代码），就会把这段字节码通过编译器编译为机器码，当再次遇到改代码是就可以直接执行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    通过阅读李兵老师的《浏览器的原理与实践》感觉对自己学习和理解前端知识大有启发，结合自己的理解对V8引擎的编译器和解释器做了以下归纳和总结。已备自己忘记时查看。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="浏览器工作原理" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>this的指向问题</title>
    <link href="http://example.com/2021/04/18/pointer_of_this/"/>
    <id>http://example.com/2021/04/18/pointer_of_this/</id>
    <published>2021-04-18T05:01:28.000Z</published>
    <updated>2024-05-02T05:12:08.158Z</updated>
    
    <content type="html"><![CDATA[<p>​    this指针是前端面试过程中最常考的问题之一，也是比较坑的问题之一，为了避免多次被坑先将this指针的相关问题记录如下，主要包括判断this指针的几类常见的方法、改变this指针的几种方法以及一些面试真题。</p><span id="more"></span><h4 id="如何判断this的指向"><a href="#如何判断this的指向" class="headerlink" title="如何判断this的指向"></a>如何判断this的指向</h4><p>在使用 this 时，为了避坑，你要谨记以下四点：</p><ol><li>当函数作为对象的方法调用时，函数中的 this 就是该对象；</li><li>当函数被正常调用时，<strong>在严格模式下，this 值是 undefined</strong>，非严格模式下 this 指向的是全局对象 window；</li><li>嵌套函数中的 this 不会继承外层函数的 this 值。</li><li>我们还提了一下箭头函数，因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。</li><li>当this遇到return时，如果返回值是一个对象，那么this指向的是构造函数的实例但是并没有被返回，如果返回值不是一个对象，那么this还是指向构造函数创建的实例。</li></ol><p>下面从几道例题中去验证：</p><ol><li><p>直接使用的函数this指向window</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> user= <span class="string">&quot;呵呵&quot;</span>，</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.user),</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>),</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// window</span></span><br></pre></td></tr></table></figure></li><li><p>嵌套函数中的 this 不会继承外层函数的 this 值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> user = <span class="string">&quot;呵呵&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.user);</span><br><span class="line">    &#125;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">o();</span><br></pre></td></tr></table></figure></li><li><p>当函数作为对象的方法调用时，函数中的 this 就是该对象，且永远指向最后调用它的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题目一</span></span><br><span class="line"><span class="keyword">var</span> o=&#123;</span><br><span class="line">a:<span class="number">10</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">    a=<span class="number">12</span>,</span><br><span class="line">        fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.b.fn() <span class="comment">//12</span></span><br><span class="line"><span class="comment">//题目二</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">a:<span class="number">10</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">    a:<span class="number">12</span></span><br><span class="line">        fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j = o.b.fn;</span><br><span class="line">j(); <span class="comment">// undefined //window</span></span><br></pre></td></tr></table></figure></li><li><p>构造函数中的this指向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.user = <span class="string">&#x27;呵呵&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Fn()</span><br><span class="line"><span class="built_in">console</span>.log(p.user) <span class="comment">// 呵呵</span></span><br></pre></td></tr></table></figure></li><li><p>当this遇到return时</p><p>如果返回值是一个对象，那么this指向的是构造函数的实例但是并没有被返回，如果返回值不是一个对象，那么this还是指向构造函数创建的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//undefined</span></span><br><span class="line">==============================</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//undefined</span></span><br><span class="line">==============================</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//呵呵</span></span><br><span class="line">==============================</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.user = <span class="string">&quot;呵呵&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.user) <span class="comment">//呵呵</span></span><br></pre></td></tr></table></figure></li><li><p>箭头函数中的this指向</p><p>箭头函数是ES6中的特性，箭头函数没有执行上下文本所以没有this，它会沿用/捕获外部环境的this。也就是说，箭头函数内部与外部的this是保持一致的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 题目一 */</span></span><br><span class="line"><span class="built_in">this</span>.a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">a:<span class="number">40</span>,</span><br><span class="line">    init:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">        go.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> go</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = test.init()</span><br><span class="line">p()</span><br><span class="line"><span class="keyword">new</span> (test.init())()</span><br><span class="line"><span class="comment">/* 题目二 */</span></span><br><span class="line"><span class="built_in">this</span>.a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">a:<span class="number">40</span>,</span><br><span class="line">    init:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">        go.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> go</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = test.init()</span><br><span class="line">p()</span><br><span class="line"><span class="keyword">new</span> (test.init())()</span><br></pre></td></tr></table></figure></li></ol><h4 id="如何改变this的指向"><a href="#如何改变this的指向" class="headerlink" title="如何改变this的指向"></a>如何改变this的指向</h4><p><strong>1、call()和apply()</strong></p><p>​    **call():**第一个参数表示要把this指向的新目标，第二个之后的参数其实相当于传参，参数以逗号隔开（性能较apply略好）。</p><p>​    用法：a.call(b,1,2)；表示要把a函数的this指向修改为b的this指向，并运行a函数，传入参数是（1,2）</p><p>​    <strong>apply()：</strong>第一个参数同上，第二个参数接收一个数组，里面也是传参，只是以数组的方式，相当于arguments</p><p>用法：a.apply(b,[1,2])；表示要把a函数的this指向修改为b的this指向，并运行a函数，传进去的参数是(1,2);</p><p>*<strong>注意：即使只有一个参数的话，也要是数组的形式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//call 的传参和apply的传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">arg1,arg2</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name,arg1,arg2);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name : <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  say : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">say.call(obj,<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>);<span class="comment">//tom one two</span></span><br><span class="line">say.spply(obj,[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>]);<span class="comment">//tom one two  效果一样</span></span><br></pre></td></tr></table></figure><p><strong>2、bind()</strong></p><p>​    作用：bind()方法会创建一个新的函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入bind()方法的第一个参数作为this，传入bind()的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p><p>​    用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar : <span class="number">1</span>,</span><br><span class="line">    eventBind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">&#x27;.someClass&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="comment">/* Act on the event */</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.bar);      <span class="comment">//1</span></span><br><span class="line">        &#125;.bind(<span class="built_in">this</span>));<span class="comment">//这里的this是eventBind的this，即指向的是foo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</p><p><strong>3、new</strong></p><p>new的运行原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Animal(<span class="string">&#x27;cat&#x27;</span>) = &#123;<span class="comment">//类似这样</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;<span class="comment">//先定义一个空对象</span></span><br><span class="line">    obj.__proto__ = Animal.prototype;</span><br><span class="line">    <span class="comment">//把 obj 的__proto__ 指向构造函数 Animal 的原型对象 prototype，</span></span><br><span class="line">    <span class="comment">//此时便建立了 obj 对象的原型链：</span></span><br><span class="line">    <span class="comment">//obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null</span></span><br><span class="line">    <span class="keyword">var</span> result = Animal.call(obj,<span class="string">&quot;cat&quot;</span>);<span class="comment">//改变this指向，从Animal改变到obj上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span>? result : obj; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&quot;追梦子&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn();<span class="comment">//this指向a</span></span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//追梦子</span></span><br></pre></td></tr></table></figure><p><strong>4、return</strong></p><p>​    在构造函数的时候，使用return进行返回一个Object的时候，当去new一个实例对象的时候，会将this指向改变为return的Object；</p><p>​     用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&#x27;追梦子&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;user&quot;</span> : <span class="string">&quot;111&quot;</span></span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//111</span></span><br></pre></td></tr></table></figure><h4 id="使用fn-apply-this-arr-和fn-…arr-的区别"><a href="#使用fn-apply-this-arr-和fn-…arr-的区别" class="headerlink" title="使用fn.apply(this,arr)和fn(…arr)的区别"></a>使用fn.apply(this,arr)和fn(…arr)的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">当然，在这道题目中用fn(...arr)也能成功的输出</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目描述</span></span><br><span class="line"><span class="comment">将数组 arr 中的元素作为调用函数 fn 的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">greeting, name, punctuation</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> greeting + <span class="string">&#x27;, &#x27;</span> + name + (punctuation || <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;Ellie&#x27;</span>, <span class="string">&#x27;!&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argsAsArray</span>(<span class="params">fn, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, arr);</span><br><span class="line">    <span class="comment">//return fn(...arr)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：<a href="https://segmentfault.com/q/1010000004566233">https://segmentfault.com/q/1010000004566233</a></p><h4 id="面试真题"><a href="#面试真题" class="headerlink" title="面试真题"></a>面试真题</h4><ol><li><p>this的指向（from:字节跳动技术中台一面）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">x: <span class="number">1</span>,</span><br><span class="line">    print () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.print();  <span class="comment">//1</span></span><br><span class="line"><span class="keyword">let</span> print = a.print()</span><br><span class="line">print();  <span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//问：如何改变this的指向</span></span><br><span class="line"><span class="keyword">let</span> print = a.print.bind(a);</span><br><span class="line">print()</span><br></pre></td></tr></table></figure></li><li></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    this指针是前端面试过程中最常考的问题之一，也是比较坑的问题之一，为了避免多次被坑先将this指针的相关问题记录如下，主要包括判断this指针的几类常见的方法、改变this指针的几种方法以及一些面试真题。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="ES" scheme="http://example.com/tags/ES/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>V8垃圾回收机制</title>
    <link href="http://example.com/2021/04/17/garbage_collect_of_v8/"/>
    <id>http://example.com/2021/04/17/garbage_collect_of_v8/</id>
    <published>2021-04-17T12:17:20.000Z</published>
    <updated>2024-05-02T05:12:12.952Z</updated>
    
    <content type="html"><![CDATA[<p>​    JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。搞清楚内存中的垃圾是如何回收的对理解内存机制和写出高性能的代码具有巨大的帮助。下面将主要介绍V8引擎的垃圾回收机制。</p><span id="more"></span><p>JavaScript、Java、Python 等语言，<strong>产生的垃圾数据是由垃圾回收器来释放的</strong>，并不需要手动通过代码来释放。</p><h4 id="调用栈中的数据如何回收"><a href="#调用栈中的数据如何回收" class="headerlink" title="调用栈中的数据如何回收"></a>调用栈中的数据如何回收</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客邦 &quot;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> c = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">      <span class="keyword">var</span> d = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    showName()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>​    执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如下图所示。与此同时，还有一个<strong>记录当前执行状态的指针（称为 ESP）</strong>，指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p><p>​    接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，<strong>这个下移操作就是销毁 showName 函数执行上下文的过程</strong>。</p><p><img src="/2021/04/17/garbage_collect_of_v8/image-20210304112315040.png" alt="image-20210304112315040"></p><p>所以说，当一个函数执行结束之后，<strong>JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文</strong>。</p><h4 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h4><p><strong>代际假说（The Generational Hypothesis）</strong>：</p><ul><li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li><li>第二个是不死的对象，会活得更久。</li></ul><p><strong>分代收集</strong>：</p><p>​    在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p><ul><li><strong>副垃圾回收器，主要负责新生代的垃圾回收。</strong></li><li><strong>主垃圾回收器，主要负责老生代的垃圾回收。</strong></li></ul><p><strong>垃圾回收器的工作流程</strong>：</p><p>​    不管是主垃圾回收器还是副垃圾回收器都遵循以下这套公共的执行流程：</p><p>​    1、<strong>标记空间中活动对象和非活动对象</strong>。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p><p>​    2、<strong>回收非活动对象所占据的内存</strong>。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p><p>​    3、<strong>内存整理</strong>。频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当出现量不连续的内存碎片后，我们再想分配一个较大的连续空间就会出现内存不足的情况。</p><h4 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h4><p>​    副垃圾回收器主要负责新生区的垃圾回收，用<strong>Scavenge 算法</strong>来处理。其原理就是：把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，新加入的对象都会存放到对象区域，<strong>当对象区域快被写满时</strong>，就需要执行一次垃圾清理操作。</p><p><img src="/2021/04/17/garbage_collect_of_v8/image-20210304114240567.png" alt="image-20210304114240567"></p><p>其回收过程如下：</p><p>​    1、对对象区域中的垃圾做标记，活动对象和非活动会对象；</p><p>​    2、标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些<strong>仍然存活的对象</strong>复制到空闲区域中，<strong>同时它还会把这些对象有序地排列起来，所以这个复制过程</strong>，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p><p>​    3、完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。</p><p><strong>对象晋升策略</strong>：由于为了执行效率，新生区的空间通常会被设置的比较小，所以很容易被存满，为此JavaScript引擎引入了晋升策略，即：<strong>经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</strong></p><h4 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h4><p>​    老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p><p>​    主垃圾回收器是采用<strong>标记 - 清除（Mark-Sweep）</strong>的算法进行垃圾回收的。</p><p>1、<strong>对垃圾数据做标记</strong>。当调用栈中的ESP指向下一个执行上下文后，上一个执行上下文中引用对象在堆中的数据就会被当做垃圾数据被<strong>标为红色</strong>，而当前正被ESP指向的指向上下文中指针指向的栈中数据会被标为<strong>活动数据</strong>。</p><p>2、<strong>垃圾数据的清除</strong>。使用<strong>Mark-Sweep</strong>算法清除掉被标记为红色的垃圾数据。</p><p><img src="/2021/04/17/garbage_collect_of_v8/image-20210304115832389.png" alt="image-20210304115832389.png"></p><p>3、<strong>内存整理</strong>。使用<strong>标记 - 整理（Mark-Compact）</strong>对内存碎片进行整理。</p><p><img src="/2021/04/17/garbage_collect_of_v8/image-20210304115856708.png" alt="image-20210304115856708"></p><h4 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h4><p>​    于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p><p>​    为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记（Incremental Marking）算法</strong>。如下图所示：</p><p><img src="/2021/04/17/garbage_collect_of_v8/image-20210304120112556.png" alt="image-20210304120112556"></p><p>​    使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。搞清楚内存中的垃圾是如何回收的对理解内存机制和写出高性能的代码具有巨大的帮助。下面将主要介绍V8引擎的垃圾回收机制。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="浏览器工作原理" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>原型与原型链</title>
    <link href="http://example.com/2021/04/17/%20js_prototype_chain/"/>
    <id>http://example.com/2021/04/17/%20js_prototype_chain/</id>
    <published>2021-04-17T11:35:54.000Z</published>
    <updated>2024-05-28T15:44:48.137Z</updated>
    
    <content type="html"><![CDATA[<p>​    帮助理解前端常考知识点原型与原型链，介绍他们的相关概念以及他们是如何指向的。</p><span id="more"></span><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>显示原型</strong>：prototype</p><ul><li>每个class/函数都有显示原型prototype，它默认指向一个Object空对象（即称为原型对象）</li><li>原型对象中一个属性constructor，它指向函数对象</li></ul><p><strong>隐式原型</strong>：<strong>proto</strong></p><ul><li>每个实例都有隐式原型__proto__</li><li>实例的__proto__指向对应的class/函数的prototype。</li></ul><p><strong>相关概念</strong>：</p><ol><li>Function是所有函数(function)的父亲，所有函数都是它的实例。</li><li>Object也是一个函数，所以Object是Function的实例对象。</li><li>任何对象的原型链顶端最终都指向Object.prototype,Object.prototype再往上已经没有东西了，所以指向null。</li><li>Function比较特殊它的原型指向自己，即Function.<strong>proto</strong> === Function.prototype。</li><li>同时，Function是对象，由(3)可知Function必然有一个地方（即Function.prototype.__proto__）指向Object.prototype。</li></ol><p><strong>先来看一个简化版的原型链图：</strong></p><p><img src="/2021/04/17/%20js_prototype_chain/image-20210303222509043.png" alt="image-20210303222509043"></p><p><strong>再来看一个完整版的：</strong></p><p><img src="/2021/04/17/%20js_prototype_chain/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型与原型链"></p><p><font color="red">总之，记住一句话：A是B的实例，则A.__ proto __  === B.prototype；只要A是对象，那么A.prototype.__ proto__ 就指向Object.prototype；prototype中的constructor指向的是自己；</font></p><h4 id="原型链与函数的继承"><a href="#原型链与函数的继承" class="headerlink" title="原型链与函数的继承"></a>原型链与函数的继承</h4><ol><li><p>ES5中的继承</p><p><strong>构造函数继承</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Parent(); <span class="comment">//new一个Parent对象用来对比</span></span><br><span class="line">p.say(); <span class="comment">//输出say</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line">c.age <span class="comment">// 12</span></span><br><span class="line">c.name <span class="comment">//&#x27;parent&#x27;</span></span><br><span class="line">c.say(); <span class="comment">//undifined</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">say是Parent原型链上的方法，Parent对象调用方法时，如果自身不存在就回去原型链上寻找，在原型链上找到了say方法，而Child对象没有继承Parent对象的原型链，所以它在向上寻找时就找不到，输出undifined。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>原型链继承：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c.name); <span class="comment">//输出parent</span></span><br><span class="line">c.say() <span class="comment">//输出say</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原型链继承是直接让Child构造函数的prototype直接指向Parent对象，这样Parent的东西Child对象可以直接从它的原型链上找到。缺点就是：当创建多个实例时，如果不同实例可能互相存在影响。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>构造函数与原型链组合继承</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>); </span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c1.arr); <span class="comment">//[1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.arr);<span class="comment">//[1,2,3,4]</span></span><br><span class="line">c1.arr.push(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c1.arr); <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.arr); <span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure></li><li><p>ES6中的继承</p><p>ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法，才可使用this关键字，否则报错。），然后再用子类的构造函数修改this实现继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent2.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> Child2(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c2.name); <span class="comment">//输出parent</span></span><br><span class="line">c2.say(); <span class="comment">//输出say</span></span><br><span class="line"><span class="built_in">console</span>.log(c.constructor); </span><br><span class="line"><span class="comment">//输出function Child(age) &#123;Parent.call(this);this.age = age;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Parent().constructor); </span><br><span class="line"><span class="comment">//输出Parent() &#123;this.name = &#x27;parent&#x27;;this.arr = [1,2,3,4];&#125;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    帮助理解前端常考知识点原型与原型链，介绍他们的相关概念以及他们是如何指向的。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="ES" scheme="http://example.com/tags/ES/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ChinaVis2019参赛总结</title>
    <link href="http://example.com/2019/07/28/ChinaVis_2019_summary/"/>
    <id>http://example.com/2019/07/28/ChinaVis_2019_summary/</id>
    <published>2019-07-28T15:14:26.000Z</published>
    <updated>2024-05-02T05:12:04.519Z</updated>
    
    <content type="html"><![CDATA[<p>​    本次ChinaVis挑战赛于7月21-24日在成都举行，由于本人家住成都较近的原因很荣幸能够报名并参加了这次挑战赛会议，期间有各行业的大佬做可视化的前沿发展汇报及最新论文汇报，让我收获颇丰，其详情请关注ChinaVis2019可视化官网。本篇博客主要用来总结本人本次与同学共同参加并完成挑战赛题目的收获与不足，以及参会时记录的挑战赛1的答案详情、听取到的其他获奖作品后的感想，以备自己今后参考所用。</p><span id="more"></span><h3 id="参赛感想"><a href="#参赛感想" class="headerlink" title="参赛感想"></a>参赛感想</h3><p>我们团队作为第一次参加该比赛的新人来说，仅仅在挑战赛1中获得了优秀奖，虽然谈不上太差但却有很多在做比赛时的不足之处值得我好好思考，在做比赛时我们遇到的主要问题我归纳了有以下：</p><p>1）花的时间太少：由于我们团队都是今年的本科毕业生，要一边做毕业设计一边做比赛，最终导致真正花在做比赛上的时间实际只有10天左右。在参会时，我与其他获奖的参赛队伍交流后得知，他们的平均用时都在30天左右甚至更多。（可能对于真正的大佬来说时间根本不是问题，但对于我们这种水平的队来说多一些时间还是挺重要的）。</p><p>2）不应该最后才写论文和答卷：我认为我们这次最大的失误就是临到交卷的前一天晚上才开始写论文和答卷（实际上其过程说是在凑比较准确一点)，在写的过程中遇到各种各样的问题，很多之前在做系统和分析数据时看似好像已经分析出的东西在写答卷时又变得不清晰和无从下手。所以，我认为应该一边做系统一边写答卷。</p><p>3）没有针对挑战赛给出的问题有针对性的设计和作答：刚开始我们就是在从整体的角度去设计这个系统要做成怎么怎么样，怎样才能吸引专家眼球之类的，然后就是从别人历年发表过的可视化文章中去找我们可能能用到的可视化图形，但却忽略了问题本身。这样做，到最后写答卷时导致的结果就是，你会发现其实你每个问题感觉都有所涉及，但又每个问题你都没有解决。就比如在我们系统中的“场馆时间安排图”——能够勉强说明场馆的开会的时间段，但别人问题问的是让你找出每个场馆的时间安排，这包括大致的开会时间和会议名称；再比如“人员的分类”——勉强能把不同类型的人员聚类（精不精确先不说），但却不能说明每一类都是什么人。当然从做可视化的角度来说这样做无可厚非，但是我们是在比赛啊。我认为一开始就应该针对每个问题去寻找可以有效解决问题的方法不管是通过后端数据处理得到还是前端可视化图形得到，这样才能既节约时间由能有效的解答问题。</p><p>4）应该在答卷中尽可能多的写出自己分析的结果：在写答卷时，因为比较匆忙，所以只把自己觉得正确的地方写上去了很多之前分析出的一些较小或则与答案有关的结果并没有写上，且做出的场馆拥堵情况热力图和人员脸谱图因为没有实现联动而在没有在答卷中出现。最后在参会听老师公布答案时发现，我们分析出的很多小细节都与答案有关，我想如果把这些都写上我们的名次应该可以再上一个档次。</p><p>5）图与图之间的搭配问题：某些用于解决某问题的图搭配起来实际不能真正的解决该问题，这也是我们在设计之初考虑不周的结果，由此导致花费了时间在制作可视化的图形上，所以在设计之初我们应该想好了设计出的图形搭配起来是否能真正解决问题而不要盲目的开始制作图形。</p><p>以上就是我总结出的在本次比赛中的不足之处，下面附上我们团队做出的系统中的部分系统截图：<br><img src="/2019/07/28/ChinaVis_2019_summary/1620055143400.png" alt="1620055143400"></p><p>点击每个会场房间可单独显示每个房间的人数变化的折线图，用于详细探索某个会场或某个格子在此时间段的人员数量变化情况。同时选择多个会场，可同时在同一坐标下显示多个房间人数变化情况，以便我们对每个会场做对比分析。</p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055210105.png" alt="1620055210105"></p><p>该视图着重观察主会场以及四个分会场随时间的人数变化以及稳定度变化（出度人数除以入度人数），借此来判断该会场是否存在人数庞大的时间段或者人员流动比较频繁的时间段，推测此会场是否在举行会议或者比赛等活动。其中，黄色颜色越深代表着会场人员变动频率越高说明属于休会时段，颜色越前表示会场人员走动越低说明处于开会时间段。<br><img src="/2019/07/28/ChinaVis_2019_summary/1620055253742.png" alt="1620055253742"></p><p>  对上面经过t-sne聚类后的人员进行圈选可以查看该类人员的轨迹。点击每个聚类好的小团会在场地图中弹出该类人员的行走路线，且在折线图中显示该类人员中去过各房间的差异，从而帮助分析人员类别。</p><h3 id="挑战赛部分答案记录"><a href="#挑战赛部分答案记录" class="headerlink" title="挑战赛部分答案记录"></a>挑战赛部分答案记录</h3><p>  由于赛方已将答案以及切入点以表格的形式完整的在PPT上展示了，在此我就不过多赘述，有需要的请观看我在现场拍摄答案图片。</p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055313214.png" alt="1620055313214"></p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055338129.png" alt="1620055338129"></p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055375251.png" alt="1620055375251"></p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055406202.png" alt="1620055406202"></p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055432077.png" alt="1620055432077"></p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055461131.png" alt="1620055461131"></p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055486695.png" alt="1620055486695"></p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055518177.png" alt="1620055518177"></p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055542386.png" alt="1620055542386"></p><p><strong>备注：</strong>会场的安排包括会场的会议时间和会议名称，我只拍到了时间安排没有拍到每个房间不同时间段对应的会议名称，所以需要详细资料的可以等一段时间去官网下载详细答案。</p><h3 id="挑战1获奖作品记录及感想"><a href="#挑战1获奖作品记录及感想" class="headerlink" title="挑战1获奖作品记录及感想"></a>挑战1获奖作品记录及感想</h3><ol><li><p>一等奖，成都理工大学-李浙川</p><p>所用开发工具：Echarts，D3.js，Tableau，Layui，Python，Excel</p><p>成都理工大学队的作品被挑战赛评议委员会认为是本次赛事中分析结果最全、结果与答案最为接近的作品。在作品中并未涉及到什么算法和高大上的可视化技术却利用现有的工具将设计出的图形相互搭配完美的解决了挑战1的各问题。以下是他们设计的部分可视化界面以及简要说明。</p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620056315442.png" alt="1620056315442"></p><p>左图 ：A 部分为会场实时人数、人员密度统计条形 图；B 部分为实时会场动态展示图；C 部分为会场异常情况通报栏；D 部分</p><p>为该异常事件具体情况展示栏；E 部分为会场人数情况热力图</p><p>右图：AB 两部分为该 id 的一二楼该天停留情况热力图；CD 两部分为该 id 一二楼重要地点的具体停留时间和弦图；E 图为该</p><p>id 三天具体移动轨迹展示图</p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620056333975.png" alt="1620056333975"></p><p>左图：在折线图中梯度下降和梯度上升的情况判断出各会场会议的起止时间，其中以会场人数跃进式上升为会议的开始标志，会场人数断崖式下降为会议的结束标志，进而得出每个会场的会议安排表</p><p>右图：工作人员流动情况气泡图(其中蓝色代表服务台，灰色代表签到处，绿色代表展厅)            </p><p>盗用胸牌16632：通过发现在某一时刻同时出现两个编号相同的胸牌</p></li><li><p>一等奖，重庆大学</p><p>处理数据前对数据进行了补全再做处理</p><p>   <img src="/2019/07/28/ChinaVis_2019_summary/1620056239274.png" alt="1620056239274"></p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620056212426.png" alt="1620056212426"></p><p>   记者越权：切入点，先分析出可进VIP房间的人不用签到但该人进入VIP房间签到 </p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620056170204.png" alt="1620056170204"></p><p>   当然作为一等奖的获得者他们也分析出了盗用胸牌者，不过他们找到该盗用ID是：发现使用该ID的人员瞬移并跳格，然后深入分析发现原因不是瞬移跳格，而是有人复制胸牌导致很短的时间内有同样ID的人在不同的两个地方出现。（顺便说一句，当时我们团队也发现了这个人，且发现他的原因也是他出现瞬移的情况，但我们没有进行深入分析，而只是把他当做传感器故障时间处理了，哎。。。可能这就是一等奖和优秀之间的差距吧）。</p></li><li><p>二等奖，东北师范大学</p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620056134636.png" alt="1620056134636"></p><p>人员分类：t-sne+圈选平行坐标图</p><p>先分类-&gt;预设-&gt;t-sne降维算法</p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620056086896.png" alt="1620056086896"></p><p>冒用：同时两条轨迹 </p><p>传感器出错：由一人异常-&gt;深入察看-&gt;某段某时，传感器失灵</p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620056065367.png" alt="1620056065367"></p></li><li><p>二等奖，山东大学</p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620056023159.png" alt="1620056023159"></p><p>用到的技术 ：D3.js    AntVG2   Vega   Echarts</p><p>右图右侧决定树：用于展示全场分类</p></li><li><p>二等奖，信息工程大学</p><p>虚幻引擎（咱也不知道啥是虚幻引擎，只知道主持人赵颖老师说这是本次比赛中用到最牛技术的获奖作品o(╥﹏╥)o）不懂所以我就不敢乱逼逼，有兴趣的可以看以下我拍摄的演讲人的报告PPT，以及该作品作者的联系方式。</p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055946850.png" alt="1620055946850"></p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055918993.png" alt="1620055918993"></p></li><li><p>二等奖，燕山大学</p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055892483.png" alt="1620055892483"></p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055864640.png" alt="1620055864640"></p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055834713.png" alt="1620055834713"></p><p>冒领ID：出入口检测不匹配</p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055794604.png" alt="1620055794604"></p></li><li><p>单项奖，中国铁道科学研究院集团有限公司-戚小玉（三维场景设计奖）</p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055772247.png" alt="1620055772247"></p><p><img src="/2019/07/28/ChinaVis_2019_summary/1620055713344.png" alt="1620055713344"></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>对于发现的问题一定要做深入的分析不然可能与正确答案失之交臂，就比如发现某个人员瞬移及跳跃时，重庆大学发现了这个问题，我们队也发现了这个问题，但我们草草结论认为是传感器问题，而重庆大学在认真分析后得出了胸牌盗用复制的正确答案。</li><li>从以上获奖作品中可看出，虽然可能在做比赛时用到的技术不同，但在解决某个问题时大多获奖团队不谋而合的采用了相同的可视化图形，这说明针对解决某一问题时一个好的可视化图形是被普遍认可的，比如在解决场馆时间安排时成都理工大学、重庆大学、东北师范大学、燕山大学、中国铁道科学研究院集团等都用到了场馆人数变化折线图来确定时间安排，这也从侧面说明了针对比赛的某一问题去找到一种正确的可视化图形的重要性。所以比赛之初针对问题去寻找正确的可视化图形非常重要。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    本次ChinaVis挑战赛于7月21-24日在成都举行，由于本人家住成都较近的原因很荣幸能够报名并参加了这次挑战赛会议，期间有各行业的大佬做可视化的前沿发展汇报及最新论文汇报，让我收获颇丰，其详情请关注ChinaVis2019可视化官网。本篇博客主要用来总结本人本次与同学共同参加并完成挑战赛题目的收获与不足，以及参会时记录的挑战赛1的答案详情、听取到的其他获奖作品后的感想，以备自己今后参考所用。&lt;/p&gt;</summary>
    
    
    
    <category term="可视化" scheme="http://example.com/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
    <category term="可视化" scheme="http://example.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="ChinaVIS" scheme="http://example.com/tags/ChinaVIS/"/>
    
  </entry>
  
</feed>
