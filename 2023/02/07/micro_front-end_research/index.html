<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="见三千大山如见我，观十方云海如观尘"><title>微前端技术调研 | Lai Teng's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><header><link rel="stylesheet" type="text/css" href="/css/reward.css"></header><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">微前端技术调研</h1><a id="logo" href="/.">Lai Teng's Blog</a><p class="description">数据可视化 &amp; 前端 &amp; 迁移学习</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">微前端技术调研</h1><div class="post-meta">2023-02-07<span> | </span><span class="category"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2023/02/07/micro_front-end_research/#waline"><span class="waline-comment-count" id="/2023/02/07/micro_front-end_research/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">微前端背景介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E7%94%A8%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">何时用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6"><span class="toc-number">2.</span> <span class="toc-text">微前端主流框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Esingle-spa%E5%88%B0qiankun"><span class="toc-number">2.1.</span> <span class="toc-text">从single-spa到qiankun</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Single-spa"><span class="toc-number">2.1.1.</span> <span class="toc-text">Single-spa</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#qiankun"><span class="toc-number">2.1.2.</span> <span class="toc-text">qiankun</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EWebComponent%E7%9A%84micro-app"><span class="toc-number">2.2.</span> <span class="toc-text">基于WebComponent的micro-app</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AE%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.2.</span> <span class="toc-text">微应用配置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EWebpack5%E7%9A%84ModuleFederation"><span class="toc-number">2.3.</span> <span class="toc-text">基于Webpack5的ModuleFederation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AE%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">微应用配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%A1%8C%E4%B8%9A%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%96%B9%E6%A1%88"><span class="toc-number">3.</span> <span class="toc-text">当前行业中的实践方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#X%E9%9F%B3%E4%B9%90PaaS%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%96%B9%E6%A1%88"><span class="toc-number">3.1.</span> <span class="toc-text">X音乐PaaS微前端方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AC%A2%E8%81%9A%E6%97%B6%E4%BB%A3EMP%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%96%B9%E6%A1%88"><span class="toc-number">3.2.</span> <span class="toc-text">欢聚时代EMP微前端方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%A1%88"><span class="toc-number">3.2.1.</span> <span class="toc-text">基本方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX%E9%87%91%E6%9C%8DALPHA%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%96%B9%E6%A1%88"><span class="toc-number">3.3.</span> <span class="toc-text">XX金服ALPHA微前端方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E8%83%8C%E6%99%AF"><span class="toc-number">3.3.1.</span> <span class="toc-text">业务背景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E6%80%9D%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">总结思考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><p>​    本文针对微前端技术进行调研，主要从微前端背景、主流框架及原理以及当前行业中的一些实践方案三个方面进行介绍，最后给出了一些自己的思考和总结。</p>
<span id="more"></span>

<h3 id="微前端背景介绍"><a href="#微前端背景介绍" class="headerlink" title="微前端背景介绍"></a>微前端背景介绍</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p>​    <a target="_blank" rel="noopener" href="https://micro-frontends.org/">Mirco-frontends</a>官网对微前端定义是：构建一个现代Web应用所需的技术、策略和方法，它具有多个团队独立开发、部署的特性。通俗来讲，微前端就是一种类似于微服务的架构理念，可以将一个复杂的前端应用拆分为更小、更简单的子应用，使得这些子应用可以由不同的团队进行独立的开发和部署。同时它也可以将不同框架（如React、Vue、Angular等）开发的、运行已久的应用进行合并，以达到降低复用成本、减少项目之间的耦合、提升项目扩展性等目的。一个微前端应用通常由一个基座应用（主应用）和多个子应用构成，通过基座应用来管理子应用的加载和卸载。</p>
<p><img src="/2023/02/07/micro_front-end_research/image-20240207171854987.png" alt="image-20240207171854987">微前端具有以下几个核心价值（引用自<a target="_blank" rel="noopener" href="https://qiankun.umijs.org/zh/guide">qiankun官网</a>)：</p>
<ul>
<li><p>技术栈无关：</p>
<p>主框架不限制接入应用的技术栈，微应用具备完全的自主权</p>
</li>
<li><p>独立开发、独立部署：</p>
<p>微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</p>
</li>
<li><p>增量升级：</p>
<p>在面对各种复杂场景时，我们通常很难对一个已存在的系统做全量的技术升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略</p>
</li>
<li><p>独立运行时：</p>
<p>每个微应用之间状态隔离，运行时状态不共享</p>
</li>
</ul>
<h4 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h4><p>​    项目中为什么要引入微前端方案？在上述核心价值中已有所体现。现代的前端应用发展趋势正在变得越来越富功能化、富交互化，已有被维护的项目会随着时间的推进变得越来越庞大、越来越难以维护。开发人员往往会面临以下几个问题：</p>
<ul>
<li>不同的团队间需要使用不同的技术栈开发同一个应用；</li>
<li>每个团队都希望独立开发、独立部署，并且独立部署的应用有更新时如何同步更新其它模块；</li>
<li>新项目中还需要老项目中的代码，如何才能在无侵入的情况下复用老项目中的代码；</li>
</ul>
<p>​    此时，开发人员可以使用微前端架构理念，将一个应用划分成若干个子应用。当路径切换时加载不同的子应用，这样来实现每个子应用的独立，同时也不用受技术栈的限制，解决期待前端团队协同开发的问题。</p>
<h4 id="何时用？"><a href="#何时用？" class="headerlink" title="何时用？"></a>何时用？</h4><p>​    是否需要使用微前端需要根据具体的业务场景来定，但通常情况下在包括但不限于以下的几种场景下使用微前端能得到一个长久的收益：</p>
<ul>
<li><p>零散的活动页面</p>
<p>​    在很多活动场景中，运营需要配置一些重复性的业务，页面间存在雷同性、相似性或由不同的组件拼凑而成的。使用一个配置系统将这些组件进行灵活的管理将大大提高开发的效率，而此时配置系统很适合使用微前端理念来解决。</p>
</li>
<li><p>中台项目</p>
<p>​    面向于公司内部提供一些服务类的产品，会随着功能的丰富和配置系统的增加变得愈发庞大和复杂，使用微前端构建可以得到长久的收益。</p>
</li>
<li><p>大型产品项目</p>
<p>​    便于多个团队协作开发独立部署，减少开发周期。    </p>
</li>
</ul>
<h3 id="微前端主流框架"><a href="#微前端主流框架" class="headerlink" title="微前端主流框架"></a>微前端主流框架</h3><p>​    几乎所有的微前端框架都需要解决两大共性问题：一是应用的加载与切换。包括路由的处理、应用加载的处理和应用入口的选择。二是应用的隔离与通信。包括JS的隔离（副作用隔离）、样式的隔离以及父子应用与子子应用之间的通信问题。围绕着这两大问题出现了如下几种常用的微前端框架/方案：</p>
<h4 id="从single-spa到qiankun"><a href="#从single-spa到qiankun" class="headerlink" title="从single-spa到qiankun"></a>从single-spa到qiankun</h4><p>​    single-spa是一个很好的微前端框架，而qiankun框架就是基于single-spa来实现的，在single-spa的基础上做了一层封装，同时也解决了single-spa的一些缺陷。</p>
<h5 id="Single-spa"><a href="#Single-spa" class="headerlink" title="Single-spa"></a>Single-spa</h5><p>​    使用single-spa首先需要在基座应用中注册所有APP的路由，single-spa会保存各子应用的路由映射关系，并充当微前端控制器Controler。当URL响应时，匹配子应用路由并加载渲染子应用，如下图所示：</p>
<p><img src="/2023/02/07/micro_front-end_research/image-20240207173851674.png" alt="image-20240207173851674"></p>
<p>使用single-spa以Vue脚手架搭建的应用为基座构建微前端项目，实现步骤及关键代码如下：</p>
<ul>
<li><p>在main.js中完成基座配置，其核心是通过<strong>registerApplication</strong>注册子应用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/ main.js</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; registerApplication, start &#125; <span class="keyword">from</span> <span class="string">&#x27;single-spa&#x27;</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> mountApp = <span class="function">(<span class="params">url</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.src = url;</span><br><span class="line">        script.onload = resolve;</span><br><span class="line">        script.onerror = reject;</span><br><span class="line">        <span class="comment">// 通过script标签的方式挂在应用</span></span><br><span class="line">        <span class="keyword">const</span> firstScript = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;script&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 挂载子应用</span></span><br><span class="line">        firstScript.parentNode.insertBefore(script, firstScript);    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> loadApp = <span class="function">(<span class="params">appRouter,appName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 远程加载子应用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">        <span class="comment">// 手动挂在子应用</span></span><br><span class="line">        <span class="keyword">await</span> mountApp(appRouter + <span class="string">&#x27;/js/chunk-venders.js/&#x27;</span>);</span><br><span class="line">        <span class="keyword">await</span> mountApp(appRouter + <span class="string">&#x27;/js/app.js&#x27;</span>);</span><br><span class="line">        <span class="comment">// 获取子应用生命周期</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">window</span>[appName]    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子应用列表</span></span><br><span class="line"><span class="keyword">const</span> appList = [</span><br><span class="line">    &#123;</span><br><span class="line">        name:<span class="string">&#x27;app1&#x27;</span>, <span class="comment">// 子应用名称</span></span><br><span class="line">        app:loadApp(<span class="string">&#x27;http://localhost:8083&#x27;</span>,<span class="string">&#x27;app1&#x27;</span>), <span class="comment">// 挂在子应用</span></span><br><span class="line">        activeWhen:<span class="function"><span class="params">location</span> =&gt;</span> location.pathname.startsWith(<span class="string">&#x27;/app1&#x27;</span>)<span class="comment">// 匹配该子路由的条件</span></span><br><span class="line">        customProps:&#123;&#125; <span class="comment">// 传递给子应用的对象</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name:<span class="string">&#x27;app2&#x27;</span>,</span><br><span class="line">        app:loadApp(<span class="string">&#x27;http://localhost:8082&#x27;</span>,<span class="string">&#x27;app2&#x27;</span>),</span><br><span class="line">        activeWhen:<span class="function"><span class="params">location</span> =&gt;</span> location.pathname.startWith(<span class="string">&#x27;/app2&#x27;</span>),</span><br><span class="line">        customProps:&#123;&#125;    </span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 注册子应用</span></span><br><span class="line">appList.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    registerApplication(item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注册路由并启动基座</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        start()    </span><br><span class="line">    &#125;,</span><br><span class="line">    render:<span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>在子应用中配置生命周期挂在与导出方式。配置的核心是使用single-spa-vue生成字路由配置，并抛出其生命周期函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> singleSpaValue <span class="keyword">from</span> <span class="string">&#x27;single-spa-vue&#x27;</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> appOptions = &#123;</span><br><span class="line">    el:<span class="string">&#x27;#microApp&#x27;</span>,</span><br><span class="line">    router,</span><br><span class="line">    render:<span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不是微应用环境，则启动自身挂在的方式</span></span><br><span class="line"><span class="keyword">if</span>(!process.env.isMicro) &#123;</span><br><span class="line">    <span class="keyword">delete</span> appOption.el</span><br><span class="line">    <span class="keyword">new</span> Vue(appOptions).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基于基座应用，导出生命周期</span></span><br><span class="line"><span class="keyword">const</span> appLifecycle = singleSpaVue(&#123;</span><br><span class="line">    Vue,</span><br><span class="line">    appOptions</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 抛出子应用生命周期</span></span><br><span class="line"><span class="comment">// 启动生命周期函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bootstrap = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> appLifecycle.bootstrap(<span class="function">()=&gt;</span>&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 挂载生命周期函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mount = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> appLifecycle.mount(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卸载生命周期函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> unmount = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> appLifecycle.unmount(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置子应用为umd打包方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">const</span> package = <span class="built_in">require</span>(<span class="string">&#x27;./package.json&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    <span class="comment">// 告诉子应用在这个地址加载静态资源，否则会去基座应用的域名下加载</span></span><br><span class="line">    publicPath:<span class="string">&#x27;//localhost:8082&#x27;</span>,</span><br><span class="line">    <span class="comment">// 开发服务器</span></span><br><span class="line">    devServer:&#123;</span><br><span class="line">        port: <span class="number">8082</span></span><br><span class="line">    &#125;,</span><br><span class="line">    configureWebpack:&#123;</span><br><span class="line">        <span class="comment">// 导出umd格式的包，在全局对象上挂载属性package.name,基座应用需要通过这个全局对象获取一些信息</span></span><br><span class="line">        <span class="comment">// 比如子应用到出的生命周期函数</span></span><br><span class="line">        output:&#123;</span><br><span class="line">            <span class="comment">// library的值在所有子应用中需要唯一</span></span><br><span class="line">            library:package.name,</span><br><span class="line">            libraryTarget:<span class="string">&#x27;umd&#x27;</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置子应用环境变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .env.micro</span></span><br><span class="line">NODE_ENV = development</span><br><span class="line">VUE_APP_BASE_URL = /app2</span><br><span class="line">isMicro = <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    Single-SPA通过路由劫持和导出生命周期钩子函数的方式很好的解决了路由的加载切换和应用接入的问题，但在应用入口的选择、应用隔离（JS隔离和样式隔离）等方面仍有不足。例如，使用JS Entry的方式需要更改打包配置，将整个微应用打包成一个JS发布到静态资源服务器，然后在主应用中配置文件地址告诉single-spa去哪加载微应用，这将导致打包产物体积膨胀、无法并行加载等问题，且该方式侵入性较强。除此之外，Single-SPA并未提供应用之间的通信方案，它仅在注册应用时给微应用注入一些状态信息，后续通讯需要用户自己去实现。</p>
<h5 id="qiankun"><a href="#qiankun" class="headerlink" title="qiankun"></a>qiankun</h5><p>为了解决Single-SPA的一些不足，qiankun在Single-SPA的基础上进行了进一步的扩展，并且保留了Single-SPA中的优秀理念。其主要的扩展如下：</p>
<ul>
<li><p>HTML Entry：JS Entry的方式是把子应用打包成一个entry script，其中css、图片等资源必须都打包到js bundle中导致bundle体积庞大，并且资源无法并行加载。HTML Entry的方式是主应用fetch子应用的html入口文件，去掉html/head/body后，把子节点插入主应用容器中，具有灵活、低成本接入的优点。</p>
</li>
<li><p>JS沙箱：JS 沙箱为每个微应用生成单独的 window proxy 对象，配合 HTML Entry 提供的 JS 脚本执行器 (execScripts) 来实现 JS 隔离，确保微应用之间全局变量/事件不冲突。</p>
</li>
<li><p>CSS样式隔离：提供了两种样式隔离的方案：严格的样式隔离和改变选择器名的方式。严格的样式隔离模式，为每个微应用的容器包裹上一个 shadow dom 节点，从而确保微应用的样式不会对全局造成影响。改变样式名的方式利用css预处理器在编译时生成不冲突的选择器名。</p>
</li>
<li><p>应用间通信：提供了两种通信方法，一种是挂载一个事件总线，在总线上注册监听事件，通过发布订阅模型来实现应用之间的相互通信。另一种基于props，将state 和 onGlobalStateChange通过props传递给子应用，从而实现应用间的通信。</p>
</li>
</ul>
<p>使用qiankun以Vue脚手架搭建主应用、React搭建子应用，实现关键代码如下：</p>
<ul>
<li><p>在主应用中注册微应用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> apps = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;ReactMicroApp&quot;</span>, <span class="comment">// 微应用名称 - 具有唯一性</span></span><br><span class="line">    entry: <span class="string">&quot;//localhost:10100&quot;</span>, <span class="comment">// 微应用入口 - 通过该地址加载微应用</span></span><br><span class="line">    container: <span class="string">&quot;#frame&quot;</span>, <span class="comment">// 微应用挂载节点 - 微应用加载完成后将挂载在该节点上</span></span><br><span class="line">    activeRule: <span class="string">&quot;/react&quot;</span>, <span class="comment">// 微应用触发的路由规则 - 触发路由规则后将加载该微应用</span></span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> apps;</span><br></pre></td></tr></table></figure></li>
<li><p>配置主应用菜单</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  menus = [</span><br><span class="line">    &#123;</span><br><span class="line">      key: <span class="string">&quot;Home&quot;</span>, <span class="comment">// 唯一 Key 值</span></span><br><span class="line">      title: <span class="string">&quot;主页&quot;</span>, <span class="comment">// 菜单标题</span></span><br><span class="line">      path: <span class="string">&quot;/&quot;</span>,  <span class="comment">// 菜单对应的路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      key: <span class="string">&quot;ReactMicroApp&quot;</span>,</span><br><span class="line">      title: <span class="string">&quot;React 主页&quot;</span>,</span><br><span class="line">      path: <span class="string">&quot;/react&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      key: <span class="string">&quot;ReactMicroAppList&quot;</span>,</span><br><span class="line">      title: <span class="string">&quot;React 列表页&quot;</span>,</span><br><span class="line">      path: <span class="string">&quot;/react/list&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置微应用，导出qiankun所需的三个生命周期钩子函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  <span class="comment">// 动态设置 webpack publicPath，防止资源加载出错</span></span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-undef</span></span><br><span class="line">  __webpack_public_path__ = <span class="built_in">window</span>.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;antd/dist/antd.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./public-path&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.jsx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 渲染函数</span></span><br><span class="line"><span class="comment"> * 两种情况：主应用生命周期钩子中运行 / 微应用单独启动时运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 独立运行时，直接挂载应用</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  render();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。</span></span><br><span class="line"><span class="comment"> * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ReactMicroApp bootstraped&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  render(props);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.unmountComponentAtNode(<span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置路由命名空间，确保主应用能正常加载子应用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// micro-app-react/src/App.jsx</span></span><br><span class="line"><span class="keyword">const</span> BASE_NAME = <span class="built_in">window</span>.__POWERED_BY_QIANKUN__ ? <span class="string">&quot;/react&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 设置路由命名空间</span></span><br><span class="line">    &lt;Router basename=&#123;BASE_NAME&#125;&gt;&#123;<span class="comment">/* ... */</span>&#125;&lt;/Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>修改webpack配置，使生命周期钩子函数能被qiankun识别。由于React脚手架对webpack配置做了隐藏，因此我们可以借助react-app-rewired来实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 config-overrides.js 文件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  webpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 微应用的包名，这里与主应用中注册的微应用名称一致</span></span><br><span class="line">    config.output.library = <span class="string">`ReactMicroApp`</span>;</span><br><span class="line">    <span class="comment">// 将你的 library 暴露为所有的模块定义下都可运行的方式</span></span><br><span class="line">    config.output.libraryTarget = <span class="string">&quot;umd&quot;</span>;</span><br><span class="line">    <span class="comment">// 按需加载相关，设置为 webpackJsonp_VueMicroApp 即可</span></span><br><span class="line">    config.output.jsonpFunction = <span class="string">`webpackJsonp_ReactMicroApp`</span>;</span><br><span class="line">    config.resolve.alias = &#123;</span><br><span class="line">      ...config.resolve.alias,</span><br><span class="line">      <span class="string">&quot;@&quot;</span>: path.resolve(__dirname, <span class="string">&quot;src&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  devServer: <span class="function"><span class="keyword">function</span> (<span class="params">configFunction</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">proxy, allowedHost</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> config = configFunction(proxy, allowedHost);</span><br><span class="line">      <span class="comment">// 关闭主机检查，使微应用可以被 fetch</span></span><br><span class="line">      config.disableHostCheck = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 配置跨域请求头，解决开发环境的跨域问题</span></span><br><span class="line">      config.headers = &#123;</span><br><span class="line">        <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 配置 history 模式</span></span><br><span class="line">      config.historyApiFallback = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="基于WebComponent的micro-app"><a href="#基于WebComponent的micro-app" class="headerlink" title="基于WebComponent的micro-app"></a>基于WebComponent的micro-app</h4><p>与qiankun不同，micro-app并没有沿袭single-spa的思路而是借鉴了WebComponent的思想，通过CustomElement结合自定义的ShadowDom，将微前端封装成一个类WebComponent组件，从而实现微前端的组件化渲染。并且由于自定义ShadowDom的隔离特性，micro-app不需要像single-spa和qiankun一样要求子应用修改渲染逻辑并暴露出方法，也不需要修改webpack配置，是目前接入微前端成本最低的方案。</p>
<h5 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h5><p>​    Web Components 是一套不同的技术，允许你创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 web 应用中使用它们。其主要由三个部分组成Custom elements（自定义元素）、Shadow DOM（影子 DOM）和HTML templates（HTML 模板），通过一起使用来创建封装功能的定制元素，且不用担心代码冲突（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components#%E4%BE%8B%E5%AD%90">引用自MDN官网</a>）。详细定义可移步至MDN官网阅读。</p>
<p><img src="/2023/02/07/micro_front-end_research/image-20240207175123787.png" alt="image-20240207175123787"></p>
<ul>
<li>使用方便：</li>
</ul>
<p>​    可以将所有功能都封装到一个类WebComponent组件中，从而实现在基座应用中嵌入一行代码即可渲染一个微前端应用。同时还提供了js沙箱、样式隔离、元素隔离、预加载、数据通信、静态资源补全等一系列完善的功能。</p>
<ul>
<li>零依赖：</li>
</ul>
<p>​    micro-app没有任何依赖，这赋予它小巧的体积和更高的扩展性。</p>
<ul>
<li>兼容所有框架：</li>
</ul>
<p>​    为了保证各个业务之间的独立开发、独立部署的能力，micro-app做了许多兼容，在任何技术框架中都可以正常运行。</p>
<h5 id="微应用配置"><a href="#微应用配置" class="headerlink" title="微应用配置"></a>微应用配置</h5><ul>
<li><p>基座配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> microApp <span class="keyword">from</span> <span class="string">&#x27;@micro-zoe/micro-app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appName = <span class="string">&#x27;my-app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预加载</span></span><br><span class="line">microApp.preFetch([</span><br><span class="line">  &#123; <span class="attr">name</span>: appName, <span class="attr">url</span>: <span class="string">&#x27;xxx&#x27;</span> &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基座向子应用数据通信</span></span><br><span class="line">microApp.setData(appName, &#123; <span class="attr">type</span>: <span class="string">&#x27;新的数据&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// 获取指定子应用数据</span></span><br><span class="line"><span class="keyword">const</span> childData = microApp.getData(appName)</span><br><span class="line"></span><br><span class="line">microApp.start(&#123;</span><br><span class="line">  <span class="comment">// 公共文件共享</span></span><br><span class="line">  globalAssets: &#123;</span><br><span class="line">    js: [<span class="string">&#x27;js地址1&#x27;</span>, <span class="string">&#x27;js地址2&#x27;</span>, ...], <span class="comment">// js地址</span></span><br><span class="line">    css: [<span class="string">&#x27;css地址1&#x27;</span>, <span class="string">&#x27;css地址2&#x27;</span>, ...], <span class="comment">// css地址</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>子应用配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> microApp <span class="keyword">from</span> <span class="string">&#x27;@micro-zoe/micro-app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appName = <span class="string">&#x27;my-app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子应用运行时，切换静态资源访问路径</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__MICRO_APP_ENVIRONMENT__) &#123;</span><br><span class="line">  __webpack_public_path__ = <span class="built_in">window</span>.__MICRO_APP_PUBLIC_PATH__</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子应用向基座发送数据</span></span><br><span class="line"><span class="comment">// dispatch只接受对象作为参数</span></span><br><span class="line"><span class="built_in">window</span>.microApp.dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;子应用发送的数据&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// 获取基座数据</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="built_in">window</span>.microApp.getData() <span class="comment">// 返回基座下发的data数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能优化，umd模式</span></span><br><span class="line"><span class="comment">// 如果子应用渲染和卸载不频繁，那么使用默认模式即可，如果子应用渲染和卸载非常频繁建议使用umd模式</span></span><br><span class="line"><span class="comment">// 将渲染操作放入 mount 函数 -- 必填</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将卸载操作放入 unmount 函数 -- 必填</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.unmountComponentAtNode(<span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微前端环境下，注册mount和unmount方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__MICRO_APP_ENVIRONMENT__) &#123;</span><br><span class="line">  <span class="built_in">window</span>[<span class="string">`micro-app-<span class="subst">$&#123;<span class="built_in">window</span>.__MICRO_APP_NAME__&#125;</span>`</span>] = &#123; mount, unmount &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 非微前端环境直接渲染</span></span><br><span class="line">  mount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>路由配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Switch, Route &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">AppRoute</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 设置基础路由，子应用可以通过window.__MICRO_APP_BASE_ROUTE__获取基座下发的baseroute，</span></span><br><span class="line">    <span class="comment">// 如果没有设置baseroute属性，则此值默认为空字符串</span></span><br><span class="line">    &lt;BrowserRouter basename=&#123;<span class="built_in">window</span>.__MICRO_APP_BASE_ROUTE__ || <span class="string">&#x27;/&#x27;</span>&#125;&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/BrowserRouter&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    综上所述，Web Components是有能力以组件加载的方式将微应用整合在一起作为微前端的一种手段，但不幸的是，Web Components是浏览器的新特性，所以它的兼容性不是很好，如果有兼容性要求的项目还是无法使用，具体请查看<a target="_blank" rel="noopener" href="https://caniuse.com/?search=WebComponents">can i use</a>。</p>
<h4 id="基于Webpack5的ModuleFederation"><a href="#基于Webpack5的ModuleFederation" class="headerlink" title="基于Webpack5的ModuleFederation"></a>基于Webpack5的ModuleFederation</h4><h5 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h5><p>​    Module Federation是webpack5提出的概念，用于解决多个应用之间的代码共享的问题，让使用者更加优雅的实现跨应用的代码共享。其解决问题的中心思想与微前端的思想类似，即把一个应用拆分成多个应用，每个应用可独立开发，独立部署，一个应用可动态的加载并运行另一个应用的代码，并实现应用之间的依赖共享。</p>
<p>为了实现这些功能，Module Federation在设计上提出了以下几个概念：</p>
<ul>
<li><p>Container：被ModuleFederationPlugin打包出来的模块被称为Container。通俗来讲就是，如果项目中一个应用适用了ModuleFederationPlugin构建，那么它就一个Container模块，它可以加载其他的Container，也可以被其他的Container所加载。</p>
</li>
<li><p>Host&amp;Remote：</p>
<ul>
<li>以消费者和生产者的角度看，Container又可被称作Host和Remote。</li>
<li>Host：消费方，它可以动态的加载并运行其他的Container的代码。</li>
<li>Remote：提供方，用于暴露属性（如组件、方法等）供Host使用。</li>
</ul>
</li>
</ul>
<p>​    对于一个container来说，Host和Remote是相对的，一个Container既可以作为Host，又可以作为Remote使用。</p>
<ul>
<li>Shared：一个 Container 可以 与其他 Container 可以共享的第三方依赖，使你的代码中不用重复加载同一份依赖，也就是共享依赖。</li>
</ul>
<h5 id="微应用配置-1"><a href="#微应用配置-1" class="headerlink" title="微应用配置"></a>微应用配置</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ModuleFederationPlugin = <span class="built_in">require</span>(<span class="string">&quot;webpack/lib/container/ModuleFederationPlugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 其他webpack配置...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ModuleFederationPlugin(&#123;</span><br><span class="line">        name: <span class="string">&#x27;empBase&#x27;</span>,</span><br><span class="line">        library: &#123; <span class="attr">type</span>: <span class="string">&#x27;var&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;empBase&#x27;</span> &#125;,</span><br><span class="line">        filename: <span class="string">&#x27;emp.js&#x27;</span>, <span class="comment">// 入口文件名称</span></span><br><span class="line">        remotes: &#123; <span class="comment">// 如果把这一模块当作基座模块的话，这里应该配置其他子应用模块的入口文件</span></span><br><span class="line">          app_two: <span class="string">&quot;app_two_remote&quot;</span>,</span><br><span class="line">          app_three: <span class="string">&quot;app_three_remote&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        exposes: &#123;   <span class="comment">//暴露可访问的组件</span></span><br><span class="line">          <span class="string">&#x27;./Component1&#x27;</span>: <span class="string">&#x27;src/components/Component1&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;./Component2&#x27;</span>: <span class="string">&#x27;src/components/Component2&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//共享依赖，其他模块不需要再次下载，便可使用</span></span><br><span class="line">        shared: [<span class="string">&quot;react&quot;</span>, <span class="string">&quot;react-dom&quot;</span>,<span class="string">&quot;react-router-dom&quot;</span>]</span><br><span class="line">      &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其构建过程如下：</p>
<ul>
<li>首先，Module Federation会让webpack以filename作为文件名生成文件。</li>
<li>其次，文件中以var的形式暴露了一个名为name的全局变量，其中包含了expose以及shared中配置的内容。</li>
<li>最后，作为host时，先通过remote的init方法将自身shared写入remote中，再通过get获取remote中expose的组件，而作为remote时，判断host中是否有可用的共享依赖，若有，则加载host的这部分依赖，若无，则加载自身依赖。</li>
</ul>
<h3 id="当前行业中的实践方案"><a href="#当前行业中的实践方案" class="headerlink" title="当前行业中的实践方案"></a>当前行业中的实践方案</h3><h4 id="X音乐PaaS微前端方案"><a href="#X音乐PaaS微前端方案" class="headerlink" title="X音乐PaaS微前端方案"></a>X音乐PaaS微前端方案</h4><p><img src="/2023/02/07/micro_front-end_research/image-20240207175435482.png" alt="image-20240207175435482"></p>
<p>​    云音乐微前端平台针对于云音乐的CMS场景，提出了可配置式的微前端平台化设计，包括用于管理主子应用的 <a target="_blank" rel="noopener" href="https://p.fn.netease.com/">PaaS 管理平台</a>，可对主子应用的引用关系以及主子应用的路由、权限等配置进行管理。以及基于 qiankun 实现的根据下发配置渲染微应用与菜单的外框架（主应用）与微应用（子应用）。</p>
<p>​    在云音乐 CMS 中，对微前端做了以下约定：</p>
<ul>
<li>以页面为粒度拆分子应用，主应用是多个子应用部分页面的组合；</li>
<li>主应用对页面路由、权限进行管理；</li>
</ul>
<p>​    云音乐CMS的主要场景是需要对现有存量的基于umi 2、umi 3以及regluar搭建的前端应用进行接入管理，其核心价值在于可管理微应用与编排菜单的 PaaS 平台。因此，运行时的微前端实现方案主要以umi为构建框架，在基于umi官方提供的qiankun插件基础上，编写并封装适配于云音乐CMS场景的umi3和regular插件，其插件主要解决了如下几个问题：</p>
<ul>
<li>扩展插件功能。为应用默认导出在runtime.js中qiankun需要的方法，并将主应用传递给子应用的参数写入子应用的全局变量中，便于需要时调用。此外，在构建完成后生成菜单并上报平台的功能。</li>
<li>处理base路由问题。在微前端场景下，多个子应用之间可能存在路由重合的场景。因此，需要对子应用路由的 base path进行改写，并拼接上主子应用的 base path。</li>
<li>解决路由反复横跳问题。将初始化路由监听由bootstrap 阶段调整到mount 阶段，并在 history 的 push() 方法上做拦截。</li>
</ul>
<p>使用方法：X音乐CMS文档：<a target="_blank" rel="noopener" href="https://p.fn.netease.com/#/use">https://p.fn.netease.com/#/use</a></p>
<h4 id="欢聚时代EMP微前端方案"><a href="#欢聚时代EMP微前端方案" class="headerlink" title="欢聚时代EMP微前端方案"></a>欢聚时代EMP微前端方案</h4><p><img src="/2023/02/07/micro_front-end_research/image-20240207175542935.png" alt="image-20240207175542935"></p>
<p>​    在中台开发过程中，有许多的配置系统需要去开发和维护， 这些配置系统之间有很多公用模块需要公用的。对于这些公用的模块，为了节约第二次开发和第三次开发的人力资源，需要考虑去把这些共享组件抽取出来作为公共的资源。解决该问题的常用方法是将业务子模块抽取为npm包，但对于该种方式来说，其具有以下痛点：</p>
<ul>
<li>更新流程繁琐。 当公用模块迭代的业务系统较多时，每次更新npm包版本后都需要更新多个应用的npm包的版本。</li>
<li>构建速度慢。 一个应用系统中可能应用到了多个以npm包形式引入的业务子模块， 随着npm包越来越多的情况下， 同步构建的体积会越来越大、构建时间变长甚至发布的流程也会越来越慢。</li>
<li>应用迭代麻烦。例如，对于中台业务场景通常需要自定义一个统一UI风格的骨架，在实际项目中引用并填充业务内容。但当模版更新某些功能后，已有的项目无法自动的更新模版需要手动更新，并且可能需要做一些冲突处理。</li>
</ul>
<p>​    由于该业务场景主要是希望对业务中的共享模块做到独立开发、独立部署、一键更新等特性，对于qiankun和single-spa来说，同一个技术栈具有状态不共享、部分模块可能需要改造才能调用，这些会增加部署、维护、改造的成本，因此采用模块联邦的方式实现微前端更贴近其业务。</p>
<h5 id="基本方案"><a href="#基本方案" class="headerlink" title="基本方案"></a>基本方案</h5><p><img src="/2023/02/07/micro_front-end_research/image-20240207175636517.png" alt="image-20240207175636517"></p>
<p>EMP是采用Webpack5的Module Federation实现的微前端方案，其生态总体框架吧如上所示。</p>
<ul>
<li>基于webpack 5、Module Federation、TypeScript搭建EMP脚手架，仓库地址：<a target="_blank" rel="noopener" href="https://github.com/efoxTeam/emp%E3%80%82">https://github.com/efoxTeam/emp。</a></li>
<li>使用脚手架搭建项目，实现构建、打包、webpack配置、Medule Federation配置等一系列配置。</li>
<li>搭建一个基站base（可以理解成一个主应用项目）， 用于放置公用组件如ui组件、业务组件等。</li>
<li>搭建具体的业务应用，如App1、App2等，这些业务应用就可以共享base中的公用业务组件，同时App1和App2之间也可以相互共享业务组件，并且当组件更新后会同步到相应的应用。</li>
</ul>
<p>使用方法：</p>
<p>​    emp-cli接入文档：<a target="_blank" rel="noopener" href="https://github.com/efoxTeam/emp/blob/main/packages/emp-cli/README-zh_CN.md">https://github.com/efoxTeam/emp/blob/main/packages/emp-cli/README-zh_CN.md</a></p>
<h4 id="XX金服ALPHA微前端方案"><a href="#XX金服ALPHA微前端方案" class="headerlink" title="XX金服ALPHA微前端方案"></a>XX金服ALPHA微前端方案</h4><h5 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h5><p>为了满足大型中台项目的开发，要解决如下问题：</p>
<ul>
<li>将不同的业务子系统集中到一个大平台上统一对外开放；</li>
<li>给不同的用户赋予不同的权限让其能够访问平台的特定业务模块，同时禁止其访问物权限的业务模块；</li>
<li>快速接入新的子系统，并对子系统进行版本管理，保证功能同步；</li>
<li>针对于老系统如何实现从Backbone技术栈到React技术栈或Vue技术栈的平滑升级；</li>
</ul>
<p>​    使用微前端方案可以很好的解决以上问题，但对于qiankun和Single-Spa框架存在以下问题：</p>
<ul>
<li>single-spa中所有的子项目都必须存在与同一域下的仓库中；</li>
<li>对于single-spa和qiankun来说，他们存在的一个共同的问题是都有一套自己的路由机制，因此如果旧项目中使用的是react-router就必须对旧的项目中的router进行重构；</li>
</ul>
<p>​    因此，ALPHA系统基于single-spa的思想，重构了一套微前端方案，使得子系统发布不受约束、独立部署、同步更新的同时，非侵入式的整合使用React、Angular、Vue等前端框架搭建的中后台项目。</p>
<p><img src="/2023/02/07/micro_front-end_research/image-20240207175743647.png" alt="image-20240207175743647"></p>
<p>针对于以上需求，APLHA前端方案通过如下过程实现：</p>
<ul>
<li>封装了一套自己的脚手架，在脚手架中设定适合自身的打包配置；</li>
<li>使用UC系统管理应用的权限，创建项目前需要在UC中创建对应的项目并设置权限；</li>
<li>以js文件为子应用入口文件，将子应用打包生成 <strong>${sourceKey}.js</strong> 文件与**${sourceKey}.css<strong>文件，并同时使用 <strong>webpack</strong> 的 <strong>ManifestPlugin</strong>生成自述</strong>mapping.json**文件；</li>
<li>在APLHA系统中加入项目的相关配置，当子应用被加载时，通过http请求的方式获取mapping.json自述文件，通过layout中的方法组合并进行模版渲染；</li>
<li>使用消息订阅与发布的方式实现layout与子系统之间的通信；</li>
</ul>
<p><img src="/2023/02/07/micro_front-end_research/image-20240207175831323.png" alt="image-20240207175831323"></p>
<p>通过该方法，ALPLHA具有较高的可配置性，可以实现三种不同场景需求：</p>
<ul>
<li>不使用ALPHA提供的layout和vendor，完全独立渲染；</li>
<li>使用ALPHA提供的layout和vendor，子项目仅渲染内容区；</li>
<li>使用ALPHA提供的layout，子项目有自己的vendor.js；</li>
</ul>
<h3 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h3><p>综上所述，现有的几种微前端实现方法与框架可总结如下：</p>
<ul>
<li>iframe</li>
<li>Single-Spa</li>
<li>qiankun</li>
<li>mirco-app（Web Components）</li>
<li>EMP（Module Federation）</li>
</ul>
<p>其中，这些解决方案各有利弊：</p>
<ul>
<li>iframe：可以直接加载其他应用，但无法做到单页导致许多功能无法正常在主应用中展示。</li>
<li>Single-Spa：很好的解决了路由的加载切换和应用接入的问题，但在应用入口的选择、应用隔离（JS隔离和样式隔离）等方面仍有不足。并且框架没有提供应用之间的通信方案，需要用户手动实现。</li>
<li>qiankun：结合了Single-Spa的优点并弥补了其缺陷。基本上可以称为单页版的iframe，具有沙箱隔离及资源预加载的特点，几乎无可挑剔。</li>
<li>mirco-app（Web Components）：Web Components是浏览器提供给开发者的能力，能在单页中实现微前端，但是考虑到时浏览器的新特性，故存在兼容性问题，微前端方面的探索也不成熟，只能作为面向未来的微前端手段。</li>
<li>EMP（Module Federation）：在实现微前端的基础上，扩充了跨应用状态共享、跨框架组件调用、远程拉取ts声明文件、动态更新微应用等能力。同时，第三方依赖的共享，使代码尽可能地重复利用，减少加载的内容。但不足之处在于目前无法覆盖所有前端框架。</li>
</ul>
<p>​    对比三个实践场景，我的感受是：没有最好的微前端框架，只有最适用的业务场景。云音乐CMS微前端方案直接利用现成的qiankun插件进行改造，既满足了对存量应用的接入、新应用的独立开发部署等需求，又极大的节约了改造成本。相比于欢聚时代EMP方案，他们的需求是希望在能够独立开发部署的同时，降低共享组件的维护成本及构建、更新效率，因此选择Module Federation无疑更加贴近需求。而对于贝壳金服的APLHA方案，需求主要关注于老应用的平滑升级及非侵入式的路由接入，因此重构了一套适用于自己的微前端方案。所以，针对于主要业务场景选择最合适的微前端方案最为重要，对于后续的细微不足可以慢慢的弥补。例如，云音乐CMS在后续的改造过程中，对于页面初始化加载速度慢的问题，通过提供sdk接入主应用的形式得到了解决，而对于共享组件复用的问题可以以构建subtree的形式得到解决。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://micro-frontends.org/">Micro Frontends 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://zh-hans.single-spa.js.org/docs/getting-started-overview">single-spa官网</a></li>
<li><a target="_blank" rel="noopener" href="https://qiankun.umijs.org/zh/guide">Qiankun官网</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components#%E4%BE%8B%E5%AD%90">WebComponents-MDN官网</a></li>
<li><a target="_blank" rel="noopener" href="http://cangdu.org/micro-app/docs.html#/">micro-app官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/efoxTeam/emp/wiki/%E3%80%8Amodule-Federation%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E3%80%8B">module-Federation原理学习</a></li>
<li><a target="_blank" rel="noopener" href="https://p.fn.netease.com/#/use">云音乐中后台PaaS</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6891532248269783054">EMP微前端方案</a></li>
</ul>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功！"></script><a class="pos-f tr3" id="github" href="https://github.com/Laighten" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/aliPay.jpg"></li><li id="WeChat" qr="/img/wechatPay.jpg"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E5%90%8E%E5%8F%B0/" rel="tag">中后台</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul></div><div class="post-nav"><a class="pre" href="/2023/08/25/visual_meeting_collection/">可视化相关会议整理</a><a class="next" href="/2021/09/06/division_and_synthesis_mechanism/">分层和合成机制</a></div><div class="nofancybox" id="waline"></div><script src="//unpkg.com/@waline/client@v2/dist/waline.js"></script><link rel="stylesheet" type="text/css" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script>let metaInfo = ['nick', 'mail', 'link']
let requiredMeta = 'nick,mail'.split(',').filter(item => {
  return metaInfo.indexOf(item) > -1
})
Waline.init({
  el: '#waline',
  comment: true,
  serverURL: 'https://waline.laighten.cn',
  pageSize: '30',
  wordLimit: '500',
  requiredMeta,
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/laiteng2.jpg"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/Laighten" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/">可视化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BA%E6%96%87/">论文</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BA%E6%96%87%E6%A6%82%E8%A7%88/">论文概览</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/ES/" style="font-size: 15px;">ES</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15px;">面试</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/" style="font-size: 15px;">可视化</a> <a href="/tags/ChinaVIS/" style="font-size: 15px;">ChinaVIS</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" style="font-size: 15px;">浏览器工作原理</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">笔记</a> <a href="/tags/%E6%B5%99%E5%A4%A7%E5%8F%AF%E8%A7%86%E5%8C%96%E6%9A%91%E6%9C%9F%E7%8F%AD2020/" style="font-size: 15px;">浙大可视化暑期班2020</a> <a href="/tags/%E4%B8%AD%E5%90%8E%E5%8F%B0/" style="font-size: 15px;">中后台</a> <a href="/tags/%E8%AE%BA%E6%96%87/" style="font-size: 15px;">论文</a> <a href="/tags/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">迁移学习</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/02/16/web_pdf_editor/">web端pdf编辑工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/08/25/visual_meeting_collection/">可视化相关会议整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/07/micro_front-end_research/">微前端技术调研</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/06/division_and_synthesis_mechanism/">分层和合成机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/26/front-end_algorithm_questions/">搞定前端手写题</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/04/visual_journal_summary/">可视化学术期刊汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/04/overview_of_paper/">论文概览</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/03/high_dimensional_data_visualization/">高维数据可视化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/23/paper_read_2021-04-23/">论文阅读-2021-04-23</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/22/visualization_related_tools/">可视化使用工具总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><div id="widget-waline-list"></div><script type="text/javascript" id="recent-comment" serverURL="https://waline.laighten.cn" count="5" src="/js/recent-comments.js?v=1.0.0" async="async"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://vis.pku.edu.cn/blog/" title="北大可视化实验室" target="_blank">北大可视化实验室</a><ul></ul><a href="https://zjuvag.org/blog/" title="浙大可视化实验室" target="_blank">浙大可视化实验室</a><ul></ul><a href="https://www.zhihu.com/people/shan-da-ke-shi-hua-shi-yan-shi" title="山东大学可视化实验室（知乎）" target="_blank">山东大学可视化实验室（知乎）</a><ul></ul><a href="http://scuvis.org/" title="川大可视化实验室" target="_blank">川大可视化实验室</a><ul></ul><a href="https://www.zhihu.com/column/360vislab" title="奇安信雷尔可视化平台（知乎）" target="_blank">奇安信雷尔可视化平台（知乎）</a><ul></ul><a href="https://www.zhihu.com/column/musicfe" title="网易云音乐技术团队（知乎）" target="_blank">网易云音乐技术团队（知乎）</a><ul></ul><a href="https://divis.cn/" title="张迪（可视化&amp;人机交互）" target="_blank">张迪（可视化&amp;人机交互）</a><ul></ul><a href="https://github.com/jindongwang/transferlearning" title="王晋东（transferlearning）" target="_blank">王晋东（transferlearning）</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Lai Teng's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>